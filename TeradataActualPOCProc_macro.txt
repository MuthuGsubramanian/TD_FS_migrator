"RequestText"
replace procedure  edw_etl.lh2_deltac_sum_c_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100),  extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of extension table: cliid , shiftindex, ddbkey ( Is actually driving table's ID columns)
* PURPOSE : Load the lh2_deltac_sum_c_sp collection table from  lh2_deltac_sum_etl view based on dw_modify_ts of base table  edw_target.lh2_load_c 
*                  
* Usage :  
call   edw_etl.lh2_deltac_sum_c_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,43195,1554590','FULL' );
call   edw_etl.lh2_deltac_sum_c_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
--Step 1 : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
--Step 2 : Delete lh_target_load_shift_new table for shiftindex and cliid, 
			for which we are going to rebuild the table
--Step 3: Delete lh_target_time_shift_new table for shiftindex and cliid,
			for which we are going to rebuild the table
--Step 4 : Insert lh_target_load_shift_new table for shiftindex and cliid used as parameter for the procedure 
--Step 5 : Insert lh_target_time_shift_new table for shiftindex and cliid used as parameter for the procedure 
--Step 6: Delete the delta c  stage table
--Step 7: insert the data set into stage table based on the filter condition
--Step 8: merge into target table
--Step 9: Capture the deleted rows
--Step 10: Cleanup the target table 
--Step 11: update the di job contorl entry ts base table 

While upgrading Dispatch 6 for the last site, We can remove the process of restricting the number of shift to be process.
Currently we have legacy job which is causing us to reprocess 30 days of data,.

* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D                Initial version
*    2019-07-30       Anandhi P         Included timestamp columns (timefull_ts, load_timearrive_ts, timeload_ts, beginspot_ts, dump_timearrive_ts, timedump_ts, timeempty_ts)
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/  

declare proc_var_dw_modify_ts varchar(19) ;
--declare proc_var_rt_max_dw_load_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);
declare proc_var_filter_list_or_list varchar(32000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_deltac_sum_c_sp');
set proc_var_di_last_run_ts = ( select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_deltac_sum_c_sp');
-- commented because of performance issue set proc_var_rt_max_dw_load_ts =  (select max(dw_modify_ts) from edw_target.lh2_load_c   where shiftindex=shiftindex and dw_logical_delete_flag ='N'  ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
--Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
			delete edw_stage.lh2_deltac_sum_shift_pre_stage;
			call dbc.sysexecsql (' lock table edw_target.lh2_load_c   for access  '
			||' lock table edw_target.lh2_dump_c   for access  '
			||' lock table edw_target.lh2_location_c   for access  '
			||' lock table edw_target.lh2_oper_list_c   for access  '
			||' insert into edw_stage.lh2_deltac_sum_shift_pre_stage '
			||' (cliid,shiftindex)  '
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_load_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			||' and ' || proc_var_filter_list  ||' group by 1,2 '
			||'union'
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_dump_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			||' and ' || proc_var_filter_list  ||' group by 1,2'
			||'union'
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_location_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			||' and ' || proc_var_filter_list  ||' group by 1,2'
			||'union'						
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_oper_list_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			||' and ' || proc_var_filter_list  ||' group by 1,2 ;'
			);
			
		else 
  	--                 if  (select cast( proc_var_rt_max_dw_load_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
    --                        then
    --                      set proc_var_rt_max_dw_load_ts = proc_var_di_last_run_ts ;
    --                end if;
--Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
			delete edw_stage.lh2_deltac_sum_shift_pre_stage;
			call dbc.sysexecsql (' lock table edw_target.lh2_load_c   for access  '
			||' lock table edw_target.lh2_dump_c   for access  '
			||' lock table edw_target.lh2_location_c   for access  '
			||' lock table edw_target.lh2_oper_list_c   for access  '
			||' insert into edw_stage.lh2_deltac_sum_shift_pre_stage '
			||' (cliid,shiftindex)  '
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_load_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			--||' and shiftdate >= current_date - 45  group by 1,2 ;'
			||' and dw_modify_ts >=  timestamp ''' || proc_var_di_last_run_ts  ||'''  group by 1,2 '
			||'Union'
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_dump_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			--||' and shiftdate >= current_date - 45  group by 1,2 ;'
			||' and dw_modify_ts >=  timestamp ''' || proc_var_di_last_run_ts  ||'''  group by 1,2 '
			||'Union'
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_location_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			--||' and shiftdate >= current_date - 45  group by 1,2 ;'
			||' and dw_modify_ts >=  timestamp ''' || proc_var_di_last_run_ts  ||'''  group by 1,2 '
			||'Union'
			||' select	 cliid ,shiftindex' 
			||' from edw_target.lh2_oper_list_c   '
			||' where	shiftindex = shiftindex '
			||' and dw_logical_delete_flag =''N'' '
			--||' and shiftdate >= current_date - 45  group by 1,2 ;'
			||' and dw_modify_ts >=  timestamp ''' || proc_var_di_last_run_ts  ||'''  group by 1,2 ;'
			);
end if;

 
begin request
--Step 2 : Delete lh_target_load_shift_new table for shiftindex and cliid, for which we are going to rebuilt the table
delete  prod_pddw.lh_target_load_shift_new  where ( shiftindex, cliid) in   ( select shiftindex, cliid from  edw_stage.lh2_deltac_sum_shift_pre_stage group by 1,2 ) ;
  
 --Step 3: Delete lh_target_time_shift_new table for shiftindex and cliid, for which we are going to rebuilt the table
delete  prod_pddw.lh_target_time_shift_new  where ( shiftindex, cliid) in   ( select shiftindex, cliid from  edw_stage.lh2_deltac_sum_shift_pre_stage  group by 1,2 ) ;

end request;
-- Do table inserts into shift tables from base tables via shiftindex 
--  prod_pddw.lh_target_load_shift ETL 
begin request
--Step 4 : Insert lh_target_load_shift_new table for shiftindex and cliid used as parameter for the procedure 
insert into prod_pddw.lh_target_load_shift_new
		(
cliid
,eqmttype#
,shiftindex
,site_code
,fleet
,ops_portal_euip_grp
,ops_portal_equip_grp_id
,size_cu_yd
,secs_per_pass
,idle_time
,spot_time
,load_time
,dump_time_dump
,dump_time_crusher
,dump_time_upper_limiit
,spot_time_upper_limiit
,flat_loaded
,down_loaded
,up_loaded
,flat_empty
,up_empty
,down_empty
,hours_per_day
,min_payload
,target_payload
,target_payload_range
,measure_43_constant
,efh_conv_downhill
,efh_conv_uphill
,payload_comp_target
,lower_tar_prod
,upper_tar_prod
,last_modified_ts
 		)
select 
	  t.cliid
	, tr.eqmttype#
	, t.shiftindex
	, tr.site_code
	, tr.fleet
	, tr.ops_portal_euip_grp
	, tr.ops_portal_equip_grp_id
	, tr.size_cu_yd
	, tr.secs_per_pass
	, tr.idle_time
	, tr.spot_time
	, tr.load_time
	, tr.dump_time_dump
	, tr.dump_time_crusher
	, tr.dump_time_upper_limiit
	, tr.spot_time_upper_limiit
	, tr.flat_loaded
	, tr.down_loaded
	, tr.up_loaded
	, tr.flat_empty
	, tr.up_empty
	, tr.down_empty
	, tr.hours_per_day
	, tr.min_payload
	, tr.target_payload
	, tr.target_payload_range
	, tr.measure_43_constant
	, tr.efh_conv_downhill
	, tr.efh_conv_uphill
	, tr.payload_comp_target
	, tr.lower_tar_prod
	, tr.upper_tar_prod
	, cast(proc_var_dw_modify_ts as timestamp(0)) as  last_modified_ts
from prod_pddw.lh_target_load_base_new tr 
inner join   edw_stage.lh2_deltac_sum_shift_pre_stage  as t 
on tr.cliid = t.cliid
where t.shiftindex >= tr.start_shiftindex 
and t.shiftindex <= tr.end_shiftindex ;



--  prod_pddw.lh_target_time_shift ETL 
--Step 5 : Insert lh_target_time_shift_new table for shiftindex and cliid used as parameter for the procedure 
insert into prod_pddw.lh_target_time_shift_new
		(
cliid
,shovel_eqmttype#
,ops_portal_shvl_grp_id
,truck_eqmttype#
,ops_portal_trck_grp_id
,shiftindex
,site_code
,target_load_time
,last_modified_ts
 		)
select 
		t.cliid
		,tr.shovel_eqmttype#
		,tr.ops_portal_shvl_grp_id
		,tr.truck_eqmttype#
		,tr.ops_portal_trck_grp_id
		,t.shiftindex
		,tr.site_code
		,tr.target_load_time
		, cast(proc_var_dw_modify_ts as timestamp(0)) as  last_modified_ts
from prod_pddw.lh_target_time_base_new tr 
inner join   edw_stage.lh2_deltac_sum_shift_pre_stage  as t 
on tr.cliid = t.cliid
where t.shiftindex >= tr.start_shiftindex 
and t.shiftindex <= tr.end_shiftindex ;



--Step 6: Delete the delta c  stage table

delete edw_stage.lh2_deltac_sum_pre_stage;
delete edw_stage.lh2_deltac_sum;
end request;

--Step 7: insert the data set into stage table based on the filter condition
insert into edw_stage.lh2_deltac_sum_pre_stage ( 
shiftindex,
shiftdate,
site_code,
cliid,
ddbkey,
year#,
month#,
months,
shift,
shift#,
crew#,
crew,
harvhos,
digtype,
dipper,
payload,
idletime,
spottime,
loadtime,
dumpingtime,
crusheridle,
travelempty,
travelloaded,
totalcycle,
loads_disteh,
loads_lift_down,
loads_lift_up,
dumps_dist,
dumps_lift_down,
dumps_lift_up,
hos,
timefull,
timefull_ts,
timeloaded,
excav,
eoper,
truck,
toperid,
toper,
load#,
material,
bench,
unit#,
unit,
dumpname,
load_seq_no,
grade,
extraload,
loadtype,
loadtons,
measuretons_shovel,
over_truck_flag,
under_truck_flag,
dump_flag,
shovel_idle,
crusher_dump_flag,
dump_number,
ldump_hos,
dump_hos,
dump_oper_id,
eliftup,
eliftdown,
distloaded,
fliftup,
fliftdown,
distempty,
emptyhaul,
fullhaul,
load_timearrive,
load_timearrive_ts,
timeload,
timeload_ts,
beginspot,
beginspot_ts,
hangtime,
dump_timearrive,
dump_timearrive_ts,
timedump,
timedump_ts,
timeempty,
timeempty_ts,
material_name,
start_date_ts,
end_date_ts,
system_version,
dw_logical_delete_flag,
dw_modify_ts,
dw_load_ts)
select
 -- We have duplicate in oper_list table
loads.shiftindex,
loads.shiftdate ,
loads.site_code ,
loads.cliid ,
loads.ddbkey ,
extract(year from shift_date.shiftdate) as year#, --- year number
shift_date.month#, ---month number
shift_date.months, ---month
shift_date.shift, ---shift (day - night)
shift_date.shift#, ---shift numer ( 1 - 2)
shift_date.crew#, ---crew number
shift_date.crew, ---crew name
(case
			when shift_date.shift# = 2
			then loads.hos + 12
			else loads.hos
end
) as harvhos, 
null as digtype,
0 as dipper,-- was harded in bteq 4B
case when loads.cliid in (32578, 19259, 1554590, 42468) then
coalesce(nullif(loads.dcstons,0),dumps.measureton)  / (1.10231) 
else coalesce(nullif(loads.dcstons,0),dumps.measureton)  end as payload,  -- tons in truck
zeroifnull(loads.queuetime / 60) as idletime, --- truck idle time at shovel
zeroifnull(loads.spottime / 60) as spottime, --- truck spot time at shovel
zeroifnull(loads.loadingtim / 60) as loadtime, --- time to load truck
zeroifnull(case
	when loc.unit# in (3, 5)
	then (zeroifnull(dumps.dumpingtim) + zeroifnull(dumps.idletime)) / 60.0
	else 0
end) as dumpingtime, --- dumping time at waste and stockpile locations
zeroifnull(case
	when loc.unit# = 4
	then (zeroifnull(dumps.dumpingtim)  + zeroifnull(dumps.idletime)) / 60.0
	else 0
end) as crusheridle, --- dumping time at crushers
zeroifnull(loads.emptyhaul / 60) as travelempty, ---actual travel time empty
zeroifnull(loads.fullhaul / 60) as travelloaded, ---actual travel time loaded
(dumpingtime + crusheridle + zeroifnull(loads.queuetime / 60) + zeroifnull(loads.spottime / 60)  + zeroifnull(loads.loadingtim / 60) + zeroifnull(loads.emptyhaul / 60)  + zeroifnull(loads.fullhaul / 60) )  as totalcycle,
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.disteh      / (3.28084) else loads.disteh      end  as loads_disteh, 
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_down / (3.28084) else loads.lift_down end  / 50 as loads_lift_down,
(case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_up / (3.28084) else loads.lift_up end / 50) as loads_lift_up,
(case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.dist/ (3.28084) else dumps.dist end) dumps_dist ,
(case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_down / (3.28084) else dumps.lift_down end / 50) dumps_lift_down,
(case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_up / (3.28084) else dumps.lift_up end / 50)dumps_lift_up,
loads.hos, ---hour of shift
loads.timefull, ---time truck loaded (seconds into  shift)
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(loads.timefull as number) / 60 as  interval minute(4)) + cast ( (cast(loads.timefull as number)  mod 60 ) as interval second(4,3)) as timefull_ts, --Included on 07/29/2019
((((shift_date.starts + loads.timefull)(int)) / 3600) (format 'zzzz99'))
|| ((((shift_date.starts + loads.timefull)(int)) mod 3600) / 60 (format ':99'))
|| (((shift_date.starts + loads.timefull)(int)) mod 60 (format ':99')) as timeloaded, -- Only adding hours to start time 
loads.excav, --- shovel
loads.eoper,
loads.truck,
truck_oper.operid as toperid,
truck_oper.name as toper,
loads.load as load#, --- material number
mat.name as material, --Load_type table column name = Material
loads.loc as bench, --- shovel bench name
loc.unit#, --- location unit number (3, 4, 5)
loc.unit, --- location unit (waste, 
dumps.loc as dumpname, --- name of dumping location     
0 as load_seq_no,
loads.grade,
loads.extraload,
loads.loadtype,
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.loadtons_us / (1.10231) else loadtons_us end as loadtons,
0 as measuretons_shovel,
loads.ot as over_truck_flag,
loads.ut as under_truck_flag,
loads.dmp as dump_flag,
((loads.idletime / 60) + (loads.hangtime / 60)) as shovel_idle,
(case
	when loc.unit# = 4
	then 1
	else 0
end) as crusher_dump_flag,
dumps.dumpid as dump_number,
null as ldump_hos,
dumps.hos as dump_hos,
dumps.oper as dump_oper_id,
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_up/ (3.28084) else loads.lift_up     end as eliftup, ---feet traveled empty up hill
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_down /(3.28084) else loads.lift_down end  as eliftdown, ---feet traveled empty down hill
case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.dist/ (3.28084) else dumps.dist end as distloaded, ---total feet traveled loaded to dumping location
case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_up /(3.28084) else dumps.lift_up end as fliftup, ---feet traveled loaded up hill
case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_down /(3.28084) else dumps.lift_down end as fliftdown, ---feet traveled loaded down hill
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.disteh / (3.28084) else loads.disteh      end  as distempty, ---total feet traveled empty to shovel
zeroifnull(loads.emptyhaul) as emptyhaul,
zeroifnull(loads.fullhaul) as fullhaul,
loads.timearrive as load_timearrive,
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(loads.timearrive as number) / 60 as  interval minute(4)) + cast ( (cast(loads.timearrive as number)  mod 60 ) as interval second(4,3)) as load_timearrive_ts, --Included on 07/29/2019
loads.timeload as timeload,
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(loads.timeload as number) / 60 as  interval minute(4)) + cast ( (cast(loads.timeload as number)  mod 60 ) as interval second(4,3)) as timeload_ts, --Included on 07/29/2019
zeroifnull(loads.beginspot) as beginspot,
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(zeroifnull(loads.beginspot) as number) / 60 as  interval minute(4)) + cast ( (cast(zeroifnull(loads.beginspot) as number)  mod 60 ) as interval second(4,3)) as beginspot_ts, --Included on 07/29/2019
zeroifnull(loads.hangtime) as hangtime,
dumps.timearrive as dump_timearrive,
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(dumps.timearrive as number) / 60 as  interval minute(4)) + cast ( (cast(dumps.timearrive as number)  mod 60 ) as interval second(4,3)) as dump_timearrive_ts, --Included on 07/29/2019
dumps.timedump as timedump,
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(dumps.timedump as number) / 60 as  interval minute(4)) + cast ( (cast(dumps.timedump as number)  mod 60 ) as interval second(4,3)) as timedump_ts, --Included on 07/29/2019
dumps.timeempty as timeempty,
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(dumps.timeempty as number) / 60 as  interval minute(4)) + cast ( (cast(dumps.timeempty as number)  mod 60 ) as interval second(4,3)) as timeempty_ts, --Included on 07/29/2019
mat.colloquial_name as  material_name,
shift_date.start_date_ts,
shift_date.end_date_ts ,
loads.system_version,
'N' as dw_logical_delete_flag,
cast(proc_var_dw_modify_ts as timestamp(0)) as dw_modify_ts,
cast(proc_var_dw_modify_ts as timestamp(0)) as dw_load_ts
--select loads.site_code
from
pddw.lh_load as loads
-- filter  condition to restict the number of shift
inner join edw_stage.lh2_deltac_sum_shift_pre_stage stg
on stg.cliid = loads.cliid
and stg.shiftindex = loads.shiftindex

inner join
pddw.lh_shift_date2_view as shift_date
on loads.shiftindex = shift_date.shiftindex
and loads.cliid = shift_date.cliid

inner join
pddw.lh_dump as dumps
on loads.shiftindex = dumps.shiftindex
and loads.dumprec = dumps.ddbkey
and loads.cliid = dumps.cliid

inner join
pddw.lh_location as loc
on dumps.shiftindex = loc.shiftindex
and dumps.cliid = loc.cliid
and dumps.loc = loc.locid


inner join 
pddw.lh_oper_list as truck_oper
on loads.shiftindex = truck_oper.shiftindex
and loads.cliid = truck_oper.cliid
and loads.oper = truck_oper.operid

inner join
app_ops_portal.load_type as mat
on loads.load = mat.num
and loads.cliid = mat.cliid

where
-- load where dump is completed
loads.extraload <>1
and loads.dumprec <> 0
and loads.loadtype <>1
and dumps.loadtype <> 1

;

insert into edw_stage.lh2_deltac_sum
(shiftindex,
shiftdate,
site_code,
cliid,
ddbkey,
year#,
month#,
months,
shift,
shift#,
crew#,
crew,
harvhos,
digtype,
shvtype,
dipper,
trktype,
payload,
idletime,
spottime,
loadtime,
dumpingtime,
crusheridle,
travelempty,
travelloaded,
totalcycle,
calctravempty,
calctravloaded,
hos,
timefull,
timefull_ts,
timeloaded,
excav,
soperid,
soper,
truck,
toperid,
toper,
load#,
material,
bench,
unit#,
unit,
dumpname,
idledelta,
spotdelta,
loaddelta,
dumpdelta,
et_delta,
lt_delta,
delta_c,
toavgdeltac,
tostdevdeltac,
toavgidledelta,
tostdevidledelta,
toavgspotdelta,
tostdevspotdelta,
toavgloaddelta,
tostdevloaddelta,
toavgetdelta,
tostdevetdelta,
toavgltdelta,
tostdevltdelta,
toavgdumpdelta,
tostdevdumpdelta,
vtodeltac3,
load_seq_no,
grade,
extraload,
loadtype,
loadtons,
measuretons_shovel,
over_truck_flag,
under_truck_flag,
dump_flag,
shovel_idle,
crusher_dump_flag,
dump_number,
ldump_hos,
dump_hos,
dump_oper_id,
shovel_eqmttype#,
truck_eqmttype#,
shvl_ops_prtl_equip_group_no#,
trk_ops_prtl_equip_group_no#,
shovel_idledelta,
eliftup,
eliftdown,
distloaded,
fliftup,
fliftdown,
distempty,
emptyhaul,
load_timearrive,
load_timearrive_ts,
timeload,
timeload_ts,
beginspot,
beginspot_ts,
hangtime,
dump_timearrive,
dump_timearrive_ts,
timedump,
timedump_ts,
timeempty,
timeempty_ts,
material_name,
start_date_ts,
end_date_ts,
system_version,
dw_logical_delete_flag,
dw_modify_ts,
dw_load_ts)

select
 -- We have duplicate in oper_list table
loads.shiftindex,
loads.shiftdate ,
loads.site_code ,
loads.cliid ,
loads.ddbkey ,
loads.year#, --- year number
loads.month#, ---month number
loads.months, ---month
loads.shift, ---shift (day - night)
loads.shift#, ---shift numer ( 1 - 2)
loads.crew#, ---crew number
loads.crew, ---crew name
loads.harvhos, 
loads.digtype,
-- calculate in stage 2
equip_list_excav.ops_prtl_equip_group as shvtype, -- shovel group
loads.dipper,-- was harded in bteq 4B
-- calculate in stage 2
equip_list_truck.ops_prtl_equip_group as trktype, -- Truck group
loads.payload,  -- tons in truck
loads.idletime, --- truck idle time at shovel
loads.spottime, --- truck spot time at shovel
loads.loadtime, --- time to load truck
loads.dumpingtime, --- dumping time at waste and stockpile locations
loads.crusheridle, --- dumping time at crushers
loads.travelempty, ---actual travel time empty
loads.travelloaded, ---actual travel time loaded
loads.totalcycle,
--(loads.lift_up / 50) as adv_empty, ---number of benches traveled up empty
--(loads.lift_down / 50) as fav_empty, ---number of benches traveled down empty
--(dumps.lift_up / 50) as adv_loaded, ---number of benches traveled up loaded
--(dumps.lift_down / 50) as fav_loaded, ---number of benches traveled down empty
--(((distempty- ((fav_empty+adv_empty)*500))*60/5280/speed.flat_empty + fav_empty*500*60/5280/speed.down_empty + adv_empty*500*60/5280/speed.up_empty))  	  As CalcTravEmpty,
((loads_disteh  - 
(loads_lift_down 
+ loads_lift_up )*500)*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end/speed.flat_empty)
+ (loads_lift_down) *500*60/case when loads.cliid in (32578, 19259,22362, 1554590, 42468) then 1000 else 5280 end/speed.down_empty 
+ (loads_lift_up)*500*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end/speed.up_empty  as calctravempty,
--(((distloaded-((fav_loaded+adv_loaded)*500))*60/5280/speed.flat_loaded + fav_loaded*500*60/5280/speed.down_loaded + adv_loaded*500*60/5280/speed.up_loaded)) 	  As calcTravLoaded,
(dumps_dist 
- ((
    (dumps_lift_down) 
	+ (dumps_lift_up)
	) * 500
	)
	)*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end /speed.flat_loaded
+ (dumps_lift_down) *500*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end /speed.down_loaded
+ (dumps_lift_up)*500*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end /speed.up_loaded as calctravloaded,
loads.hos, ---hour of shift
loads.timefull, ---time truck loaded (seconds into  shift)
loads.timefull_ts, 
loads.timeloaded, -- Only adding hours to start time 
loads.excav, --- shovel
excav_oper.operid as soperid,
excav_oper.name as soper,
loads.truck,
loads.toperid,
loads.toper,
loads.load#, --- material number
loads.material, --Load_type table column name = Material
loads.bench, --- shovel bench name
loads.unit#, --- location unit number (3, 4, 5)
loads.unit, --- location unit (waste, 
loads.dumpname, --- name of dumping location     
loads.idletime - truck_std_time.idle_time as idledelta,
loads.spottime - truck_std_time.spot_time as spotdelta,
loads.loadtime  - excav_std_load_time.target_load_time as loaddelta,
(case
when	loads.unit#=4
-- crusheridle and dumpingtime are calculated above
then crusheridle - truck_std_time.dump_time_crusher
else dumpingtime - truck_std_time.dump_time_dump
end) as dumpdelta,
-- calctravempty and calctravloaded are calculated above
zeroifnull(loads.emptyhaul / 60)  - calctravempty as et_delta,
zeroifnull(loads.fullhaul / 60) - calctravloaded as lt_delta,
(case
when	loads.unit# in(3,5) 
then 
totalcycle 
- (calctravempty + calctravloaded + truck_std_time.idle_time + truck_std_time.spot_time + excav_std_load_time.target_load_time + truck_std_time.dump_time_dump)
else	
totalcycle 
- (calctravempty + calctravloaded + truck_std_time.idle_time + truck_std_time.spot_time + excav_std_load_time.target_load_time + truck_std_time.dump_time_crusher)
end) as delta_c,
avg(delta_c) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgdeltac,        
stddev_samp(delta_c) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as tostdevdeltac,
avg(idledelta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgidledelta,
stddev_samp(idledelta)over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevidledelta,
avg(spotdelta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgspotdelta,
stddev_samp(spotdelta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as tostdevspotdelta,
avg(loaddelta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgloaddelta,
stddev_samp(loaddelta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as tostdevloaddelta,
avg(et_delta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgetdelta,
stddev_samp(et_delta)over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevetdelta,
avg(lt_delta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgltdelta,
stddev_samp(lt_delta) over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevltdelta,
avg(dumpdelta)over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as toavgdumpdelta,
stddev_samp(dumpdelta)over(partition by loads.cliid,loads.shiftindex,loads.crew#, loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevdumpdelta,
(case
when	delta_c <= toavgdeltac + (tostdevdeltac*3)	and delta_c >= toavgdeltac - (tostdevdeltac*3)
then 'Y'
else 'N'
end) as vtodeltac3,
loads.load_seq_no,
loads.grade,
loads.extraload,
loads.loadtype,
loads.loadtons,
loads.measuretons_shovel,
loads.over_truck_flag,
loads.under_truck_flag,
loads.dump_flag,
loads.shovel_idle,
loads.crusher_dump_flag,
loads.dump_number,
loads. ldump_hos,
loads.dump_hos,
loads.dump_oper_id,
equip_list_excav.lh_equip_class as shovel_eqmttype#, -- shovel group
equip_list_truck.lh_equip_class as truck_eqmttype#, -- Truck group
equip_list_excav.ops_prtl_equip_group_no  as shvl_ops_prtl_equip_group_no#,
equip_list_truck.ops_prtl_equip_group_no as trk_ops_prtl_equip_group_no#,
shovel_idle - shovel_std_time.idle_time   as shovel_idledelta,
loads.eliftup, ---feet traveled empty up hill
loads.eliftdown, ---feet traveled empty down hill
loads.distloaded, ---total feet traveled loaded to dumping location
loads.fliftup, ---feet traveled loaded up hill
loads.fliftdown, ---feet traveled loaded down hill
loads.distempty, ---total feet traveled empty to shovel
loads.emptyhaul,
loads.load_timearrive,
loads.load_timearrive_ts,
loads.timeload,
loads.timeload_ts,
loads.beginspot,
loads.beginspot_ts,
loads.hangtime,
loads.dump_timearrive,
loads.dump_timearrive_ts,
loads.timedump,
loads.timedump_ts,
loads.timeempty,
loads.timeempty_ts,
loads.material_name,
loads.start_date_ts,
loads.end_date_ts ,
loads.system_version,
loads.dw_logical_delete_flag,
loads.dw_modify_ts,
loads.dw_load_ts
from
edw_stage.lh2_deltac_sum_pre_stage as loads
inner join
 prod_mapping.ops_portal_equipment_list as equip_list_excav
on	loads.excav = equip_list_excav.lh_equip_id
and loads.cliid = equip_list_excav.lh_cliid

inner join
prod_mapping.ops_portal_equipment_list as equip_list_truck
on	loads.truck = equip_list_truck.lh_equip_id
and loads.cliid = equip_list_truck.lh_cliid

inner join pddw.lh_target_time_base_view	as 	excav_std_load_time
on	loads.cliid = excav_std_load_time.cliid
and	loads.shiftindex >= excav_std_load_time.start_shiftindex
and	loads.shiftindex <= excav_std_load_time.end_shiftindex
and	equip_list_excav.ops_prtl_equip_group_no  = excav_std_load_time.ops_portal_shvl_grp_id
and	equip_list_truck.ops_prtl_equip_group_no = excav_std_load_time.ops_portal_trck_grp_id

inner join pddw.lh_target_load_base_view  truck_std_time
on loads.cliid=truck_std_time.cliid and
loads.shiftindex>=truck_std_time.start_shiftindex and
loads.shiftindex<=truck_std_time.end_shiftindex and
equip_list_truck.ops_prtl_equip_group_no = truck_std_time.ops_portal_equip_grp_id

inner join pddw.lh_target_load_base_view  shovel_std_time
on loads.cliid=shovel_std_time.cliid and
loads.shiftindex>=shovel_std_time.start_shiftindex and
loads.shiftindex<=shovel_std_time.end_shiftindex and
equip_list_excav.ops_prtl_equip_group_no = shovel_std_time.ops_portal_equip_grp_id

inner join 
 pddw.lh_oper_list as excav_oper
on loads.shiftindex = excav_oper.shiftindex
and loads.eoper = excav_oper.operid
and loads.cliid = excav_oper.cliid

--rt_deltac_calcs_mor_15min
--Get the average timing for an equipment group\
inner join
    (select
            target_load.cliid,
            target_load.shiftindex,
            site_code,
            ops_portal_euip_grp,
            ops_portal_equip_grp_id,
            target_payload_range ,
            max(last_modified_ts) as last_modified_ts,
            avg(size_cu_yd) as size_cu_yd,
            avg(secs_per_pass) as secs_per_pass,
            avg(idle_time) as idle_time,
            avg(spot_time) as spot_time,
            avg(load_time) as load_time,
            avg(dump_time_dump) as dump_time_dump,
            avg(dump_time_crusher) as dump_time_crusher,
            avg(dump_time_upper_limiit) as dump_time_upper_limiit,
            avg(spot_time_upper_limiit) as spot_time_upper_limiit,
            avg(flat_loaded) as flat_loaded,
            avg(down_loaded) as down_loaded,
            avg(up_loaded) as up_loaded,
            avg(flat_empty) as flat_empty,
            avg(up_empty) as up_empty,
            avg(down_empty) as down_empty,
            avg(hours_per_day) as hours_per_day,
            avg(min_payload) as min_payload,
            avg(target_payload) as target_payload,
            avg(measure_43_constant) as measure_43_constant,
            avg(efh_conv_downhill) as efh_conv_downhill,
            avg(efh_conv_uphill) as efh_conv_uphill,
            avg(payload_comp_target) as payload_comp_target,
            avg(lower_tar_prod) as lower_tar_prod,
            avg(upper_tar_prod) as upper_tar_prod
        from
		prod_pddw.lh_target_load_shift_new target_load
		--- to reduce the number of rows to process
		inner join edw_stage.lh2_deltac_sum_shift_pre_stage stg
		on stg.cliid = target_load.cliid
		and stg.shiftindex = target_load.shiftindex
		group by 1,2,3,4,5,6
    ) as speed
		on loads.cliid = speed.cliid
		and loads.shiftindex = speed.shiftindex
		and equip_list_truck.ops_prtl_equip_group_no = speed. ops_portal_equip_grp_id
; 

--Step 8: merge into target table
merge into edw_target.lh2_deltac_sum_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 year# ,  
 month# ,  
 months ,  
 shift ,  
 shift# ,  
 crew# ,  
 crew ,  
 harvhos ,  
 digtype ,  
 shvtype ,  
 dipper ,  
 trktype ,  
 payload ,  
 idletime ,  
 spottime ,  
 loadtime ,  
 dumpingtime ,  
 crusheridle ,  
 travelempty ,  
 travelloaded ,  
 totalcycle ,  
 calctravempty ,  
 calctravloaded ,  
 hos ,  
 timefull ,  
 timefull_ts ,
 timeloaded ,  
 excav ,  
 soperid ,  
 soper ,  
 truck ,  
 toperid ,  
 toper ,  
 load# ,  
 material ,  
 bench ,  
 unit# ,  
 unit ,  
 dumpname ,  
 idledelta ,  
 spotdelta ,  
 loaddelta ,  
 dumpdelta ,  
 et_delta ,  
 lt_delta ,  
 delta_c ,  
 toavgdeltac ,  
 tostdevdeltac ,  
 toavgidledelta ,  
 tostdevidledelta ,  
 toavgspotdelta ,  
 tostdevspotdelta ,  
 toavgloaddelta ,  
 tostdevloaddelta ,  
 toavgetdelta ,  
 tostdevetdelta ,  
 toavgltdelta ,  
 tostdevltdelta ,  
 toavgdumpdelta ,  
 tostdevdumpdelta ,  
 vtodeltac3 ,  
 load_seq_no ,  
 grade ,  
 extraload ,  
 loadtype ,  
 loadtons ,  
 measuretons_shovel ,  
 over_truck_flag ,  
 under_truck_flag ,  
 dump_flag ,  
 shovel_idle ,  
 crusher_dump_flag ,  
 dump_number ,  
 ldump_hos ,  
 dump_hos ,  
 dump_oper_id ,  
 shovel_eqmttype# ,  
 truck_eqmttype# ,  
 shvl_ops_prtl_equip_group_no#,
 trk_ops_prtl_equip_group_no#,
 shovel_idledelta ,  
 eliftup ,  
 eliftdown ,  
 distloaded ,  
 fliftup ,  
 fliftdown ,  
 distempty ,  
 emptyhaul ,  
 load_timearrive , 
 load_timearrive_ts ,
 timeload ,  
 timeload_ts ,
 beginspot ,  
 beginspot_ts ,
 hangtime ,  
 dump_timearrive ,  
 dump_timearrive_ts ,
 timedump , 
 timedump_ts ,
 timeempty ,  
 timeempty_ts ,
 material_name ,  
 start_date_ts ,
 end_date_ts,
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_deltac_sum
qualify( row_number() over (partition by cliid,shiftindex,ddbkey order by toper desc,soper desc) =1)
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey 
 )

WHEN MATCHED THEN 
UPDATE SET 
 site_code =  stg.site_code , 
 shiftdate =  stg.shiftdate,
excav = stg.excav , 
truck = stg.truck,
 year# =  stg.year# , 
 month# =  stg.month# , 
 months =  stg.months , 
 shift =  stg.shift , 
 shift# =  stg.shift# , 
 crew# =  stg.crew# , 
 crew =  stg.crew , 
 harvhos =  stg.harvhos , 
 digtype =  stg.digtype , 
 shvtype =  stg.shvtype , 
 dipper =  stg.dipper , 
 trktype =  stg.trktype , 
 payload =  stg.payload , 
 idletime =  stg.idletime , 
 spottime =  stg.spottime , 
 loadtime =  stg.loadtime , 
 dumpingtime =  stg.dumpingtime , 
 crusheridle =  stg.crusheridle , 
 travelempty =  stg.travelempty , 
 travelloaded =  stg.travelloaded , 
 totalcycle =  stg.totalcycle , 
 calctravempty =  stg.calctravempty , 
 calctravloaded =  stg.calctravloaded , 
 hos =  stg.hos , 
 timefull =  stg.timefull , 
 timefull_ts =  stg.timefull_ts , 
 timeloaded =  stg.timeloaded , 
 soperid =  stg.soperid , 
 soper =  stg.soper , 
 toperid =  stg.toperid , 
 toper =  stg.toper , 
 load# =  stg.load# , 
 material =  stg.material , 
 bench =  stg.bench , 
 unit# =  stg.unit# , 
 unit =  stg.unit , 
 dumpname =  stg.dumpname , 
 idledelta =  stg.idledelta , 
 spotdelta =  stg.spotdelta , 
 loaddelta =  stg.loaddelta , 
 dumpdelta =  stg.dumpdelta , 
 et_delta =  stg.et_delta , 
 lt_delta =  stg.lt_delta , 
 delta_c =  stg.delta_c , 
 toavgdeltac =  stg.toavgdeltac , 
 tostdevdeltac =  stg.tostdevdeltac , 
 toavgidledelta =  stg.toavgidledelta , 
 tostdevidledelta =  stg.tostdevidledelta , 
 toavgspotdelta =  stg.toavgspotdelta , 
 tostdevspotdelta =  stg.tostdevspotdelta , 
 toavgloaddelta =  stg.toavgloaddelta , 
 tostdevloaddelta =  stg.tostdevloaddelta , 
 toavgetdelta =  stg.toavgetdelta , 
 tostdevetdelta =  stg.tostdevetdelta , 
 toavgltdelta =  stg.toavgltdelta , 
 tostdevltdelta =  stg.tostdevltdelta , 
 toavgdumpdelta =  stg.toavgdumpdelta , 
 tostdevdumpdelta =  stg.tostdevdumpdelta , 
 vtodeltac3 =  stg.vtodeltac3 , 
 load_seq_no =  stg.load_seq_no , 
 grade =  stg.grade , 
 extraload =  stg.extraload , 
 loadtype =  stg.loadtype , 
 loadtons =  stg.loadtons , 
 measuretons_shovel =  stg.measuretons_shovel , 
 over_truck_flag =  stg.over_truck_flag , 
 under_truck_flag =  stg.under_truck_flag , 
 dump_flag =  stg.dump_flag , 
 shovel_idle =  stg.shovel_idle , 
 crusher_dump_flag =  stg.crusher_dump_flag , 
 dump_number =  stg.dump_number , 
 ldump_hos =  stg.ldump_hos , 
 dump_hos =  stg.dump_hos , 
 dump_oper_id =  stg.dump_oper_id , 
 shovel_eqmttype# =  stg.shovel_eqmttype# , 
 truck_eqmttype# =  stg.truck_eqmttype# , 
 shvl_ops_prtl_equip_group_no# =  stg.shvl_ops_prtl_equip_group_no#,
 trk_ops_prtl_equip_group_no# =   stg.trk_ops_prtl_equip_group_no#,
 shovel_idledelta =  stg.shovel_idledelta , 
 eliftup =  stg.eliftup , 
 eliftdown =  stg.eliftdown , 
 distloaded =  stg.distloaded , 
 fliftup =  stg.fliftup , 
 fliftdown =  stg.fliftdown , 
 distempty =  stg.distempty , 
 emptyhaul =  stg.emptyhaul , 
 load_timearrive =  stg.load_timearrive , 
 load_timearrive_ts =  stg.load_timearrive_ts , 
 timeload =  stg.timeload , 
 timeload_ts =  stg.timeload_ts , 
 beginspot =  stg.beginspot , 
 beginspot_ts =  stg.beginspot_ts , 
 hangtime =  stg.hangtime , 
 dump_timearrive =  stg.dump_timearrive , 
 dump_timearrive_ts =  stg.dump_timearrive_ts , 
 timedump =  stg.timedump , 
 timedump_ts =  stg.timedump_ts , 
 timeempty =  stg.timeempty , 
 timeempty_ts =  stg.timeempty_ts , 
 material_name =  stg.material_name , 
 start_date_ts =  stg.start_date_ts ,
 end_date_ts =  stg.end_date_ts,
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.year# , 
  stg.month# , 
  stg.months , 
  stg.shift , 
  stg.shift# , 
  stg.crew# , 
  stg.crew , 
  stg.harvhos , 
  stg.digtype , 
  stg.shvtype , 
  stg.dipper , 
  stg.trktype , 
  stg.payload , 
  stg.idletime , 
  stg.spottime , 
  stg.loadtime , 
  stg.dumpingtime , 
  stg.crusheridle , 
  stg.travelempty , 
  stg.travelloaded , 
  stg.totalcycle , 
  stg.calctravempty , 
  stg.calctravloaded , 
  stg.hos , 
  stg.timefull , 
  stg.timefull_ts , 
  stg.timeloaded , 
  stg.excav , 
  stg.soperid , 
  stg.soper , 
  stg.truck , 
  stg.toperid , 
  stg.toper , 
  stg.load# , 
  stg.material , 
  stg.bench , 
  stg.unit# , 
  stg.unit , 
  stg.dumpname , 
  stg.idledelta , 
  stg.spotdelta , 
  stg.loaddelta , 
  stg.dumpdelta , 
  stg.et_delta , 
  stg.lt_delta , 
  stg.delta_c , 
  stg.toavgdeltac , 
  stg.tostdevdeltac , 
  stg.toavgidledelta , 
  stg.tostdevidledelta , 
  stg.toavgspotdelta , 
  stg.tostdevspotdelta , 
  stg.toavgloaddelta , 
  stg.tostdevloaddelta , 
  stg.toavgetdelta , 
  stg.tostdevetdelta , 
  stg.toavgltdelta , 
  stg.tostdevltdelta , 
  stg.toavgdumpdelta , 
  stg.tostdevdumpdelta , 
  stg.vtodeltac3 , 
  stg.load_seq_no , 
  stg.grade , 
  stg.extraload , 
  stg.loadtype , 
  stg.loadtons , 
  stg.measuretons_shovel , 
  stg.over_truck_flag , 
  stg.under_truck_flag , 
  stg.dump_flag , 
  stg.shovel_idle , 
  stg.crusher_dump_flag , 
  stg.dump_number , 
  stg.ldump_hos , 
  stg.dump_hos , 
  stg.dump_oper_id , 
  stg.shovel_eqmttype# , 
  stg.truck_eqmttype# , 
  stg.shvl_ops_prtl_equip_group_no#,
  stg.trk_ops_prtl_equip_group_no#,
  stg.shovel_idledelta , 
  stg.eliftup , 
  stg.eliftdown , 
  stg.distloaded , 
  stg.fliftup , 
  stg.fliftdown , 
  stg.distempty , 
  stg.emptyhaul , 
  stg.load_timearrive , 
  stg.load_timearrive_ts , 
  stg.timeload , 
  stg.timeload_ts , 
  stg.beginspot , 
  stg.beginspot_ts , 
  stg.hangtime , 
  stg.dump_timearrive , 
  stg.dump_timearrive_ts , 
  stg.timedump , 
  stg.timedump_ts , 
  stg.timeempty , 
  stg.timeempty_ts , 
  stg.material_name , 
  stg.start_date_ts ,
  stg.end_date_ts,
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step 9: Capture the deleted rows
 
update edw_target.lh2_deltac_sum_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_deltac_sum as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_deltac_sum  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

begin request
--Step 10: Cleanup the target table 
delete   edw_target.lh2_deltac_sum_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step 11: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_load_ts) from edw_stage.lh2_deltac_sum), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_deltac_sum_c_sp';
end request;

end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_dump_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_dump_c collection table from  lh2_dump_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_dump_b
*                      
* Usage :  
call edw_etl.lh2_dump_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_dump_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   -----------------------------------   -----------------------------------   
*    2019-03-08       Kali D         Initial version
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_dump_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_dump_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_dump_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
    -- Sabarish S 2019-08-30 added as part of incremental load enhancement
   set proc_var_filter_list = '  ( shiftid , site_code ) in  
																					(select shiftid,site_code from edw_target.lh2_shift_dump_tbars_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  union
																					select shiftid,site_code from edw_target.lh2_shift_dump_tmbars_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  union
																					select shiftid,site_code from edw_target.lh2_shift_dump_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_load_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_eqmt_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_loc_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_grade_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_dump_lift_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_dump_lift_dist_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
																					select shiftid,site_code from edw_target.lh2_shift_oper_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_sum_shift_dump_b  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''')  ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_dump_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_dump_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'dumpid, ' 
  || 'bay, ' 
  || 'blast, ' 
  || 'dump_blast, ' 
  || 'calctravti, ' 
  || 'dist, ' 
  || 'dumpingtim, ' 
  || 'dumptons, ' 
  || 'efh, ' 
  || 'eoper, ' 
  || 'excav, ' 
  || 'excav_orig, ' 
  || 'extraload, ' 
  || 'grade, ' 
  || 'hos, ' 
  || 'idletime, ' 
  || 'idmp, ' 
  || 'intvl, ' 
  || 'lift_down, ' 
  || 'lift_up, ' 
  || 'liftdist_d, ' 
  || 'liftdist_u, ' 
  || 'load, ' 
  || 'loadnumber, ' 
  || 'loadold, ' 
  || 'loadrec, ' 
  || 'loadtype, ' 
  || 'loc, ' 
  || 'measureton, ' 
  || 'oper, ' 
  || 'shiftlink, ' 
  || 'timearrive, ' 
  || 'timearrive_ts, ' 
  || 'timedigest, ' 
  || 'timedigest_ts, ' 
  || 'timedump, ' 
  || 'timedump_ts, ' 
  || 'timeempty, ' 
  || 'timeempty_ts, ' 
  || 'truck, ' 
  || 'truck_orig, ' 
  || 'val_dmp, ' 
  || 'gpsx, ' 
  || 'gpsy, ' 
  || 'dlock, ' 
  || 'elock, ' 
  || 'edlock, ' 
  || 'rlock, ' 
  || 'gpsstat, ' 
  || 'tbars0, ' 
  || 'tbars1, ' 
  || 'tbars2, ' 
  || 'tbars3, ' 
  || 'blend#, ' 
  || 'blend, ' 
  || 'tmbars0#, ' 
  || 'tmbars0, ' 
  || 'tmbars1#, ' 
  || 'tmbars1, ' 
  || 'tmbars2#, ' 
  || 'tmbars2, ' 
  || 'tmbars3#, ' 
  || 'tmbars3, ' 
  || 'tmbars4#, ' 
  || 'tmbars4, ' 
  || 'tmbars5#, ' 
  || 'tmbars5, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' dumpid, ' 
  || ' bay, ' 
  || ' blast, ' 
  || ' dump_blast, ' 
  || ' calctravti, ' 
  || ' dist, ' 
  || ' dumpingtim, ' 
  || ' dumptons, ' 
  || ' efh, ' 
  || ' eoper, ' 
  || ' excav, ' 
  || ' excav_orig, ' 
  || ' extraload, ' 
  || ' grade, ' 
  || ' hos, ' 
  || ' idletime, ' 
  || ' idmp, ' 
  || ' intvl, ' 
  || ' lift_down, ' 
  || ' lift_up, ' 
  || ' liftdist_d, ' 
  || ' liftdist_u, ' 
  || ' load, ' 
  || ' loadnumber, ' 
  || ' loadold, ' 
  || ' loadrec, ' 
  || ' loadtype, ' 
  || ' loc, ' 
  || ' measureton, ' 
  || ' oper, ' 
  || ' shiftlink, ' 
  || ' timearrive, ' 
  || ' timearrive_ts, ' 
  || ' timedigest, ' 
  || ' timedigest_ts, ' 
  || ' timedump, ' 
  || ' timedump_ts, ' 
  || ' timeempty, ' 
  || ' timeempty_ts, ' 
  || ' truck, ' 
  || ' truck_orig, ' 
  || ' val_dmp, ' 
  || ' gpsx, ' 
  || ' gpsy, ' 
  || ' dlock, ' 
  || ' elock, ' 
  || ' edlock, ' 
  || ' rlock, ' 
  || ' gpsstat, ' 
  || ' tbars0, ' 
  || ' tbars1, ' 
  || ' tbars2, ' 
  || ' tbars3, ' 
  || ' blend#, ' 
  || ' blend, ' 
  || ' tmbars0#, ' 
  || ' tmbars0, ' 
  || ' tmbars1#, ' 
  || ' tmbars1, ' 
  || ' tmbars2#, ' 
  || ' tmbars2, ' 
  || ' tmbars3#, ' 
  || ' tmbars3, ' 
  || ' tmbars4#, ' 
  || ' tmbars4, ' 
  || ' tmbars5#, ' 
  || ' tmbars5, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_dump_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_dump_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 dumpid ,  
 bay ,  
 blast ,  
 dump_blast ,  
 calctravti ,  
 dist ,  
 dumpingtim ,  
 dumptons ,  
 efh ,  
 eoper ,  
 excav ,  
 excav_orig ,  
 extraload ,  
 grade ,  
 hos ,  
 idletime ,  
 idmp ,  
 intvl ,  
 lift_down ,  
 lift_up ,  
 liftdist_d ,  
 liftdist_u ,  
 load ,  
 loadnumber ,  
 loadold ,  
 loadrec ,  
 loadtype ,  
 loc ,  
 measureton ,  
 oper ,  
 shiftlink ,  
 timearrive ,  
 timearrive_ts ,  
 timedigest ,  
 timedigest_ts ,  
 timedump ,  
 timedump_ts ,  
 timeempty ,  
 timeempty_ts ,  
 truck ,  
 truck_orig ,  
 val_dmp ,  
 gpsx ,  
 gpsy ,  
 dlock ,  
 elock ,  
 edlock ,  
 rlock ,  
 gpsstat ,  
 tbars0 ,  
 tbars1 ,  
 tbars2 ,  
 tbars3 ,  
 blend# ,  
 blend ,  
 tmbars0# ,  
 tmbars0 ,  
 tmbars1# ,  
 tmbars1 ,  
 tmbars2# ,  
 tmbars2 ,  
 tmbars3# ,  
 tmbars3 ,  
 tmbars4# ,  
 tmbars4 ,  
 tmbars5# ,  
 tmbars5 ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_dump_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 dumpid =  stg.dumpid , 
 bay =  stg.bay , 
 blast =  stg.blast , 
 dump_blast =  stg.dump_blast , 
 calctravti =  stg.calctravti , 
 dist =  stg.dist , 
 dumpingtim =  stg.dumpingtim , 
 dumptons =  stg.dumptons , 
 efh =  stg.efh , 
 eoper =  stg.eoper , 
 excav =  stg.excav , 
 excav_orig =  stg.excav_orig , 
 extraload =  stg.extraload , 
 grade =  stg.grade , 
 hos =  stg.hos , 
 idletime =  stg.idletime , 
 idmp =  stg.idmp , 
 intvl =  stg.intvl , 
 lift_down =  stg.lift_down , 
 lift_up =  stg.lift_up , 
 liftdist_d =  stg.liftdist_d , 
 liftdist_u =  stg.liftdist_u , 
 load =  stg.load , 
 loadnumber =  stg.loadnumber , 
 loadold =  stg.loadold , 
 loadrec =  stg.loadrec , 
 loadtype =  stg.loadtype , 
 loc =  stg.loc , 
 measureton =  stg.measureton , 
 oper =  stg.oper , 
 shiftlink =  stg.shiftlink , 
 timearrive =  stg.timearrive , 
 timearrive_ts =  stg.timearrive_ts , 
 timedigest =  stg.timedigest , 
 timedigest_ts =  stg.timedigest_ts , 
 timedump =  stg.timedump , 
 timedump_ts =  stg.timedump_ts , 
 timeempty =  stg.timeempty , 
 timeempty_ts =  stg.timeempty_ts , 
 truck =  stg.truck , 
 truck_orig =  stg.truck_orig , 
 val_dmp =  stg.val_dmp , 
 gpsx =  stg.gpsx , 
 gpsy =  stg.gpsy , 
 dlock =  stg.dlock , 
 elock =  stg.elock , 
 edlock =  stg.edlock , 
 rlock =  stg.rlock , 
 gpsstat =  stg.gpsstat , 
 tbars0 =  stg.tbars0 , 
 tbars1 =  stg.tbars1 , 
 tbars2 =  stg.tbars2 , 
 tbars3 =  stg.tbars3 , 
 blend# =  stg.blend# , 
 blend =  stg.blend , 
 tmbars0# =  stg.tmbars0# , 
 tmbars0 =  stg.tmbars0 , 
 tmbars1# =  stg.tmbars1# , 
 tmbars1 =  stg.tmbars1 , 
 tmbars2# =  stg.tmbars2# , 
 tmbars2 =  stg.tmbars2 , 
 tmbars3# =  stg.tmbars3# , 
 tmbars3 =  stg.tmbars3 , 
 tmbars4# =  stg.tmbars4# , 
 tmbars4 =  stg.tmbars4 , 
 tmbars5# =  stg.tmbars5# , 
 tmbars5 =  stg.tmbars5 , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.dumpid , 
  stg.bay , 
  stg.blast , 
  stg.dump_blast , 
  stg.calctravti , 
  stg.dist , 
  stg.dumpingtim , 
  stg.dumptons , 
  stg.efh , 
  stg.eoper , 
  stg.excav , 
  stg.excav_orig , 
  stg.extraload , 
  stg.grade , 
  stg.hos , 
  stg.idletime , 
  stg.idmp , 
  stg.intvl , 
  stg.lift_down , 
  stg.lift_up , 
  stg.liftdist_d , 
  stg.liftdist_u , 
  stg.load , 
  stg.loadnumber , 
  stg.loadold , 
  stg.loadrec , 
  stg.loadtype , 
  stg.loc , 
  stg.measureton , 
  stg.oper , 
  stg.shiftlink , 
  stg.timearrive , 
  stg.timearrive_ts , 
  stg.timedigest , 
  stg.timedigest_ts , 
  stg.timedump , 
  stg.timedump_ts , 
  stg.timeempty , 
  stg.timeempty_ts , 
  stg.truck , 
  stg.truck_orig , 
  stg.val_dmp , 
  stg.gpsx , 
  stg.gpsy , 
  stg.dlock , 
  stg.elock , 
  stg.edlock , 
  stg.rlock , 
  stg.gpsstat , 
  stg.tbars0 , 
  stg.tbars1 , 
  stg.tbars2 , 
  stg.tbars3 , 
  stg.blend# , 
  stg.blend , 
  stg.tmbars0# , 
  stg.tmbars0 , 
  stg.tmbars1# , 
  stg.tmbars1 , 
  stg.tmbars2# , 
  stg.tmbars2 , 
  stg.tmbars3# , 
  stg.tmbars3 , 
  stg.tmbars4# , 
  stg.tmbars4 , 
  stg.tmbars5# , 
  stg.tmbars5 , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_dump_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_dump_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_dump_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_dump_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_dump_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_dump_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_dump_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_dump_c collection table from  lh2_dump_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_dump_b
*                      
* Usage :  
call edw_etl.lh2_dump_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_dump_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   -----------------------------------   -----------------------------------   
*    2019-03-08       Kali D         Initial version
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_dump_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_dump_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_dump_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
    -- Sabarish S 2019-08-30 added as part of incremental load enhancement
   set proc_var_filter_list = '  ( shiftid , site_code ) in  
																					(select shiftid,site_code from edw_target.lh2_shift_dump_tbars_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  union
																					select shiftid,site_code from edw_target.lh2_shift_dump_tmbars_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  union
																					select shiftid,site_code from edw_target.lh2_shift_dump_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_load_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_eqmt_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_loc_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_grade_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_dump_lift_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_shift_dump_lift_dist_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
																					select shiftid,site_code from edw_target.lh2_shift_oper_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
																					select shiftid,site_code from edw_target.lh2_sum_shift_dump_b  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''')  ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_dump_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_dump_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'dumpid, ' 
  || 'bay, ' 
  || 'blast, ' 
  || 'dump_blast, ' 
  || 'calctravti, ' 
  || 'dist, ' 
  || 'dumpingtim, ' 
  || 'dumptons, ' 
  || 'efh, ' 
  || 'eoper, ' 
  || 'excav, ' 
  || 'excav_orig, ' 
  || 'extraload, ' 
  || 'grade, ' 
  || 'hos, ' 
  || 'idletime, ' 
  || 'idmp, ' 
  || 'intvl, ' 
  || 'lift_down, ' 
  || 'lift_up, ' 
  || 'liftdist_d, ' 
  || 'liftdist_u, ' 
  || 'load, ' 
  || 'loadnumber, ' 
  || 'loadold, ' 
  || 'loadrec, ' 
  || 'loadtype, ' 
  || 'loc, ' 
  || 'measureton, ' 
  || 'oper, ' 
  || 'shiftlink, ' 
  || 'timearrive, ' 
  || 'timearrive_ts, ' 
  || 'timedigest, ' 
  || 'timedigest_ts, ' 
  || 'timedump, ' 
  || 'timedump_ts, ' 
  || 'timeempty, ' 
  || 'timeempty_ts, ' 
  || 'truck, ' 
  || 'truck_orig, ' 
  || 'val_dmp, ' 
  || 'gpsx, ' 
  || 'gpsy, ' 
  || 'dlock, ' 
  || 'elock, ' 
  || 'edlock, ' 
  || 'rlock, ' 
  || 'gpsstat, ' 
  || 'tbars0, ' 
  || 'tbars1, ' 
  || 'tbars2, ' 
  || 'tbars3, ' 
  || 'blend#, ' 
  || 'blend, ' 
  || 'tmbars0#, ' 
  || 'tmbars0, ' 
  || 'tmbars1#, ' 
  || 'tmbars1, ' 
  || 'tmbars2#, ' 
  || 'tmbars2, ' 
  || 'tmbars3#, ' 
  || 'tmbars3, ' 
  || 'tmbars4#, ' 
  || 'tmbars4, ' 
  || 'tmbars5#, ' 
  || 'tmbars5, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' dumpid, ' 
  || ' bay, ' 
  || ' blast, ' 
  || ' dump_blast, ' 
  || ' calctravti, ' 
  || ' dist, ' 
  || ' dumpingtim, ' 
  || ' dumptons, ' 
  || ' efh, ' 
  || ' eoper, ' 
  || ' excav, ' 
  || ' excav_orig, ' 
  || ' extraload, ' 
  || ' grade, ' 
  || ' hos, ' 
  || ' idletime, ' 
  || ' idmp, ' 
  || ' intvl, ' 
  || ' lift_down, ' 
  || ' lift_up, ' 
  || ' liftdist_d, ' 
  || ' liftdist_u, ' 
  || ' load, ' 
  || ' loadnumber, ' 
  || ' loadold, ' 
  || ' loadrec, ' 
  || ' loadtype, ' 
  || ' loc, ' 
  || ' measureton, ' 
  || ' oper, ' 
  || ' shiftlink, ' 
  || ' timearrive, ' 
  || ' timearrive_ts, ' 
  || ' timedigest, ' 
  || ' timedigest_ts, ' 
  || ' timedump, ' 
  || ' timedump_ts, ' 
  || ' timeempty, ' 
  || ' timeempty_ts, ' 
  || ' truck, ' 
  || ' truck_orig, ' 
  || ' val_dmp, ' 
  || ' gpsx, ' 
  || ' gpsy, ' 
  || ' dlock, ' 
  || ' elock, ' 
  || ' edlock, ' 
  || ' rlock, ' 
  || ' gpsstat, ' 
  || ' tbars0, ' 
  || ' tbars1, ' 
  || ' tbars2, ' 
  || ' tbars3, ' 
  || ' blend#, ' 
  || ' blend, ' 
  || ' tmbars0#, ' 
  || ' tmbars0, ' 
  || ' tmbars1#, ' 
  || ' tmbars1, ' 
  || ' tmbars2#, ' 
  || ' tmbars2, ' 
  || ' tmbars3#, ' 
  || ' tmbars3, ' 
  || ' tmbars4#, ' 
  || ' tmbars4, ' 
  || ' tmbars5#, ' 
  || ' tmbars5, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_dump_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_dump_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 dumpid ,  
 bay ,  
 blast ,  
 dump_blast ,  
 calctravti ,  
 dist ,  
 dumpingtim ,  
 dumptons ,  
 efh ,  
 eoper ,  
 excav ,  
 excav_orig ,  
 extraload ,  
 grade ,  
 hos ,  
 idletime ,  
 idmp ,  
 intvl ,  
 lift_down ,  
 lift_up ,  
 liftdist_d ,  
 liftdist_u ,  
 load ,  
 loadnumber ,  
 loadold ,  
 loadrec ,  
 loadtype ,  
 loc ,  
 measureton ,  
 oper ,  
 shiftlink ,  
 timearrive ,  
 timearrive_ts ,  
 timedigest ,  
 timedigest_ts ,  
 timedump ,  
 timedump_ts ,  
 timeempty ,  
 timeempty_ts ,  
 truck ,  
 truck_orig ,  
 val_dmp ,  
 gpsx ,  
 gpsy ,  
 dlock ,  
 elock ,  
 edlock ,  
 rlock ,  
 gpsstat ,  
 tbars0 ,  
 tbars1 ,  
 tbars2 ,  
 tbars3 ,  
 blend# ,  
 blend ,  
 tmbars0# ,  
 tmbars0 ,  
 tmbars1# ,  
 tmbars1 ,  
 tmbars2# ,  
 tmbars2 ,  
 tmbars3# ,  
 tmbars3 ,  
 tmbars4# ,  
 tmbars4 ,  
 tmbars5# ,  
 tmbars5 ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_dump_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 dumpid =  stg.dumpid , 
 bay =  stg.bay , 
 blast =  stg.blast , 
 dump_blast =  stg.dump_blast , 
 calctravti =  stg.calctravti , 
 dist =  stg.dist , 
 dumpingtim =  stg.dumpingtim , 
 dumptons =  stg.dumptons , 
 efh =  stg.efh , 
 eoper =  stg.eoper , 
 excav =  stg.excav , 
 excav_orig =  stg.excav_orig , 
 extraload =  stg.extraload , 
 grade =  stg.grade , 
 hos =  stg.hos , 
 idletime =  stg.idletime , 
 idmp =  stg.idmp , 
 intvl =  stg.intvl , 
 lift_down =  stg.lift_down , 
 lift_up =  stg.lift_up , 
 liftdist_d =  stg.liftdist_d , 
 liftdist_u =  stg.liftdist_u , 
 load =  stg.load , 
 loadnumber =  stg.loadnumber , 
 loadold =  stg.loadold , 
 loadrec =  stg.loadrec , 
 loadtype =  stg.loadtype , 
 loc =  stg.loc , 
 measureton =  stg.measureton , 
 oper =  stg.oper , 
 shiftlink =  stg.shiftlink , 
 timearrive =  stg.timearrive , 
 timearrive_ts =  stg.timearrive_ts , 
 timedigest =  stg.timedigest , 
 timedigest_ts =  stg.timedigest_ts , 
 timedump =  stg.timedump , 
 timedump_ts =  stg.timedump_ts , 
 timeempty =  stg.timeempty , 
 timeempty_ts =  stg.timeempty_ts , 
 truck =  stg.truck , 
 truck_orig =  stg.truck_orig , 
 val_dmp =  stg.val_dmp , 
 gpsx =  stg.gpsx , 
 gpsy =  stg.gpsy , 
 dlock =  stg.dlock , 
 elock =  stg.elock , 
 edlock =  stg.edlock , 
 rlock =  stg.rlock , 
 gpsstat =  stg.gpsstat , 
 tbars0 =  stg.tbars0 , 
 tbars1 =  stg.tbars1 , 
 tbars2 =  stg.tbars2 , 
 tbars3 =  stg.tbars3 , 
 blend# =  stg.blend# , 
 blend =  stg.blend , 
 tmbars0# =  stg.tmbars0# , 
 tmbars0 =  stg.tmbars0 , 
 tmbars1# =  stg.tmbars1# , 
 tmbars1 =  stg.tmbars1 , 
 tmbars2# =  stg.tmbars2# , 
 tmbars2 =  stg.tmbars2 , 
 tmbars3# =  stg.tmbars3# , 
 tmbars3 =  stg.tmbars3 , 
 tmbars4# =  stg.tmbars4# , 
 tmbars4 =  stg.tmbars4 , 
 tmbars5# =  stg.tmbars5# , 
 tmbars5 =  stg.tmbars5 , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.dumpid , 
  stg.bay , 
  stg.blast , 
  stg.dump_blast , 
  stg.calctravti , 
  stg.dist , 
  stg.dumpingtim , 
  stg.dumptons , 
  stg.efh , 
  stg.eoper , 
  stg.excav , 
  stg.excav_orig , 
  stg.extraload , 
  stg.grade , 
  stg.hos , 
  stg.idletime , 
  stg.idmp , 
  stg.intvl , 
  stg.lift_down , 
  stg.lift_up , 
  stg.liftdist_d , 
  stg.liftdist_u , 
  stg.load , 
  stg.loadnumber , 
  stg.loadold , 
  stg.loadrec , 
  stg.loadtype , 
  stg.loc , 
  stg.measureton , 
  stg.oper , 
  stg.shiftlink , 
  stg.timearrive , 
  stg.timearrive_ts , 
  stg.timedigest , 
  stg.timedigest_ts , 
  stg.timedump , 
  stg.timedump_ts , 
  stg.timeempty , 
  stg.timeempty_ts , 
  stg.truck , 
  stg.truck_orig , 
  stg.val_dmp , 
  stg.gpsx , 
  stg.gpsy , 
  stg.dlock , 
  stg.elock , 
  stg.edlock , 
  stg.rlock , 
  stg.gpsstat , 
  stg.tbars0 , 
  stg.tbars1 , 
  stg.tbars2 , 
  stg.tbars3 , 
  stg.blend# , 
  stg.blend , 
  stg.tmbars0# , 
  stg.tmbars0 , 
  stg.tmbars1# , 
  stg.tmbars1 , 
  stg.tmbars2# , 
  stg.tmbars2 , 
  stg.tmbars3# , 
  stg.tmbars3 , 
  stg.tmbars4# , 
  stg.tmbars4 , 
  stg.tmbars5# , 
  stg.tmbars5 , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_dump_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_dump_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_dump_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_dump_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_dump_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_dump_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_enum_c_ds6_sp ( filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , num, enumname 
* PURPOSE : Load the lh2_enum_c collection table from  lh2_enum_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_enum_b
*                      
* Usage :  
call edw_etl.lh2_enum_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_enum_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   ------------------------------------  ------------------------------------  
*    2019-03-08       Kali D         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_enum_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_enum_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_enum_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = '  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   set proc_var_filter_list = ' (  site_code ) in   ( select   site_code  from  edw_target.lh2_enum_b    where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  group by 1 ) ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_enum_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_enum_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'enumname, ' 
  || 'num, ' 
  || 'name, ' 
  || 'abbrev, ' 
  || 'flags, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
  || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' enumname, ' 
  || ' num, ' 
  || ' name, ' 
  || ' abbrev, ' 
  || ' flags, ' 
  ||'  ''Dispatch 6'' as system_version,'
  ||'  ''N'' as dw_logical_delete_flag,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_enum_ds6_etl   '
  ||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_enum_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 enumname ,  
 num ,  
 name ,  
 abbrev ,  
 flags ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_enum_ds6 
) as stg 
ON ( stg.cliid = tgt.cliid and 
stg.enumname = tgt.enumname and 
stg.num = tgt.num)

WHEN MATCHED THEN 
UPDATE SET 
shiftindex =  stg.shiftindex , 
 shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 name =  stg.name , 
 abbrev =  stg.abbrev , 
 flags =  stg.flags , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.enumname , 
  stg.num , 
  stg.name , 
  stg.abbrev , 
  stg.flags , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_enum_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_enum_ds6 as stg 
      where stg.cliid = tgt.cliid 
	  and stg.enumname = tgt.enumname 
      and stg.num = tgt.num 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_enum_ds6  stg1 
     where   stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
--Kali D 2019-05-08 for now we are keeping the unavailable enum in pv5 
--delete   edw_target.lh2_enum_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_enum_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_enum_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_equip_cat_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, eqmtid,hos
* PURPOSE : Load the lh2_equip_cat_c collection table from  lh2_equip_cat_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_state_b
*                      
* Usage :  
call edw_etl.lh2_equip_cat_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_equip_cat_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
	Step 1a: Before actual table we have to bulit the  stage lh2_equip_state_oper_equip_cat
	Step 1b: insert into  lh2_equip_state_oper_equip_cat for better performance 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D         Initial version
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/  

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_equip_cat_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_equip_cat_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_state_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   -- Sabarish S 2019-08-30 added as part of incremental load enhancement  
   set proc_var_filter_list = ' ( shiftid, site_code) in   
(select shiftid,site_code from edw_target.lh2_shift_aux_b  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_state_b  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_reason_b  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_eqmt_b  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_oper_b  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' ) ' ;
   end if;


--Step1a: Delete the stage lh2_equip_state_oper table

delete edw_stage.lh2_equip_state_oper_equip_cat;

--Step 1b: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_equip_state_oper_equip_cat ( site_code,'  
  || 'shiftindex, ' 
  || 'shiftid, ' 
  || 'shiftdate, ' 
  || 'eqmt_id, ' 
  || 'cliid, ' 
  || 'eqmt_name, ' 
  || 'eqmt_enum_type, ' 
  || 'eqmt_enum_type_code, ' 
  || 'enum_timecat_code, ' 
  || 'enum_timecat_descr, ' 
  || 'status_event_start_time, ' 
  || 'status_event_end_time, ' 
  || 'status_event_duration_sec, ' 
  || 'fieldreason, ' 
  || 'fieldreasonrec, ' 
  || 'state_enum_status_code, ' 
  || 'fieldcomment, ' 
  || 'oper_login_num, ' 
  || 'oper_logout_num, ' 
  || 'oper_id, ' 
  || 'oper_name, ' 
  || 'oper_start_time, ' 
  || 'oper_end_time, ' 
  || 'starttime_time, ' 
  || 'starttime_num, ' 
  || 'endtime_time, ' 
  || 'endtime_num, ' 
  || 'oper_available_time, ' 
  || 'oper_available_time_sec, ' 
  || 'tmcat01, ' 
  || 'tmcat02, ' 
  || 'tmcat03, ' 
  || 'tmcat04, ' 
  || 'tmcat05, ' 
  || 'tmcat06, ' 
  || 'tmcat07, ' 
  || 'tmcat08, ' 
  || 'tmcat09, ' 
  || 'tmcat10, ' 
  || 'tmcat11, ' 
  || 'tmcat12, ' 
  || 'tmcat13, ' 
  || 'tmcat14, ' 
  || 'tmcat15, ' 
  || 'tmcat16, ' 
  || 'tmcat17, ' 
  || 'tmcat18, ' 
  || ' tmcat19 )'
 || 'select  site_code,'  
  || ' shiftindex, ' 
  || ' shiftid, ' 
  || ' shiftdate, ' 
  || ' eqmt_id, ' 
  || ' cliid, ' 
  || ' eqmt_name, ' 
  || ' eqmt_enum_type, ' 
  || ' eqmt_enum_type_code, ' 
  || ' enum_timecat_code, ' 
  || ' enum_timecat_descr, ' 
  || ' status_event_start_time, ' 
  || ' status_event_end_time, ' 
  || ' status_event_duration_sec, ' 
  || ' fieldreason, ' 
  || ' fieldreasonrec, ' 
  || ' state_enum_status_code, ' 
  || ' fieldcomment, ' 
  || ' oper_login_num, ' 
  || ' oper_logout_num, ' 
  || ' oper_id, ' 
  || ' oper_name, ' 
  || ' oper_start_time, ' 
  || ' oper_end_time, ' 
  || ' starttime_time, ' 
  || ' starttime_num, ' 
  || ' endtime_time, ' 
  || ' endtime_num, ' 
  || ' oper_available_time, ' 
  || ' oper_available_time_sec, ' 
  || ' tmcat01, ' 
  || ' tmcat02, ' 
  || ' tmcat03, ' 
  || ' tmcat04, ' 
  || ' tmcat05, ' 
  || ' tmcat06, ' 
  || ' tmcat07, ' 
  || ' tmcat08, ' 
  || ' tmcat09, ' 
  || ' tmcat10, ' 
  || ' tmcat11, ' 
  || ' tmcat12, ' 
  || ' tmcat13, ' 
  || ' tmcat14, ' 
  || ' tmcat15, ' 
  || ' tmcat16, ' 
  || ' tmcat17, ' 
  || ' tmcat18, ' 
  || ' tmcat19 from edw_etl_view.lh2_equip_state_oper_etl   '
 ||'  where  '|| proc_var_filter_list ||';'
);


--Step1: Delete the stage table

delete edw_stage.lh2_equip_cat_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_equip_cat_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'eqmtid, ' 
  || 'eqmtid_orig, ' 
  || 'hos, ' 
  || 'intvl, ' 
  || 'tmcat00, ' 
  || 'tmcat01, ' 
  || 'tmcat02, ' 
  || 'tmcat03, ' 
  || 'tmcat04, ' 
  || 'tmcat05, ' 
  || 'tmcat06, ' 
  || 'tmcat07, ' 
  || 'tmcat08, ' 
  || 'tmcat09, ' 
  || 'tmcat10, ' 
  || 'tmcat11, ' 
  || 'tmcat12, ' 
  || 'tmcat13, ' 
  || 'tmcat14, ' 
  || 'tmcat15, ' 
  || 'tmcat16, ' 
  || 'tmcat17, ' 
  || 'tmcat18, ' 
  || 'tmcat19, ' 
  || 'unit, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' eqmtid, ' 
  || ' eqmtid_orig, ' 
  || ' hos, ' 
  || ' intvl, ' 
  || ' tmcat00, ' 
  || ' tmcat01, ' 
  || ' tmcat02, ' 
  || ' tmcat03, ' 
  || ' tmcat04, ' 
  || ' tmcat05, ' 
  || ' tmcat06, ' 
  || ' tmcat07, ' 
  || ' tmcat08, ' 
  || ' tmcat09, ' 
  || ' tmcat10, ' 
  || ' tmcat11, ' 
  || ' tmcat12, ' 
  || ' tmcat13, ' 
  || ' tmcat14, ' 
  || ' tmcat15, ' 
  || ' tmcat16, ' 
  || ' tmcat17, ' 
  || ' tmcat18, ' 
  || ' tmcat19, ' 
  || ' unit, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_equip_cat_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_equip_cat_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 eqmtid ,  
 eqmtid_orig ,  
 hos ,  
 intvl ,  
 tmcat00 ,  
 tmcat01 ,  
 tmcat02 ,  
 tmcat03 ,  
 tmcat04 ,  
 tmcat05 ,  
 tmcat06 ,  
 tmcat07 ,  
 tmcat08 ,  
 tmcat09 ,  
 tmcat10 ,  
 tmcat11 ,  
 tmcat12 ,  
 tmcat13 ,  
 tmcat14 ,  
 tmcat15 ,  
 tmcat16 ,  
 tmcat17 ,  
 tmcat18 ,  
 tmcat19 ,  
 unit ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_equip_cat_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey and 
stg.eqmtid = tgt.eqmtid and 
stg.hos = tgt.hos
)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 eqmtid =  stg.eqmtid , 
 eqmtid_orig =  stg.eqmtid_orig , 
 hos =  stg.hos , 
 intvl =  stg.intvl , 
 tmcat00 =  stg.tmcat00 , 
 tmcat01 =  stg.tmcat01 , 
 tmcat02 =  stg.tmcat02 , 
 tmcat03 =  stg.tmcat03 , 
 tmcat04 =  stg.tmcat04 , 
 tmcat05 =  stg.tmcat05 , 
 tmcat06 =  stg.tmcat06 , 
 tmcat07 =  stg.tmcat07 , 
 tmcat08 =  stg.tmcat08 , 
 tmcat09 =  stg.tmcat09 , 
 tmcat10 =  stg.tmcat10 , 
 tmcat11 =  stg.tmcat11 , 
 tmcat12 =  stg.tmcat12 , 
 tmcat13 =  stg.tmcat13 , 
 tmcat14 =  stg.tmcat14 , 
 tmcat15 =  stg.tmcat15 , 
 tmcat16 =  stg.tmcat16 , 
 tmcat17 =  stg.tmcat17 , 
 tmcat18 =  stg.tmcat18 , 
 tmcat19 =  stg.tmcat19 , 
 unit =  stg.unit , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.eqmtid , 
  stg.eqmtid_orig , 
  stg.hos , 
  stg.intvl , 
  stg.tmcat00 , 
  stg.tmcat01 , 
  stg.tmcat02 , 
  stg.tmcat03 , 
  stg.tmcat04 , 
  stg.tmcat05 , 
  stg.tmcat06 , 
  stg.tmcat07 , 
  stg.tmcat08 , 
  stg.tmcat09 , 
  stg.tmcat10 , 
  stg.tmcat11 , 
  stg.tmcat12 , 
  stg.tmcat13 , 
  stg.tmcat14 , 
  stg.tmcat15 , 
  stg.tmcat16 , 
  stg.tmcat17 , 
  stg.tmcat18 , 
  stg.tmcat19 , 
  stg.unit , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_equip_cat_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_equip_cat_ds6 as stg 
		where stg.shiftindex = tgt.shiftindex 
		and stg.cliid = tgt.cliid 
		and stg.ddbkey = tgt.ddbkey  
		and stg.eqmtid = tgt.eqmtid 
		and stg.hos = tgt.hos
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_equip_cat_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_equip_cat_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_equip_cat_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_equip_cat_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"




replace  procedure edw_etl.lh2_equip_list_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey ,eqmtid
* PURPOSE : Load the lh2_equip_list_c collection table from  lh2_equip_list_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_eqmt_b and lh2_shift_aux_b
*                      
* Usage :  
call edw_etl.lh2_equip_list_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_equip_list_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_equip_list_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_equip_list_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  ( select min(dw_modify_ts) from (select max(dw_modify_ts) dw_modify_ts from edw_target.lh2_shift_eqmt_b union select max(dw_modify_ts) dw_modify_ts from edw_target.lh2_shift_aux_b ) eqmt  ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   set proc_var_filter_list = ' ( shiftindex, cliid) in   ( select  shiftindex,  cliid from  edw_etl_view.lh2_equip_list_ds6_etl     where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  group by 1,2 ) ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_equip_list_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_equip_list_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'eqmtid, ' 
  || 'eqmtid_orig, ' 
  || 'eqmttype, ' 
  || 'eqmttype#, ' 
  || 'eqmttype#_orig, ' 
  || 'eqmttype_orig, ' 
  || 'extraload, ' 
  || 'pit, ' 
  || 'size, ' 
  || 'trammer, ' 
  || 'unit, ' 
  || 'unit#, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' eqmtid, ' 
  || ' eqmtid_orig, ' 
  || ' eqmttype, ' 
  || ' eqmttype#, ' 
  || ' eqmttype#_orig, ' 
  || ' eqmttype_orig, ' 
  || ' extraload, ' 
  || ' pit, ' 
  || ' size, ' 
  || ' trammer, ' 
  || ' unit, ' 
  || ' unit#, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_equip_list_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_equip_list_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 eqmtid ,  
 eqmtid_orig ,  
 eqmttype ,  
 eqmttype# ,  
 eqmttype#_orig ,  
 eqmttype_orig ,  
 extraload ,  
 pit ,  
 size ,  
 trammer ,  
 unit ,  
 unit# ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_equip_list_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey and  -- not sure that dbkey same dbkey can available on both tables (equip and aux)
 stg.eqmtid =  tgt.eqmtid )

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 

 eqmtid_orig =  stg.eqmtid_orig , 
 eqmttype =  stg.eqmttype , 
 eqmttype# =  stg.eqmttype# , 
 eqmttype#_orig =  stg.eqmttype#_orig , 
 eqmttype_orig =  stg.eqmttype_orig , 
 extraload =  stg.extraload , 
 pit =  stg.pit , 
 size =  stg.size , 
 trammer =  stg.trammer , 
 unit =  stg.unit , 
 unit# =  stg.unit# , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.eqmtid , 
  stg.eqmtid_orig , 
  stg.eqmttype , 
  stg.eqmttype# , 
  stg.eqmttype#_orig , 
  stg.eqmttype_orig , 
  stg.extraload , 
  stg.pit , 
  stg.size , 
  stg.trammer , 
  stg.unit , 
  stg.unit# , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_equip_list_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_equip_list_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
	  and stg.eqmtid = tgt.eqmtid 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_equip_list_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_equip_list_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_equip_list_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_equip_list_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_fueling_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_fueling_c collection table from  lh2_fueling_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_fuel_b
*                      
* Usage :  
call edw_etl.lh2_fueling_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_fueling_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D                Initial version
*    2019-07-30       Anandhi P         Included timestamp field timestart_ts & timeend_ts from edw_target.lh2_shift_fuel_b.
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/  

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select substr(cast(current_timestamp(0) as varchar (25)),1,19));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_fueling_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_fueling_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_fuel_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
	   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
    -- Sabarish S 2019-08-30 added as part of incremental load enhancement
   set proc_var_filter_list = ' ( shiftid , site_code ) in    
(select shiftid,site_code from edw_target.lh2_shift_fuel_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_eqmt_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_aux_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_fuel_array_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''') ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_fueling_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_fueling_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'fuelid, ' 
  || 'eqmt, ' 
  || 'unit, ' 
  || 'timestart, ' 
  || 'timestart_ts, ' 
  || 'timeend, ' 
  || 'timeend_ts, ' 
  || 'fuel00, ' 
  || 'fuel01, ' 
  || 'fuel02, ' 
  || 'fuel03, ' 
  || 'fuel04, ' 
  || 'fuel05, ' 
  || 'fuel06, ' 
  || 'fuel07, ' 
  || 'fuel08, ' 
  || 'fuel09, ' 
  || 'fuel10, ' 
  || 'fuel11, ' 
  || 'fuel12, ' 
  || 'fuel13, ' 
  || 'fuel14, ' 
  || 'fuel15, ' 
  || 'fuel16, ' 
  || 'fuel17, ' 
  || 'fuel18, ' 
  || 'fuel19, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' fuelid, ' 
  || ' eqmt, ' 
  || ' unit, ' 
  || ' timestart, ' 
  || ' timestart_ts, ' 
  || ' timeend, ' 
  || ' timeend_ts, ' 
  || ' fuel00, ' 
  || ' fuel01, ' 
  || ' fuel02, ' 
  || ' fuel03, ' 
  || ' fuel04, ' 
  || ' fuel05, ' 
  || ' fuel06, ' 
  || ' fuel07, ' 
  || ' fuel08, ' 
  || ' fuel09, ' 
  || ' fuel10, ' 
  || ' fuel11, ' 
  || ' fuel12, ' 
  || ' fuel13, ' 
  || ' fuel14, ' 
  || ' fuel15, ' 
  || ' fuel16, ' 
  || ' fuel17, ' 
  || ' fuel18, ' 
  || ' fuel19, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts  from edw_etl_view.lh2_fueling_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_fueling_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 fuelid ,  
 eqmt ,  
 unit ,  
 timestart ,  
 timestart_ts ,  
 timeend ,  
 timeend_ts , 
 fuel00 ,  
 fuel01 ,  
 fuel02 ,  
 fuel03 ,  
 fuel04 ,  
 fuel05 ,  
 fuel06 ,  
 fuel07 ,  
 fuel08 ,  
 fuel09 ,  
 fuel10 ,  
 fuel11 ,  
 fuel12 ,  
 fuel13 ,  
 fuel14 ,  
 fuel15 ,  
 fuel16 ,  
 fuel17 ,  
 fuel18 ,  
 fuel19 ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_fueling_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey )

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 fuelid =  stg.fuelid , 
 eqmt =  stg.eqmt , 
 unit =  stg.unit , 
 timestart =  stg.timestart , 
 timestart_ts =  stg.timestart_ts , 
 timeend =  stg.timeend , 
 timeend_ts =  stg.timeend_ts , 
 fuel00 =  stg.fuel00 , 
 fuel01 =  stg.fuel01 , 
 fuel02 =  stg.fuel02 , 
 fuel03 =  stg.fuel03 , 
 fuel04 =  stg.fuel04 , 
 fuel05 =  stg.fuel05 , 
 fuel06 =  stg.fuel06 , 
 fuel07 =  stg.fuel07 , 
 fuel08 =  stg.fuel08 , 
 fuel09 =  stg.fuel09 , 
 fuel10 =  stg.fuel10 , 
 fuel11 =  stg.fuel11 , 
 fuel12 =  stg.fuel12 , 
 fuel13 =  stg.fuel13 , 
 fuel14 =  stg.fuel14 , 
 fuel15 =  stg.fuel15 , 
 fuel16 =  stg.fuel16 , 
 fuel17 =  stg.fuel17 , 
 fuel18 =  stg.fuel18 , 
 fuel19 =  stg.fuel19 , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.fuelid , 
  stg.eqmt , 
  stg.unit , 
  stg.timestart , 
  stg.timestart_ts , 
  stg.timeend , 
  stg.timeend_ts , 
  stg.fuel00 , 
  stg.fuel01 , 
  stg.fuel02 , 
  stg.fuel03 , 
  stg.fuel04 , 
  stg.fuel05 , 
  stg.fuel06 , 
  stg.fuel07 , 
  stg.fuel08 , 
  stg.fuel09 , 
  stg.fuel10 , 
  stg.fuel11 , 
  stg.fuel12 , 
  stg.fuel13 , 
  stg.fuel14 , 
  stg.fuel15 , 
  stg.fuel16 , 
  stg.fuel17 , 
  stg.fuel18 , 
  stg.fuel19 , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_fueling_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_fueling_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_fueling_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_fueling_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_fueling_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_fueling_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_grade_list_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_grade_list_c collection table from  lh2_grade_list_ds6_etl view based on dw_modify_ts of base table  edw_target.lh2_shift_grade_b 
*                      
* Usage :  
call edw_etl.lh2_grade_list_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_grade_list_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   -----------------------------------   -----------------------------------   
*    2019-03-08       Kali D         Initial version
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_grade_list_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_grade_list_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_grade_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
     -- Sabarish S 2019-08-30 added as part of incremental load enhancement
   set proc_var_filter_list = ' ( shiftid , site_code ) in   
(select shiftid,site_code from edw_target.lh2_shift_grade_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_grade_array_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_loc_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' )  ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_grade_list_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_grade_list_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'blend, ' 
  || 'blend#, ' 
  || 'dumps, ' 
  || 'grade00, ' 
  || 'grade01, ' 
  || 'grade02, ' 
  || 'grade03, ' 
  || 'grade04, ' 
  || 'grade05, ' 
  || 'grade06, ' 
  || 'grade07, ' 
  || 'grade08, ' 
  || 'grade09, ' 
  || 'grade10, ' 
  || 'grade11, ' 
  || 'grade12, ' 
  || 'grade13, ' 
  || 'grade14, ' 
  || 'grade15, ' 
  || 'grade16, ' 
  || 'grade17, ' 
  || 'grade18, ' 
  || 'grade19, ' 
  || 'grade20, ' 
  || 'grade21, ' 
  || 'grade22, ' 
  || 'grade23, ' 
  || 'grade24, ' 
  || 'gradeid, ' 
  || 'inv, ' 
  || 'load#, ' 
  || 'loads, ' 
  || 'loc, ' 
  || 'spgr, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' blend, ' 
  || ' blend#, ' 
  || ' dumps, ' 
  || ' grade00, ' 
  || ' grade01, ' 
  || ' grade02, ' 
  || ' grade03, ' 
  || ' grade04, ' 
  || ' grade05, ' 
  || ' grade06, ' 
  || ' grade07, ' 
  || ' grade08, ' 
  || ' grade09, ' 
  || ' grade10, ' 
  || ' grade11, ' 
  || ' grade12, ' 
  || ' grade13, ' 
  || ' grade14, ' 
  || ' grade15, ' 
  || ' grade16, ' 
  || ' grade17, ' 
  || ' grade18, ' 
  || ' grade19, ' 
  || ' grade20, ' 
  || ' grade21, ' 
  || ' grade22, ' 
  || ' grade23, ' 
  || ' grade24, ' 
  || ' gradeid, ' 
  || ' inv, ' 
  || ' load#, ' 
  || ' loads, ' 
  || ' loc, ' 
  || ' spgr, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_grade_list_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_grade_list_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 blend ,  
 blend# ,  
 dumps ,  
 grade00 ,  
 grade01 ,  
 grade02 ,  
 grade03 ,  
 grade04 ,  
 grade05 ,  
 grade06 ,  
 grade07 ,  
 grade08 ,  
 grade09 ,  
 grade10 ,  
 grade11 ,  
 grade12 ,  
 grade13 ,  
 grade14 ,  
 grade15 ,  
 grade16 ,  
 grade17 ,  
 grade18 ,  
 grade19 ,  
 grade20 ,  
 grade21 ,  
 grade22 ,  
 grade23 ,  
 grade24 ,  
 gradeid ,  
 inv ,  
 load# ,  
 loads ,  
 loc ,  
 spgr ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_grade_list_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 blend =  stg.blend , 
 blend# =  stg.blend# , 
 dumps =  stg.dumps , 
 grade00 =  stg.grade00 , 
 grade01 =  stg.grade01 , 
 grade02 =  stg.grade02 , 
 grade03 =  stg.grade03 , 
 grade04 =  stg.grade04 , 
 grade05 =  stg.grade05 , 
 grade06 =  stg.grade06 , 
 grade07 =  stg.grade07 , 
 grade08 =  stg.grade08 , 
 grade09 =  stg.grade09 , 
 grade10 =  stg.grade10 , 
 grade11 =  stg.grade11 , 
 grade12 =  stg.grade12 , 
 grade13 =  stg.grade13 , 
 grade14 =  stg.grade14 , 
 grade15 =  stg.grade15 , 
 grade16 =  stg.grade16 , 
 grade17 =  stg.grade17 , 
 grade18 =  stg.grade18 , 
 grade19 =  stg.grade19 , 
 grade20 =  stg.grade20 , 
 grade21 =  stg.grade21 , 
 grade22 =  stg.grade22 , 
 grade23 =  stg.grade23 , 
 grade24 =  stg.grade24 , 
 gradeid =  stg.gradeid , 
 inv =  stg.inv , 
 load# =  stg.load# , 
 loads =  stg.loads , 
 loc =  stg.loc , 
 spgr =  stg.spgr , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.blend , 
  stg.blend# , 
  stg.dumps , 
  stg.grade00 , 
  stg.grade01 , 
  stg.grade02 , 
  stg.grade03 , 
  stg.grade04 , 
  stg.grade05 , 
  stg.grade06 , 
  stg.grade07 , 
  stg.grade08 , 
  stg.grade09 , 
  stg.grade10 , 
  stg.grade11 , 
  stg.grade12 , 
  stg.grade13 , 
  stg.grade14 , 
  stg.grade15 , 
  stg.grade16 , 
  stg.grade17 , 
  stg.grade18 , 
  stg.grade19 , 
  stg.grade20 , 
  stg.grade21 , 
  stg.grade22 , 
  stg.grade23 , 
  stg.grade24 , 
  stg.gradeid , 
  stg.inv , 
  stg.load# , 
  stg.loads , 
  stg.loc , 
  stg.spgr , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_grade_list_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_grade_list_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_grade_list_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_grade_list_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_grade_list_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_grade_list_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_load_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_load_c collection table from  lh2_load_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_load_b
*                      
* Usage :  
call edw_etl.lh2_load_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_load_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
	Step 1a: Before actual table we have to bulit the  stage lh2_equip_state_oper_load_time_cat
	Step 1b: insert into  lh2_equip_state_oper_load_time_cat for better performance 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D               Initial version
*   2019-07-31		 Anandhi P		 Included timestamp field (beginspot_ts)
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/  

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_load_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_load_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_load_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   -- Sabarish S 2019-08-30 added as part of incremental load enhancement
   set proc_var_filter_list = ' ( shiftid , site_code ) in   
(select shiftid,site_code from edw_target.lh2_shift_load_tbars_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_load_tmbars_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_load_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_dump_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_aux_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_state_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_reason_b     where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_eqmt_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_oper_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_grade_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_loc_b    where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_sum_shift_load_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_load_lift_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_load_lift_dist_array_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_sum_shift_dump_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''
) ' ;
   end if;



--Step1a: Delete the stage lh2_equip_state_oper_load_time_cat table

delete edw_stage.lh2_equip_state_oper_load_time_cat;

--Step 1b: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_equip_state_oper_load_time_cat ( site_code,'  
  || 'shiftindex, ' 
  || 'shiftid, ' 
  || 'shiftdate, ' 
  || 'eqmt_id, ' 
  || 'cliid, ' 
  || 'eqmt_name, ' 
  || 'eqmt_enum_type, ' 
  || 'eqmt_enum_type_code, ' 
  || 'enum_timecat_code, ' 
  || 'enum_timecat_descr, ' 
  || 'status_event_start_time, ' 
  || 'status_event_end_time, ' 
  || 'status_event_duration_sec, ' 
  || 'fieldreason, ' 
  || 'fieldreasonrec, ' 
  || 'state_enum_status_code, ' 
  || 'fieldcomment, ' 
  || 'oper_login_num, ' 
  || 'oper_logout_num, ' 
  || 'oper_id, ' 
  || 'oper_name, ' 
  || 'oper_start_time, ' 
  || 'oper_end_time, ' 
  || 'starttime_time, ' 
  || 'starttime_num, ' 
  || 'endtime_time, ' 
  || 'endtime_num, ' 
  || 'oper_available_time, ' 
  || 'oper_available_time_sec, ' 
  || 'tmcat01, ' 
  || 'tmcat02, ' 
  || 'tmcat03, ' 
  || 'tmcat04, ' 
  || 'tmcat05, ' 
  || 'tmcat06, ' 
  || 'tmcat07, ' 
  || 'tmcat08, ' 
  || 'tmcat09, ' 
  || 'tmcat10, ' 
  || 'tmcat11, ' 
  || 'tmcat12, ' 
  || 'tmcat13, ' 
  || 'tmcat14, ' 
  || 'tmcat15, ' 
  || 'tmcat16, ' 
  || 'tmcat17, ' 
  || 'tmcat18, ' 
  || ' tmcat19 )'
 || 'select  site_code,'  
  || ' shiftindex, ' 
  || ' shiftid, ' 
  || ' shiftdate, ' 
  || ' eqmt_id, ' 
  || ' cliid, ' 
  || ' eqmt_name, ' 
  || ' eqmt_enum_type, ' 
  || ' eqmt_enum_type_code, ' 
  || ' enum_timecat_code, ' 
  || ' enum_timecat_descr, ' 
  || ' status_event_start_time, ' 
  || ' status_event_end_time, ' 
  || ' status_event_duration_sec, ' 
  || ' fieldreason, ' 
  || ' fieldreasonrec, ' 
  || ' state_enum_status_code, ' 
  || ' fieldcomment, ' 
  || ' oper_login_num, ' 
  || ' oper_logout_num, ' 
  || ' oper_id, ' 
  || ' oper_name, ' 
  || ' oper_start_time, ' 
  || ' oper_end_time, ' 
  || ' starttime_time, ' 
  || ' starttime_num, ' 
  || ' endtime_time, ' 
  || ' endtime_num, ' 
  || ' oper_available_time, ' 
  || ' oper_available_time_sec, ' 
  || ' tmcat01, ' 
  || ' tmcat02, ' 
  || ' tmcat03, ' 
  || ' tmcat04, ' 
  || ' tmcat05, ' 
  || ' tmcat06, ' 
  || ' tmcat07, ' 
  || ' tmcat08, ' 
  || ' tmcat09, ' 
  || ' tmcat10, ' 
  || ' tmcat11, ' 
  || ' tmcat12, ' 
  || ' tmcat13, ' 
  || ' tmcat14, ' 
  || ' tmcat15, ' 
  || ' tmcat16, ' 
  || ' tmcat17, ' 
  || ' tmcat18, ' 
  || ' tmcat19 from edw_etl_view.lh2_equip_state_oper_etl   '
 ||'  where  '|| proc_var_filter_list ||';'
);

--Step1: Delete the stage table

delete edw_stage.lh2_load_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_load_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'atrteh, ' 
  || 'atrtfh, ' 
  || 'beginspot, ' 
  || 'beginspot_ts, ' 
  || 'ctrteh, ' 
  || 'ctrtfh, ' 
  || 'dcsboomjac, ' 
  || 'dcsbuckets, ' 
  || 'dcslastbkt, ' 
  || 'dcsloadtm, ' 
  || 'dcspropelt, ' 
  || 'dcsswingan, ' 
  || 'dcsswingtm, ' 
  || 'dcstons, ' 
  || 'dcstruck, ' 
  || 'disteh, ' 
  || 'distfh, ' 
  || 'dmp, ' 
  || 'dumprec, ' 
  || 'dumptime, ' 
  || 'efheh, ' 
  || 'efhfh, ' 
  || 'emptyhaul, ' 
  || 'eoper, ' 
  || 'ex_tmcat00, ' 
  || 'ex_tmcat01, ' 
  || 'ex_tmcat02, ' 
  || 'ex_tmcat03, ' 
  || 'ex_tmcat04, ' 
  || 'ex_tmcat05, ' 
  || 'ex_tmcat06, ' 
  || 'ex_tmcat07, ' 
  || 'ex_tmcat08, ' 
  || 'ex_tmcat09, ' 
  || 'ex_tmcat10, ' 
  || 'ex_tmcat11, ' 
  || 'ex_tmcat12, ' 
  || 'ex_tmcat13, ' 
  || 'ex_tmcat14, ' 
  || 'ex_tmcat15, ' 
  || 'ex_tmcat16, ' 
  || 'ex_tmcat17, ' 
  || 'ex_tmcat18, ' 
  || 'ex_tmcat19, ' 
  || 'excav, ' 
  || 'excav_orig, ' 
  || 'excavnextl, ' 
  || 'excavprevl, ' 
  || 'extraload, ' 
  || 'fullhaul, ' 
  || 'grade, ' 
  || 'hangtime, ' 
  || 'hos, ' 
  || 'idletime, ' 
  || 'ieh, ' 
  || 'ifh, ' 
  || 'ild, ' 
  || 'intvl, ' 
  || 'isp, ' 
  || 'leycaes, ' 
  || 'lift_down, ' 
  || 'lift_up, ' 
  || 'liftdist_d, ' 
  || 'liftdist_u, ' 
  || 'load, ' 
  || 'loadingtim, ' 
  || 'loadnumber, ' 
  || 'loadold, ' 
  || 'loadtons_us, ' 
  || 'loadtype, ' 
  || 'loc, ' 
  || 'measureton, ' 
  || 'oper, ' 
  || 'ot, ' 
  || 'queuetime, ' 
  || 'shiftlink, ' 
  || 'spottime, ' 
  || 'timearrive, ' 
  || 'timearrive_ts, ' 
  || 'timefull, ' 
  || 'timefull_ts, ' 
  || 'timeload, ' 
  || 'timeload_ts, ' 
  || 'tk_tmcat00, ' 
  || 'tk_tmcat01, ' 
  || 'tk_tmcat02, ' 
  || 'tk_tmcat03, ' 
  || 'tk_tmcat04, ' 
  || 'tk_tmcat05, ' 
  || 'tk_tmcat06, ' 
  || 'tk_tmcat07, ' 
  || 'tk_tmcat08, ' 
  || 'tk_tmcat09, ' 
  || 'tk_tmcat10, ' 
  || 'tk_tmcat11, ' 
  || 'tk_tmcat12, ' 
  || 'tk_tmcat13, ' 
  || 'tk_tmcat14, ' 
  || 'tk_tmcat15, ' 
  || 'tk_tmcat16, ' 
  || 'tk_tmcat17, ' 
  || 'tk_tmcat18, ' 
  || 'tk_tmcat19, ' 
  || 'truck, ' 
  || 'truck_orig, ' 
  || 'ut, ' 
  || 'val_ehaul, ' 
  || 'val_fhaul, ' 
  || 'val_ld, ' 
  || 'val_mt, ' 
  || 'val_sp, ' 
  || 'val_spld, ' 
  || 'val_spldmt, ' 
  || 'dumpasn, ' 
  || 'loadtons, ' 
  || 'dlock, ' 
  || 'elock, ' 
  || 'edlock, ' 
  || 'rlock, ' 
  || 'tbars0, ' 
  || 'tbars1, ' 
  || 'tbars2, ' 
  || 'tbars3, ' 
  || 'tmbars0#, ' 
  || 'tmbars0, ' 
  || 'tmbars1#, ' 
  || 'tmbars1, ' 
  || 'tmbars2#, ' 
  || 'tmbars2, ' 
  || 'tmbars3#, ' 
  || 'tmbars3, ' 
  || 'tmbars4#, ' 
  || 'tmbars4, ' 
  || 'tmbars5#, ' 
  || 'tmbars5, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' atrteh, ' 
  || ' atrtfh, ' 
  || ' beginspot, ' 
  || ' beginspot_ts, ' 
  || ' ctrteh, ' 
  || ' ctrtfh, ' 
  || ' dcsboomjac, ' 
  || ' dcsbuckets, ' 
  || ' dcslastbkt, ' 
  || ' dcsloadtm, ' 
  || ' dcspropelt, ' 
  || ' dcsswingan, ' 
  || ' dcsswingtm, ' 
  || ' dcstons, ' 
  || ' dcstruck, ' 
  || ' disteh, ' 
  || ' distfh, ' 
  || ' dmp, ' 
  || ' dumprec, ' 
  || ' dumptime, ' 
  || ' efheh, ' 
  || ' efhfh, ' 
  || ' emptyhaul, ' 
  || ' eoper, ' 
  || ' ex_tmcat00, ' 
  || ' ex_tmcat01, ' 
  || ' ex_tmcat02, ' 
  || ' ex_tmcat03, ' 
  || ' ex_tmcat04, ' 
  || ' ex_tmcat05, ' 
  || ' ex_tmcat06, ' 
  || ' ex_tmcat07, ' 
  || ' ex_tmcat08, ' 
  || ' ex_tmcat09, ' 
  || ' ex_tmcat10, ' 
  || ' ex_tmcat11, ' 
  || ' ex_tmcat12, ' 
  || ' ex_tmcat13, ' 
  || ' ex_tmcat14, ' 
  || ' ex_tmcat15, ' 
  || ' ex_tmcat16, ' 
  || ' ex_tmcat17, ' 
  || ' ex_tmcat18, ' 
  || ' ex_tmcat19, ' 
  || ' excav, ' 
  || ' excav_orig, ' 
  || ' excavnextl, ' 
  || ' excavprevl, ' 
  || ' extraload, ' 
  || ' fullhaul, ' 
  || ' grade, ' 
  || ' hangtime, ' 
  || ' hos, ' 
  || ' idletime, ' 
  || ' ieh, ' 
  || ' ifh, ' 
  || ' ild, ' 
  || '  intvl, ' 
  || ' isp, ' 
  || ' leycaes, ' 
  || ' lift_down, ' 
  || ' lift_up, ' 
  || ' liftdist_d, ' 
  || ' liftdist_u, ' 
  || ' load, ' 
  || ' loadingtim, ' 
  || ' loadnumber, ' 
  || ' loadold, ' 
  || ' loadtons_us, ' 
  || ' loadtype, ' 
  || ' loc, ' 
  || ' measureton, ' 
  || ' oper, ' 
  || ' ot, ' 
  || ' queuetime, ' 
  || ' shiftlink, ' 
  || ' spottime, ' 
  || ' timearrive, ' 
  || ' timearrive_ts, ' 
  || ' timefull, ' 
  || ' timefull_ts, ' 
  || ' timeload, ' 
  || ' timeload_ts, ' 
  || ' tk_tmcat00, ' 
  || ' tk_tmcat01, ' 
  || ' tk_tmcat02, ' 
  || ' tk_tmcat03, ' 
  || ' tk_tmcat04, ' 
  || ' tk_tmcat05, ' 
  || ' tk_tmcat06, ' 
  || ' tk_tmcat07, ' 
  || ' tk_tmcat08, ' 
  || ' tk_tmcat09, ' 
  || ' tk_tmcat10, ' 
  || ' tk_tmcat11, ' 
  || ' tk_tmcat12, ' 
  || ' tk_tmcat13, ' 
  || ' tk_tmcat14, ' 
  || ' tk_tmcat15, ' 
  || ' tk_tmcat16, ' 
  || ' tk_tmcat17, ' 
  || ' tk_tmcat18, ' 
  || ' tk_tmcat19, ' 
  || ' truck, ' 
  || ' truck_orig, ' 
  || ' ut, ' 
  || ' val_ehaul, ' 
  || ' val_fhaul, ' 
  || ' val_ld, ' 
  || ' val_mt, ' 
  || ' val_sp, ' 
  || ' val_spld, ' 
  || ' val_spldmt, ' 
  || ' dumpasn, ' 
  || ' loadtons, ' 
  || ' dlock, ' 
  || ' elock, ' 
  || ' edlock, ' 
  || ' rlock, ' 
  || ' tbars0, ' 
  || ' tbars1, ' 
  || ' tbars2, ' 
  || ' tbars3, ' 
  || ' tmbars0#, ' 
  || ' tmbars0, ' 
  || ' tmbars1#, ' 
  || ' tmbars1, ' 
  || ' tmbars2#, ' 
  || ' tmbars2, ' 
  || ' tmbars3#, ' 
  || ' tmbars3, ' 
  || ' tmbars4#, ' 
  || ' tmbars4, ' 
  || ' tmbars5#, ' 
  || ' tmbars5, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts  from edw_etl_view.lh2_load_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_load_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 atrteh ,  
 atrtfh ,  
 beginspot ,  
 beginspot_ts , 
 ctrteh ,  
 ctrtfh ,  
 dcsboomjac ,  
 dcsbuckets ,  
 dcslastbkt ,  
 dcsloadtm ,  
 dcspropelt ,  
 dcsswingan ,  
 dcsswingtm ,  
 dcstons ,  
 dcstruck ,  
 disteh ,  
 distfh ,  
 dmp ,  
 dumprec ,  
 dumptime ,  
 efheh ,  
 efhfh ,  
 emptyhaul ,  
 eoper ,  
 ex_tmcat00 ,  
 ex_tmcat01 ,  
 ex_tmcat02 ,  
 ex_tmcat03 ,  
 ex_tmcat04 ,  
 ex_tmcat05 ,  
 ex_tmcat06 ,  
 ex_tmcat07 ,  
 ex_tmcat08 ,  
 ex_tmcat09 ,  
 ex_tmcat10 ,  
 ex_tmcat11 ,  
 ex_tmcat12 ,  
 ex_tmcat13 ,  
 ex_tmcat14 ,  
 ex_tmcat15 ,  
 ex_tmcat16 ,  
 ex_tmcat17 ,  
 ex_tmcat18 ,  
 ex_tmcat19 ,  
 excav ,  
 excav_orig ,  
 excavnextl ,  
 excavprevl ,  
 extraload ,  
 fullhaul ,  
 grade ,  
 hangtime ,  
 hos ,  
 idletime ,  
 ieh ,  
 ifh ,  
 ild ,  
 intvl ,  
 isp ,  
 leycaes ,  
 lift_down ,  
 lift_up ,  
 liftdist_d ,  
 liftdist_u ,  
 load ,  
 loadingtim ,  
 loadnumber ,  
 loadold ,  
 loadtons_us ,  
 loadtype ,  
 loc ,  
 measureton ,  
 oper ,  
 ot ,  
 queuetime ,  
 shiftlink ,  
 spottime ,  
 timearrive ,  
 timearrive_ts ,  
 timefull ,  
 timefull_ts ,  
 timeload ,  
 timeload_ts ,  
 tk_tmcat00 ,  
 tk_tmcat01 ,  
 tk_tmcat02 ,  
 tk_tmcat03 ,  
 tk_tmcat04 ,  
 tk_tmcat05 ,  
 tk_tmcat06 ,  
 tk_tmcat07 ,  
 tk_tmcat08 ,  
 tk_tmcat09 ,  
 tk_tmcat10 ,  
 tk_tmcat11 ,  
 tk_tmcat12 ,  
 tk_tmcat13 ,  
 tk_tmcat14 ,  
 tk_tmcat15 ,  
 tk_tmcat16 ,  
 tk_tmcat17 ,  
 tk_tmcat18 ,  
 tk_tmcat19 ,  
 truck ,  
 truck_orig ,  
 ut ,  
 val_ehaul ,  
 val_fhaul ,  
 val_ld ,  
 val_mt ,  
 val_sp ,  
 val_spld ,  
 val_spldmt ,  
 dumpasn ,  
 loadtons ,  
 dlock ,  
 elock ,  
 edlock ,  
 rlock ,  
 tbars0 ,  
 tbars1 ,  
 tbars2 ,  
 tbars3 ,  
 tmbars0# ,  
 tmbars0 ,  
 tmbars1# ,  
 tmbars1 ,  
 tmbars2# ,  
 tmbars2 ,  
 tmbars3# ,  
 tmbars3 ,  
 tmbars4# ,  
 tmbars4 ,  
 tmbars5# ,  
 tmbars5 ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_load_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 atrteh =  stg.atrteh , 
 atrtfh =  stg.atrtfh , 
 beginspot =  stg.beginspot , 
 beginspot_ts =  stg.beginspot_ts , 
 ctrteh =  stg.ctrteh , 
 ctrtfh =  stg.ctrtfh , 
 dcsboomjac =  stg.dcsboomjac , 
 dcsbuckets =  stg.dcsbuckets , 
 dcslastbkt =  stg.dcslastbkt , 
 dcsloadtm =  stg.dcsloadtm , 
 dcspropelt =  stg.dcspropelt , 
 dcsswingan =  stg.dcsswingan , 
 dcsswingtm =  stg.dcsswingtm , 
 dcstons =  stg.dcstons , 
 dcstruck =  stg.dcstruck , 
 disteh =  stg.disteh , 
 distfh =  stg.distfh , 
 dmp =  stg.dmp , 
 dumprec =  stg.dumprec , 
 dumptime =  stg.dumptime , 
 efheh =  stg.efheh , 
 efhfh =  stg.efhfh , 
 emptyhaul =  stg.emptyhaul , 
 eoper =  stg.eoper , 
 ex_tmcat00 =  stg.ex_tmcat00 , 
 ex_tmcat01 =  stg.ex_tmcat01 , 
 ex_tmcat02 =  stg.ex_tmcat02 , 
 ex_tmcat03 =  stg.ex_tmcat03 , 
 ex_tmcat04 =  stg.ex_tmcat04 , 
 ex_tmcat05 =  stg.ex_tmcat05 , 
 ex_tmcat06 =  stg.ex_tmcat06 , 
 ex_tmcat07 =  stg.ex_tmcat07 , 
 ex_tmcat08 =  stg.ex_tmcat08 , 
 ex_tmcat09 =  stg.ex_tmcat09 , 
 ex_tmcat10 =  stg.ex_tmcat10 , 
 ex_tmcat11 =  stg.ex_tmcat11 , 
 ex_tmcat12 =  stg.ex_tmcat12 , 
 ex_tmcat13 =  stg.ex_tmcat13 , 
 ex_tmcat14 =  stg.ex_tmcat14 , 
 ex_tmcat15 =  stg.ex_tmcat15 , 
 ex_tmcat16 =  stg.ex_tmcat16 , 
 ex_tmcat17 =  stg.ex_tmcat17 , 
 ex_tmcat18 =  stg.ex_tmcat18 , 
 ex_tmcat19 =  stg.ex_tmcat19 , 
 excav =  stg.excav , 
 excav_orig =  stg.excav_orig , 
 excavnextl =  stg.excavnextl , 
 excavprevl =  stg.excavprevl , 
 extraload =  stg.extraload , 
 fullhaul =  stg.fullhaul , 
 grade =  stg.grade , 
 hangtime =  stg.hangtime , 
 hos =  stg.hos , 
 idletime =  stg.idletime , 
 ieh =  stg.ieh , 
 ifh =  stg.ifh , 
 ild =  stg.ild , 
 intvl =  stg.intvl , 
 isp =  stg.isp , 
 leycaes =  stg.leycaes , 
 lift_down =  stg.lift_down , 
 lift_up =  stg.lift_up , 
 liftdist_d =  stg.liftdist_d , 
 liftdist_u =  stg.liftdist_u , 
 load =  stg.load , 
 loadingtim =  stg.loadingtim , 
 loadnumber =  stg.loadnumber , 
 loadold =  stg.loadold , 
 loadtons_us =  stg.loadtons_us , 
 loadtype =  stg.loadtype , 
 loc =  stg.loc , 
 measureton =  stg.measureton , 
 oper =  stg.oper , 
 ot =  stg.ot , 
 queuetime =  stg.queuetime , 
 shiftlink =  stg.shiftlink , 
 spottime =  stg.spottime , 
 timearrive =  stg.timearrive , 
 timearrive_ts =  stg.timearrive_ts , 
 timefull =  stg.timefull , 
 timefull_ts =  stg.timefull_ts , 
 timeload =  stg.timeload , 
 timeload_ts =  stg.timeload_ts , 
 tk_tmcat00 =  stg.tk_tmcat00 , 
 tk_tmcat01 =  stg.tk_tmcat01 , 
 tk_tmcat02 =  stg.tk_tmcat02 , 
 tk_tmcat03 =  stg.tk_tmcat03 , 
 tk_tmcat04 =  stg.tk_tmcat04 , 
 tk_tmcat05 =  stg.tk_tmcat05 , 
 tk_tmcat06 =  stg.tk_tmcat06 , 
 tk_tmcat07 =  stg.tk_tmcat07 , 
 tk_tmcat08 =  stg.tk_tmcat08 , 
 tk_tmcat09 =  stg.tk_tmcat09 , 
 tk_tmcat10 =  stg.tk_tmcat10 , 
 tk_tmcat11 =  stg.tk_tmcat11 , 
 tk_tmcat12 =  stg.tk_tmcat12 , 
 tk_tmcat13 =  stg.tk_tmcat13 , 
 tk_tmcat14 =  stg.tk_tmcat14 , 
 tk_tmcat15 =  stg.tk_tmcat15 , 
 tk_tmcat16 =  stg.tk_tmcat16 , 
 tk_tmcat17 =  stg.tk_tmcat17 , 
 tk_tmcat18 =  stg.tk_tmcat18 , 
 tk_tmcat19 =  stg.tk_tmcat19 , 
 truck =  stg.truck , 
 truck_orig =  stg.truck_orig , 
 ut =  stg.ut , 
 val_ehaul =  stg.val_ehaul , 
 val_fhaul =  stg.val_fhaul , 
 val_ld =  stg.val_ld , 
 val_mt =  stg.val_mt , 
 val_sp =  stg.val_sp , 
 val_spld =  stg.val_spld , 
 val_spldmt =  stg.val_spldmt , 
 dumpasn =  stg.dumpasn , 
 loadtons =  stg.loadtons , 
 dlock =  stg.dlock , 
 elock =  stg.elock , 
 edlock =  stg.edlock , 
 rlock =  stg.rlock , 
 tbars0 =  stg.tbars0 , 
 tbars1 =  stg.tbars1 , 
 tbars2 =  stg.tbars2 , 
 tbars3 =  stg.tbars3 , 
 tmbars0# =  stg.tmbars0# , 
 tmbars0 =  stg.tmbars0 , 
 tmbars1# =  stg.tmbars1# , 
 tmbars1 =  stg.tmbars1 , 
 tmbars2# =  stg.tmbars2# , 
 tmbars2 =  stg.tmbars2 , 
 tmbars3# =  stg.tmbars3# , 
 tmbars3 =  stg.tmbars3 , 
 tmbars4# =  stg.tmbars4# , 
 tmbars4 =  stg.tmbars4 , 
 tmbars5# =  stg.tmbars5# , 
 tmbars5 =  stg.tmbars5 , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.atrteh , 
  stg.atrtfh , 
  stg.beginspot , 
   stg.beginspot_ts , 
  stg.ctrteh , 
  stg.ctrtfh , 
  stg.dcsboomjac , 
  stg.dcsbuckets , 
  stg.dcslastbkt , 
  stg.dcsloadtm , 
  stg.dcspropelt , 
  stg.dcsswingan , 
  stg.dcsswingtm , 
  stg.dcstons , 
  stg.dcstruck , 
  stg.disteh , 
  stg.distfh , 
  stg.dmp , 
  stg.dumprec , 
  stg.dumptime , 
  stg.efheh , 
  stg.efhfh , 
  stg.emptyhaul , 
  stg.eoper , 
  stg.ex_tmcat00 , 
  stg.ex_tmcat01 , 
  stg.ex_tmcat02 , 
  stg.ex_tmcat03 , 
  stg.ex_tmcat04 , 
  stg.ex_tmcat05 , 
  stg.ex_tmcat06 , 
  stg.ex_tmcat07 , 
  stg.ex_tmcat08 , 
  stg.ex_tmcat09 , 
  stg.ex_tmcat10 , 
  stg.ex_tmcat11 , 
  stg.ex_tmcat12 , 
  stg.ex_tmcat13 , 
  stg.ex_tmcat14 , 
  stg.ex_tmcat15 , 
  stg.ex_tmcat16 , 
  stg.ex_tmcat17 , 
  stg.ex_tmcat18 , 
  stg.ex_tmcat19 , 
  stg.excav , 
  stg.excav_orig , 
  stg.excavnextl , 
  stg.excavprevl , 
  stg.extraload , 
  stg.fullhaul , 
  stg.grade , 
  stg.hangtime , 
  stg.hos , 
  stg.idletime , 
  stg.ieh , 
  stg.ifh , 
  stg.ild , 
  stg.intvl , 
  stg.isp , 
  stg.leycaes , 
  stg.lift_down , 
  stg.lift_up , 
  stg.liftdist_d , 
  stg.liftdist_u , 
  stg.load , 
  stg.loadingtim , 
  stg.loadnumber , 
  stg.loadold , 
  stg.loadtons_us , 
  stg.loadtype , 
  stg.loc , 
  stg.measureton , 
  stg.oper , 
  stg.ot , 
  stg.queuetime , 
  stg.shiftlink , 
  stg.spottime , 
  stg.timearrive , 
  stg.timearrive_ts , 
  stg.timefull , 
  stg.timefull_ts , 
  stg.timeload , 
  stg.timeload_ts , 
  stg.tk_tmcat00 , 
  stg.tk_tmcat01 , 
  stg.tk_tmcat02 , 
  stg.tk_tmcat03 , 
  stg.tk_tmcat04 , 
  stg.tk_tmcat05 , 
  stg.tk_tmcat06 , 
  stg.tk_tmcat07 , 
  stg.tk_tmcat08 , 
  stg.tk_tmcat09 , 
  stg.tk_tmcat10 , 
  stg.tk_tmcat11 , 
  stg.tk_tmcat12 , 
  stg.tk_tmcat13 , 
  stg.tk_tmcat14 , 
  stg.tk_tmcat15 , 
  stg.tk_tmcat16 , 
  stg.tk_tmcat17 , 
  stg.tk_tmcat18 , 
  stg.tk_tmcat19 , 
  stg.truck , 
  stg.truck_orig , 
  stg.ut , 
  stg.val_ehaul , 
  stg.val_fhaul , 
  stg.val_ld , 
  stg.val_mt , 
  stg.val_sp , 
  stg.val_spld , 
  stg.val_spldmt , 
  stg.dumpasn , 
  stg.loadtons , 
  stg.dlock , 
  stg.elock , 
  stg.edlock , 
  stg.rlock , 
  stg.tbars0 , 
  stg.tbars1 , 
  stg.tbars2 , 
  stg.tbars3 , 
  stg.tmbars0# , 
  stg.tmbars0 , 
  stg.tmbars1# , 
  stg.tmbars1 , 
  stg.tmbars2# , 
  stg.tmbars2 , 
  stg.tmbars3# , 
  stg.tmbars3 , 
  stg.tmbars4# , 
  stg.tmbars4 , 
  stg.tmbars5# , 
  stg.tmbars5 , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_load_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_load_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_load_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_load_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_load_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_load_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"




replace  procedure edw_etl.lh2_location_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey
* PURPOSE : Load the lh2_location_c collection table from  lh2_location_ds6_etl view based on dw_modify_ts of base table  edw_target.lh2_shift_loc_b 
*                      
* Usage :  
call edw_etl.lh2_location_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_location_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_location_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_location_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_loc_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   set proc_var_filter_list = ' ( shiftid , site_code ) in   ( select shiftid , site_code  from   edw_target.lh2_shift_loc_b    where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  group by 1,2 ) ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_location_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_location_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'locid, ' 
  || 'pit, ' 
  || 'region, ' 
  || 'elev, ' 
  || 'elev_dispatch, ' 
  || 'unit#, ' 
  || 'unit, ' 
  || 'x, ' 
  || 'y, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' locid, ' 
  || ' pit, ' 
  || ' region, ' 
  || ' elev, ' 
  || ' elev_dispatch, ' 
  || ' unit#, ' 
  || ' unit, ' 
  || ' x, ' 
  || ' y, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_location_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_location_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 locid ,  
 pit ,  
 region ,  
 elev ,  
 elev_dispatch ,  
 unit# ,  
 unit ,  
 x ,  
 y ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_location_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 locid =  stg.locid , 
 pit =  stg.pit , 
 region =  stg.region , 
 elev =  stg.elev , 
 elev_dispatch =  stg.elev_dispatch , 
 unit# =  stg.unit# , 
 unit =  stg.unit , 
 x =  stg.x , 
 y =  stg.y , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.locid , 
  stg.pit , 
  stg.region , 
  stg.elev , 
  stg.elev_dispatch , 
  stg.unit# , 
  stg.unit , 
  stg.x , 
  stg.y , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_location_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_location_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_location_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_location_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_location_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_location_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"




replace  procedure edw_etl.lh2_oper_list_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_oper_list_c collection table from  lh2_oper_list_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_oper_b
*                      
* Usage :  
call edw_etl.lh2_oper_list_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_oper_list_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_list_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_list_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_oper_b); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   set proc_var_filter_list = ' 	( shiftid , site_code ) in   ( select shiftid , site_code from edw_target.lh2_shift_oper_b    where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  group by 1,2 ) ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_oper_list_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_oper_list_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'operid, ' 
  || 'name, ' 
  || 'crew#, ' 
  || 'crew, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' operid, ' 
  || ' name, ' 
  || ' crew#, ' 
  || ' crew, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts  from edw_etl_view.lh2_oper_list_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_oper_list_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 operid ,  
 name ,  
 crew# ,  
 crew ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_oper_list_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 operid =  stg.operid , 
 name =  stg.name , 
 crew# =  stg.crew# , 
 crew =  stg.crew , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.operid , 
  stg.name , 
  stg.crew# , 
  stg.crew , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_oper_list_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_oper_list_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_oper_list_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_oper_list_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_oper_list_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_oper_list_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace procedure edw_etl.lh2_oper_total_sum_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey , eqmtid , logintime , locid ,operid, unit#
* PURPOSE : Load the lh2_oper_total_sum_c collection table from  lh2_oper_total_sum_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_oper_b
*                      
* Usage :  
call edw_etl.lh2_oper_total_sum_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_oper_total_sum_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
	Step 1a: Before actual table we have to bulit the  stage lh2_equip_state_oper_total_sum
	Step 1b: insert into  lh2_equip_state_oper_total_sum for better performance 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D                Initial version
*   2019-04-10		 Kali D				To improve perfromance we are loading the data into stage table  edw_stage.lh2_equip_state_oper
*   2019-07-31		Anandhi P		Included timestamp field (logintime_ts)
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_total_sum_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_total_sum_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_oper_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   -- Sabarish S 2019-08-30 added as part of incremental load enhancement
   set proc_var_filter_list = ' ( shiftindex, site_code) in   
(
select shiftindex,site_code from edw_target.lh2_load_c   where dw_modify_ts >=  timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select ((shiftdate - (date ''1970-01-01'' )) * 2  + (shiftid -1) mod 2) shiftindex ,site_code from edw_target.lh2_shift_aux_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select ((shiftdate - (date ''1970-01-01'' )) * 2  + (shiftid -1) mod 2) shiftindex  ,site_code from edw_target.lh2_shift_eqmt_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select ((shiftdate - (date ''1970-01-01'' )) * 2  + (shiftid -1) mod 2) shiftindex  ,site_code from edw_target.lh2_shift_loc_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select ((shiftdate - (date ''1970-01-01'' )) * 2  + (shiftid -1) mod 2) shiftindex  ,site_code from edw_target.lh2_shift_state_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select ((shiftdate - (date ''1970-01-01'' )) * 2  + (shiftid -1) mod 2) shiftindex ,site_code from edw_target.lh2_shift_reason_b   where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select ((shiftdate - (date ''1970-01-01'' )) * 2  + (shiftid -1) mod 2) shiftindex  ,site_code from edw_target.lh2_shift_oper_b where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''') ' ;
   end if;


--Step1a: Delete the stage lh2_equip_state_oper table

delete edw_stage.lh2_equip_state_oper_total_sum;

--Step 1b: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_equip_state_oper_total_sum ( site_code,'  
  || 'shiftindex, ' 
  || 'shiftid, ' 
  || 'shiftdate, ' 
  || 'eqmt_id, ' 
  || 'cliid, ' 
  || 'eqmt_name, ' 
  || 'eqmt_enum_type, ' 
  || 'eqmt_enum_type_code, ' 
  || 'enum_timecat_code, ' 
  || 'enum_timecat_descr, ' 
  || 'status_event_start_time, ' 
  || 'status_event_end_time, ' 
  || 'status_event_duration_sec, ' 
  || 'fieldreason, ' 
  || 'fieldreasonrec, ' 
  || 'state_enum_status_code, ' 
  || 'fieldcomment, ' 
  || 'oper_login_num, ' 
  || 'oper_logout_num, ' 
  || 'oper_id, ' 
  || 'oper_name, ' 
  || 'oper_start_time, ' 
  || 'oper_end_time, ' 
  || 'starttime_time, ' 
  || 'starttime_num, ' 
  || 'endtime_time, ' 
  || 'endtime_num, ' 
  || 'oper_available_time, ' 
  || 'oper_available_time_sec, ' 
  || 'tmcat01, ' 
  || 'tmcat02, ' 
  || 'tmcat03, ' 
  || 'tmcat04, ' 
  || 'tmcat05, ' 
  || 'tmcat06, ' 
  || 'tmcat07, ' 
  || 'tmcat08, ' 
  || 'tmcat09, ' 
  || 'tmcat10, ' 
  || 'tmcat11, ' 
  || 'tmcat12, ' 
  || 'tmcat13, ' 
  || 'tmcat14, ' 
  || 'tmcat15, ' 
  || 'tmcat16, ' 
  || 'tmcat17, ' 
  || 'tmcat18, ' 
  || ' tmcat19 )'
 || 'select  site_code,'  
  || ' shiftindex, ' 
  || ' shiftid, ' 
  || ' shiftdate, ' 
  || ' eqmt_id, ' 
  || ' cliid, ' 
  || ' eqmt_name, ' 
  || ' eqmt_enum_type, ' 
  || ' eqmt_enum_type_code, ' 
  || ' enum_timecat_code, ' 
  || ' enum_timecat_descr, ' 
  || ' status_event_start_time, ' 
  || ' status_event_end_time, ' 
  || ' status_event_duration_sec, ' 
  || ' fieldreason, ' 
  || ' fieldreasonrec, ' 
  || ' state_enum_status_code, ' 
  || ' fieldcomment, ' 
  || ' oper_login_num, ' 
  || ' oper_logout_num, ' 
  || ' oper_id, ' 
  || ' oper_name, ' 
  || ' oper_start_time, ' 
  || ' oper_end_time, ' 
  || ' starttime_time, ' 
  || ' starttime_num, ' 
  || ' endtime_time, ' 
  || ' endtime_num, ' 
  || ' oper_available_time, ' 
  || ' oper_available_time_sec, ' 
  || ' tmcat01, ' 
  || ' tmcat02, ' 
  || ' tmcat03, ' 
  || ' tmcat04, ' 
  || ' tmcat05, ' 
  || ' tmcat06, ' 
  || ' tmcat07, ' 
  || ' tmcat08, ' 
  || ' tmcat09, ' 
  || ' tmcat10, ' 
  || ' tmcat11, ' 
  || ' tmcat12, ' 
  || ' tmcat13, ' 
  || ' tmcat14, ' 
  || ' tmcat15, ' 
  || ' tmcat16, ' 
  || ' tmcat17, ' 
  || ' tmcat18, ' 
  || ' tmcat19 from edw_etl_view.lh2_equip_state_oper_etl   '
 ||'  where  '|| proc_var_filter_list ||';'
);



--Step1: Delete the stage table

delete edw_stage.lh2_oper_total_sum_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_oper_total_sum_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'eqmtid, ' 
  || 'eqmtid_orig, ' 
  || 'idletime, ' 
  || 'loadcnt, ' 
  || 'loadtime, ' 
  || 'locid, ' 
  || 'logintime, ' 
  || 'logintime_ts, ' 
  || 'name, ' 
  || 'operid, ' 
  || 'pit, ' 
  || 'spottime, ' 
  || 'tmcat00, ' 
  || 'tmcat01, ' 
  || 'tmcat02, ' 
  || 'tmcat03, ' 
  || 'tmcat04, ' 
  || 'tmcat05, ' 
  || 'tmcat06, ' 
  || 'tmcat07, ' 
  || 'tmcat08, ' 
  || 'tmcat09, ' 
  || 'tmcat10, ' 
  || 'tmcat11, ' 
  || 'tmcat12, ' 
  || 'tmcat13, ' 
  || 'tmcat14, ' 
  || 'tmcat15, ' 
  || 'tmcat16, ' 
  || 'tmcat17, ' 
  || 'tmcat18, ' 
  || 'tmcat19, ' 
  || 'totalloads, ' 
  || 'totaltime, ' 
  || 'totaltons, ' 
  || 'unit, ' 
  || 'unit#, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' eqmtid, ' 
  || ' eqmtid_orig, ' 
  || ' idletime, ' 
  || ' loadcnt, ' 
  || ' loadtime, ' 
  || ' locid, ' 
  || ' logintime, ' 
  || ' logintime_ts, ' 
  || ' name, ' 
  || ' operid, ' 
  || ' pit, ' 
  || ' spottime, ' 
  || ' tmcat00, ' 
  || ' tmcat01, ' 
  || ' tmcat02, ' 
  || ' tmcat03, ' 
  || ' tmcat04, ' 
  || ' tmcat05, ' 
  || ' tmcat06, ' 
  || ' tmcat07, ' 
  || ' tmcat08, ' 
  || ' tmcat09, ' 
  || ' tmcat10, ' 
  || ' tmcat11, ' 
  || ' tmcat12, ' 
  || ' tmcat13, ' 
  || ' tmcat14, ' 
  || ' tmcat15, ' 
  || ' tmcat16, ' 
  || ' tmcat17, ' 
  || ' tmcat18, ' 
  || ' tmcat19, ' 
  || ' totalloads, ' 
  || ' totaltime, ' 
  || ' totaltons, ' 
  || ' unit, ' 
  || ' unit#, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as  dw_load_ts from edw_etl_view.lh2_oper_total_sum_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_oper_total_sum_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 eqmtid ,  
 eqmtid_orig ,  
 idletime ,  
 loadcnt ,  
 loadtime ,  
 locid ,  
 logintime ,  
 logintime_ts ,  
 name ,  
 operid ,  
 pit ,  
 spottime ,  
 tmcat00 ,  
 tmcat01 ,  
 tmcat02 ,  
 tmcat03 ,  
 tmcat04 ,  
 tmcat05 ,  
 tmcat06 ,  
 tmcat07 ,  
 tmcat08 ,  
 tmcat09 ,  
 tmcat10 ,  
 tmcat11 ,  
 tmcat12 ,  
 tmcat13 ,  
 tmcat14 ,  
 tmcat15 ,  
 tmcat16 ,  
 tmcat17 ,  
 tmcat18 ,  
 tmcat19 ,  
 totalloads ,  
 totaltime ,  
 totaltons ,  
 unit ,  
 unit# ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_oper_total_sum_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey and 
stg.eqmtid =  tgt.eqmtid and
stg.logintime =  tgt.logintime  and 
stg.locid =  tgt.locid and
stg.operid =  tgt.operid and
stg.unit# =  tgt.unit# )

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 eqmtid_orig =  stg.eqmtid_orig , 
 idletime =  stg.idletime , 
 loadcnt =  stg.loadcnt , 
 loadtime =  stg.loadtime , 
 logintime_ts =  stg.logintime_ts , 
 name =  stg.name , 
  pit =  stg.pit , 
 spottime =  stg.spottime , 
 tmcat00 =  stg.tmcat00 , 
 tmcat01 =  stg.tmcat01 , 
 tmcat02 =  stg.tmcat02 , 
 tmcat03 =  stg.tmcat03 , 
 tmcat04 =  stg.tmcat04 , 
 tmcat05 =  stg.tmcat05 , 
 tmcat06 =  stg.tmcat06 , 
 tmcat07 =  stg.tmcat07 , 
 tmcat08 =  stg.tmcat08 , 
 tmcat09 =  stg.tmcat09 , 
 tmcat10 =  stg.tmcat10 , 
 tmcat11 =  stg.tmcat11 , 
 tmcat12 =  stg.tmcat12 , 
 tmcat13 =  stg.tmcat13 , 
 tmcat14 =  stg.tmcat14 , 
 tmcat15 =  stg.tmcat15 , 
 tmcat16 =  stg.tmcat16 , 
 tmcat17 =  stg.tmcat17 , 
 tmcat18 =  stg.tmcat18 , 
 tmcat19 =  stg.tmcat19 , 
 totalloads =  stg.totalloads , 
 totaltime =  stg.totaltime , 
 totaltons =  stg.totaltons , 
 unit =  stg.unit , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.eqmtid , 
  stg.eqmtid_orig , 
  stg.idletime , 
  stg.loadcnt , 
  stg.loadtime , 
  stg.locid , 
  stg.logintime , 
  stg.logintime_ts , 
  stg.name , 
  stg.operid , 
  stg.pit , 
  stg.spottime , 
  stg.tmcat00 , 
  stg.tmcat01 , 
  stg.tmcat02 , 
  stg.tmcat03 , 
  stg.tmcat04 , 
  stg.tmcat05 , 
  stg.tmcat06 , 
  stg.tmcat07 , 
  stg.tmcat08 , 
  stg.tmcat09 , 
  stg.tmcat10 , 
  stg.tmcat11 , 
  stg.tmcat12 , 
  stg.tmcat13 , 
  stg.tmcat14 , 
  stg.tmcat15 , 
  stg.tmcat16 , 
  stg.tmcat17 , 
  stg.tmcat18 , 
  stg.tmcat19 , 
  stg.totalloads , 
  stg.totaltime , 
  stg.totaltons , 
  stg.unit , 
  stg.unit# , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_oper_total_sum_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_oper_total_sum_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
		and stg.cliid = tgt.cliid 
		and stg.ddbkey = tgt.ddbkey 
		and stg.eqmtid =  tgt.eqmtid 
		and stg.logintime =  tgt.logintime   
		and stg.locid =  tgt.locid 
		and stg.operid =  tgt.operid
		and stg.unit# =  tgt.unit#
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_oper_total_sum_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_oper_total_sum_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_oper_total_sum_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_oper_total_sum_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"




replace procedure edw_etl.lh2_reason_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of extension table: cliid , shiftindex, ddbkey
* PURPOSE : Load the lh2_reason_c collection table from  lh2_reason_ds6_etl view based on dw_modify_ts of base table ADD SOURCE TABLE NAME
*                      
* Usage :  
call edw_etl.lh2_reason_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_reason_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_reason_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_reason_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_pit_reason_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   set proc_var_filter_list = ' ( shiftindex, cliid) in   ( select shiftindex, cliid from  edw_etl_view.lh2_reason_ds6_etl  where dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  group by 1,2 ) ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_reason_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_reason_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'name, ' 
  || 'reason, ' 
  || 'status, ' 
  || 'delaytime, ' 
  || 'category, ' 
  || 'mainttime, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' name, ' 
  || ' reason, ' 
  || ' status, ' 
  || ' delaytime, ' 
  || ' category, ' 
  || ' mainttime, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts  from edw_etl_view.lh2_reason_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_reason_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 name ,  
 reason ,  
 status ,  
 delaytime ,  
 category ,  
 mainttime ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_reason_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey and 
stg.reason =  tgt.reason and 
 stg.status =  tgt.status )

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 name =  stg.name , 
 delaytime =  stg.delaytime , 
 category =  stg.category , 
 mainttime =  stg.mainttime , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.name , 
  stg.reason , 
  stg.status , 
  stg.delaytime , 
  stg.category , 
  stg.mainttime , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_reason_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_reason_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
	  and stg.reason =  tgt.reason
	  and  stg.status =  tgt.status 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_reason_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_reason_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_reason_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_reason_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"




replace  procedure edw_etl.lh2_roaddump_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey , locstart ,locend
* PURPOSE : Load the lh2_roaddump_c collection table from  lh2_roaddump_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_pit_travel_b
*                      
* Usage :  
call edw_etl.lh2_roaddump_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_roaddump_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_roaddump_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_roaddump_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_pit_travel_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   set proc_var_filter_list = ' ( shiftindex, cliid) in   ( select  shiftindex,  cliid from  edw_etl_view.lh2_roaddump_ds6_etl     where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  group by 1,2 ) ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_roaddump_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_roaddump_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'site_name, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'id, ' 
  || 'locstart, ' 
  || 'locend, ' 
  || 'dist, ' 
  || 'startx, ' 
  || 'starty, ' 
  || 'startz, ' 
  || 'endx, ' 
  || 'endy, ' 
  || 'endz, ' 
  || 'grade, ' 
  || 'xgraph_0, ' 
  || 'xgraph_1, ' 
  || 'xgraph_2, ' 
  || 'ygraph_1, ' 
  || 'ygraph_2, ' 
  || 'closed, ' 
  || 'timeempty, ' 
  || 'timeloaded, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' site_name, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' id, ' 
  || ' locstart, ' 
  || ' locend, ' 
  || ' dist, ' 
  || ' startx, ' 
  || ' starty, ' 
  || ' startz, ' 
  || ' endx, ' 
  || ' endy, ' 
  || ' endz, ' 
  || ' grade, ' 
  || ' xgraph_0, ' 
  || ' xgraph_1, ' 
  || ' xgraph_2, ' 
  || ' ygraph_1, ' 
  || ' ygraph_2, ' 
  || ' closed, ' 
  || ' timeempty, ' 
  || ' timeloaded, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_roaddump_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_roaddump_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 site_name ,  
 cliid ,  
 ddbkey ,  
 id ,  
 locstart ,  
 locend ,  
 dist ,  
 startx ,  
 starty ,  
 startz ,  
 endx ,  
 endy ,  
 endz ,  
 grade ,  
 xgraph_0 ,  
 xgraph_1 ,  
 xgraph_2 ,  
 ygraph_1 ,  
 ygraph_2 ,  
 closed ,  
 timeempty ,  
 timeloaded ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_roaddump_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey and 
stg.locstart =  tgt.locstart and  
 stg.locend =  tgt.locend  )

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 site_name =  stg.site_name , 
 id =  stg.id , 
 dist =  stg.dist , 
 startx =  stg.startx , 
 starty =  stg.starty , 
 startz =  stg.startz , 
 endx =  stg.endx , 
 endy =  stg.endy , 
 endz =  stg.endz , 
 grade =  stg.grade , 
 xgraph_0 =  stg.xgraph_0 , 
 xgraph_1 =  stg.xgraph_1 , 
 xgraph_2 =  stg.xgraph_2 , 
 ygraph_1 =  stg.ygraph_1 , 
 ygraph_2 =  stg.ygraph_2 , 
 closed =  stg.closed , 
 timeempty =  stg.timeempty , 
 timeloaded =  stg.timeloaded , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.site_name , 
  stg.cliid , 
  stg.ddbkey , 
  stg.id , 
  stg.locstart , 
  stg.locend , 
  stg.dist , 
  stg.startx , 
  stg.starty , 
  stg.startz , 
  stg.endx , 
  stg.endy , 
  stg.endz , 
  stg.grade , 
  stg.xgraph_0 , 
  stg.xgraph_1 , 
  stg.xgraph_2 , 
  stg.ygraph_1 , 
  stg.ygraph_2 , 
  stg.closed , 
  stg.timeempty , 
  stg.timeloaded , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_roaddump_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_roaddump_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
	  and stg.locstart =  tgt.locstart 
      and stg.locend =  tgt.locend
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_roaddump_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_roaddump_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_roaddump_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_roaddump_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"




replace  procedure edw_etl.lh2_shift_date_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode VARCHAR(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_shift_date_c collection table from  lh2_shift_date_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_info_b
*                      
* Usage :  
call edw_etl.lh2_shift_date_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_shift_date_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_shift_date_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_shift_date_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_info_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   set proc_var_filter_list = ' ( shiftid , site_code ) in   ( select shiftid , site_code from  edw_target.lh2_shift_info_b     where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||'''  group by 1,2 ) ' ;
   end if;


--Step1: Delete the stage table

delete edw_stage.lh2_shift_date_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_shift_date_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'name, ' 
  || 'years, ' 
  || 'month#, ' 
  || 'months, ' 
  || 'days, ' 
  || 'shift#, ' 
  || 'shift, ' 
  || 'dates, ' 
  || 'starts, ' 
  || 'crew#, ' 
  || 'crew, ' 
  || 'len, ' 
  || 'disptime, ' 
  || 'holiday, ' 
  || 'ddmmyy, ' 
  || 'finyear, ' 
  || 'finquarter, ' 
  || 'finmonth, ' 
  || 'finweek, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' name, ' 
  || ' years, ' 
  || ' month#, ' 
  || ' months, ' 
  || ' days, ' 
  || ' shift#, ' 
  || ' shift, ' 
  || ' dates, ' 
  || ' starts, ' 
  || ' crew#, ' 
  || ' crew, ' 
  || ' len, ' 
  || ' disptime, ' 
  || ' holiday, ' 
  || ' ddmmyy, ' 
  || ' finyear, ' 
  || ' finquarter, ' 
  || ' finmonth, ' 
  || ' finweek, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
  ||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_shift_date_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);

--Step3: merge into target table
merge into edw_target.lh2_shift_date_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 name ,  
 years ,  
 month# ,  
 months ,  
 days ,  
 shift# ,  
 shift ,  
 dates ,  
 starts ,  
 crew# ,  
 crew ,  
 len ,  
 disptime ,  
 holiday ,  
 ddmmyy ,  
 finyear ,  
 finquarter ,  
 finmonth ,  
 finweek ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_shift_date_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid
and stg.ddbkey = tgt.ddbkey)

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 ddbkey =  stg.ddbkey , 
 name =  stg.name , 
 years =  stg.years , 
 month# =  stg.month# , 
 months =  stg.months , 
 days =  stg.days , 
 shift# =  stg.shift# , 
 shift =  stg.shift , 
 dates =  stg.dates , 
 starts =  stg.starts , 
 crew# =  stg.crew# , 
 crew =  stg.crew , 
 len =  stg.len , 
 disptime =  stg.disptime , 
 holiday =  stg.holiday , 
 ddmmyy =  stg.ddmmyy , 
 finyear =  stg.finyear , 
 finquarter =  stg.finquarter , 
 finmonth =  stg.finmonth , 
 finweek =  stg.finweek , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.name , 
  stg.years , 
  stg.month# , 
  stg.months , 
  stg.days , 
  stg.shift# , 
  stg.shift , 
  stg.dates , 
  stg.starts , 
  stg.crew# , 
  stg.crew , 
  stg.len , 
  stg.disptime , 
  stg.holiday , 
  stg.ddmmyy , 
  stg.finyear , 
  stg.finquarter , 
  stg.finmonth , 
  stg.finweek , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows  don't think its required Kali D
 
update edw_target.lh2_shift_date_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_shift_date_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_shift_date_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_shift_date_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_shift_date_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_shift_date_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"RequestText"

create  procedure edw_etl.lh2_status_data_c_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey ( Is actually driving table's ID columns),eqmt, starttime 
* PURPOSE : Load the lh2_status_data_c collection table from  lh2_status_data_etl view based on dw_modify_ts of base table pddw.lh_status_event
*                      
* Usage :  
call edw_etl.lh2_status_data_c_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,43195,1554590','FULL' );
call edw_etl.lh2_status_data_c_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-07-30       Sabarish S         Initial version
*    *****************************************************************************************************************************************************/ 

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_data_c_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_data_c_sp');
set proc_var_base_max_dw_modify_ts =  (select max(dw_modify_ts) from pddw.lh_status_event ); 



if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
--Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
			delete edw_stage.lh2_status_data_shift_stage;
			call dbc.sysexecsql (' insert into edw_stage.lh2_status_data_shift_stage '
			||' (cliid,shiftindex)  '
			||' select	 cliid ,shiftindex' 
			||' from pddw.lh_status_event   '
			||' where	shiftindex = shiftindex '
			||' and ' || proc_var_filter_list  ||' group by 1,2 ;'
			);
			
		else 
  	--                 if  (select cast( proc_var_rt_max_dw_load_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
    --                        then
    --                      set proc_var_rt_max_dw_load_ts = proc_var_di_last_run_ts ;
    --                end if;
--Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
			delete edw_stage.lh2_status_data_shift_stage;
			call dbc.sysexecsql (' insert into edw_stage.lh2_status_data_shift_stage '
			||' (cliid,shiftindex)  '
			||' select	 cliid ,shiftindex' 
			||' from pddw.lh_status_event   '
			||' where	shiftindex = shiftindex '
			||' and dw_modify_ts >=  timestamp ''' || proc_var_di_last_run_ts  ||'''  group by 1,2 ;'
			);
end if;

--Step1: Delete the stage table

delete  edw_stage.lh2_status_data;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_status_data ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'eqmt, ' 
  || 'unit, ' 
  || 'operid, ' 
  || 'starttime, ' 
  || 'endtime, ' 
  || 'duration, ' 
  || 'category, ' 
  || 'reason, ' 
  || 'classification, ' 
  || 'comments, ' 
  || 'workorder, ' 
  || 'validevent, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' 0, ' 
  || ' eqmt, ' 
  || ' unit, ' 
  || ' operid, ' 
  || ' starttime, ' 
  || ' endtime, ' 
  || ' duration, ' 
  || ' category, ' 
  || ' reason, ' 
  || 'classification, ' 
  || ' comments, ' 
  || ' workorder, ' 
  || ' validevent, ' 
   ||' system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_status_data_etl  ; '
);


--Step3: merge into target table
merge into edw_target.lh2_status_data_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 eqmt ,  
 unit ,  
 operid ,  
 starttime ,  
 endtime ,  
 duration ,
 category , 
 reason ,  
 classification ,    
 comments ,  
 workorder ,  
 validevent ,   
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_status_data 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.eqmt = tgt.eqmt and
stg.starttime = tgt.starttime )

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 unit =  stg.unit , 
 operid =  stg.operid , 
 endtime =  stg.endtime , 
 duration =  stg.duration ,
 category =  stg.category , 
 reason =  stg.reason , 
 classification =  stg.classification ,  
 comments =  stg.comments , 
 workorder =  stg.workorder , 
 validevent =  stg.validevent , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.eqmt , 
  stg.unit , 
  stg.operid , 
  stg.starttime , 
  stg.endtime , 
  stg.duration , 
  stg.category , 
  stg.reason , 
  stg.classification , 
  stg.comments , 
  stg.workorder , 
  stg.validevent , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_status_data_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_status_data as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.eqmt = tgt.eqmt
	  and stg.starttime = tgt.starttime 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_status_data  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_status_data_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_status_data), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_status_data_c_sp';


end;
--------------------------------------------------------------------------------

"RequestText"
replace  procedure edw_etl.lh2_status_event_c_ds6_sp ( start_shift_date DATE,end_shift_date DATE, filter_cliid VARCHAR(100), extract_mode Varchar(10))
begin

/****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey ( Is actually driving table's ID columns), starttime 
* PURPOSE : Load the lh2_status_event_c collection table from  lh2_status_event_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_state_b
*                      
* Usage :  
call edw_etl.lh2_status_event_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_status_event_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   
*    2019-03-08       Kali D              Initial version
*   2019-07-31		 Anandhi P		 Included timestamp field (starttime_ts & endtime_ts)
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/  

declare proc_var_dw_modify_ts varchar(19) ;
declare proc_var_ds6_base_max_dw_modify_ts varchar(19);
declare proc_var_di_last_run_ts varchar(19);
declare proc_var_di_last_run_ts_no_look_back timestamp(0);
declare proc_var_filter_list varchar(8000);


set proc_var_dw_modify_ts = (select cast(current_timestamp(0) as varchar (19)));
set proc_var_di_last_run_ts_no_look_back = (select extract_high_ts    from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_event_c_ds6_sp');
set proc_var_di_last_run_ts = (select extract_high_ts - cast( 24*60* lookback_days_dec as interval minute(4))   from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_event_c_ds6_sp');
set proc_var_ds6_base_max_dw_modify_ts =  (select max(dw_modify_ts) from edw_target.lh2_shift_state_b ); 


if extract_mode ='FULL'
   then 
    set proc_var_filter_list = ' shiftdate between '''|| start_shift_date ||''' and '''|| end_shift_date||''' and  cliid in  ( select cast(token as int)   from table (strtok_split_to_table(1,'''||filter_cliid||''', '','' ) returns (outkey integer,tokennum integer,token varchar(20) character set unicode)) as cliid_list  )' ;
   else 
                   if  (select cast( proc_var_ds6_base_max_dw_modify_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time)
                            then
                            set proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
                        end if;
   -- Sabarish S 2019-08-30 added as part of incremental load enhancement
   set proc_var_filter_list = ' ( shiftid, site_code) in 
(select shiftid,site_code from edw_target.lh2_shift_aux_b   where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_state_b   where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_reason_b   where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union 
select shiftid,site_code from edw_target.lh2_shift_eqmt_b   where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union
select shiftid,site_code from edw_target.lh2_shift_oper_b where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' )  ' ;
   end if;


--Step1: Delete the stage table

delete  edw_stage.lh2_status_event_ds6;

--Step2: insert the data set into stage table based on the filter condition
call dbc.sysexecsql (' insert into edw_stage.lh2_status_event_ds6 ( shiftindex,'  
  || 'shiftdate, ' 
  || 'site_code, ' 
  || 'cliid, ' 
  || 'ddbkey, ' 
  || 'eqmt, ' 
  || 'unit, ' 
  || 'operid, ' 
  || 'starttime, ' 
  || 'starttime_ts, ' 
  || 'endtime, ' 
  || 'endtime_ts, ' 
  || 'duration, ' 
  || 'reason, ' 
  || 'status, ' 
  || 'category, ' 
  || 'comments, ' 
  || 'vevent, ' 
  || 'reasonlink, ' 
  || 'work_order_number, ' 
  || 'district_code, ' 
  || 'eqmtid_orig, ' 
  || 'loc, ' 
  || 'region, ' 
  || 'system_version, ' 
  || 'dw_logical_delete_flag, ' 
  || 'dw_modify_ts, ' 
  || ' dw_load_ts )'
 || 'select  shiftindex,'  
  || ' shiftdate, ' 
  || ' site_code, ' 
  || ' cliid, ' 
  || ' ddbkey, ' 
  || ' eqmt, ' 
  || ' unit, ' 
  || ' operid, ' 
  || ' starttime, ' 
  || ' starttime_ts, ' 
  || ' endtime, ' 
  || ' endtime_ts, ' 
  || ' duration, ' 
  || ' reason, ' 
  || ' status, ' 
  || ' category, ' 
  || ' comments, ' 
  || ' vevent, ' 
  || ' reasonlink, ' 
  || ' work_order_number, ' 
  || ' district_code, ' 
  || ' eqmtid_orig, ' 
  || ' loc, ' 
  || ' region, ' 
   ||'  ''Dispatch 6'' as system_version,'
 ||'  ''N'' as dw_logical_delete_flag,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_modify_ts,'
||'  timestamp ''' || proc_var_dw_modify_ts  ||'''  as dw_load_ts from edw_etl_view.lh2_status_event_ds6_etl   '
||'  where  '|| proc_var_filter_list ||';'
);


--Step3: merge into target table
merge into edw_target.lh2_status_event_c as tgt 
using 
( 
select  
shiftindex ,  
 shiftdate ,  
 site_code ,  
 cliid ,  
 ddbkey ,  
 eqmt ,  
 unit ,  
 operid ,  
 starttime ,  
 starttime_ts , 
 endtime , 
 endtime_ts , 
 duration ,  
 reason ,  
 status ,  
 category ,  
 comments ,  
 vevent ,  
 reasonlink ,  
 work_order_number ,  
 district_code ,  
 eqmtid_orig ,  
 loc ,  
 region ,  
 system_version ,  
 dw_logical_delete_flag ,  
 dw_modify_ts ,  
 dw_load_ts   
from  edw_stage.lh2_status_event_ds6 
) as stg 
ON ( stg.shiftindex = tgt.shiftindex and 
stg.cliid = tgt.cliid and 
stg.ddbkey = tgt.ddbkey and
stg.starttime = tgt.starttime )

WHEN MATCHED THEN 
UPDATE SET 
shiftdate =  stg.shiftdate , 
 site_code =  stg.site_code , 
 eqmt =  stg.eqmt , 
 unit =  stg.unit , 
 operid =  stg.operid , 
 starttime_ts =  stg.starttime_ts , 
 endtime =  stg.endtime , 
 endtime_ts =  stg.endtime_ts , 
 duration =  stg.duration , 
 reason =  stg.reason , 
 status =  stg.status , 
 category =  stg.category , 
 comments =  stg.comments , 
 vevent =  stg.vevent , 
 reasonlink =  stg.reasonlink , 
 work_order_number =  stg.work_order_number , 
 district_code =  stg.district_code , 
 eqmtid_orig =  stg.eqmtid_orig , 
 loc =  stg.loc , 
 region =  stg.region , 
 system_version =  stg.system_version , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

WHEN NOT MATCHED THEN 
INSERT VALUES (
 stg.shiftindex , 
  stg.shiftdate , 
  stg.site_code , 
  stg.cliid , 
  stg.ddbkey , 
  stg.eqmt , 
  stg.unit , 
  stg.operid , 
  stg.starttime , 
  stg.starttime_ts , 
  stg.endtime , 
  stg.endtime_ts , 
  stg.duration , 
  stg.reason , 
  stg.status , 
  stg.category , 
  stg.comments , 
  stg.vevent , 
  stg.reasonlink , 
  stg.work_order_number , 
  stg.district_code , 
  stg.eqmtid_orig , 
  stg.loc , 
  stg.region , 
  stg.system_version , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--Step4: Capture the deleted rows
 
update edw_target.lh2_status_event_c  as tgt 
set dw_logical_delete_flag = 'Y' ,
       dw_modify_ts = cast(proc_var_dw_modify_ts as timestamp(0))
where 
tgt.dw_logical_delete_flag <>'Y'
and not exists
      (select 1
      from edw_stage.lh2_status_event_ds6 as stg 
      where stg.shiftindex = tgt.shiftindex 
      and stg.cliid = tgt.cliid 
      and stg.ddbkey = tgt.ddbkey 
	  and stg.starttime = tgt.starttime 
         )  
and  exists
     (
     select 'X'
     from edw_stage.lh2_status_event_ds6  stg1 
     where  stg1.shiftindex = tgt.shiftindex
     and stg1.cliid = tgt.cliid
     )   ; 

--Step5: Cleanup the target table 
delete   edw_target.lh2_status_event_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

--Step6: update the di job contorl entry ts base table 
update edw_target.di_job_control_entry_ts_base 
set dw_load_ts =  cast(proc_var_dw_modify_ts as timestamp(0)),
extract_low_ts =  proc_var_di_last_run_ts_no_look_back  ,
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_status_event_ds6), proc_var_di_last_run_ts_no_look_back )
where job_name ='job_lh2_status_event_c_ds6_sp';


end;
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_app_config_b
as
(
merge into edw_target.lh2_app_config_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.app_config_id ,  
	coalesce(stg.scope,' ') as scope ,  
	coalesce(stg.app_config_key,' ') as app_config_key ,  
	coalesce(stg.app_config_value,' ') as app_config_value ,  
	stg.app_config_timestamp ,  
	stg.recordstatus ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_app_config as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.app_config_id = tgt.app_config_id)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	scope =  stg.scope , 
	app_config_key =  stg.app_config_key , 
	app_config_value =  stg.app_config_value , 
	app_config_timestamp =  stg.app_config_timestamp , 
	recordstatus =  stg.recordstatus , 
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.app_config_id , 
	stg.scope , 
	stg.app_config_key , 
	stg.app_config_value , 
	stg.app_config_timestamp , 
	stg.recordstatus , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update edw_target.lh2_app_config_b  
from  edw_stage_016 .lh2_app_config stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_app_config_b.site_code and  
stg.app_config_id = edw_target.lh2_app_config_b.app_config_id and  
stg.change_type ='D'  ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro edw_stage_016.m_lh2_comm_log_b
as
(
merge into edw_target.lh2_comm_log_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.comm_log_id ,  
	stg.shiftid, 
	stg.shiftdate ,
	stg.shiftindex ,
	stg.comm_log_timestamp ,  
	stg.messagetype ,  
	coalesce(stg.eqmttype,' ') as eqmttype ,  
	coalesce(stg.eqmptid,' ') as eqmptid ,  
	coalesce(stg.ip,' ') as ip ,  
	stg.seconds ,  
	coalesce(stg.loc,' ') as loc ,  
	coalesce(stg.beacon,' ') as beacon ,  
	stg.received ,  
	stg.sent ,  
	coalesce(stg.messagebody,' ') as messagebody ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_comm_log as stg  
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.comm_log_id = tgt.comm_log_id  )

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	shiftid =  stg.shiftid , 
	shiftdate = 	stg.shiftdate ,
	shiftindex = stg.shiftindex ,
	comm_log_timestamp =  stg.comm_log_timestamp , 
	messagetype =  stg.messagetype , 
	eqmttype =  stg.eqmttype , 
	eqmptid =  stg.eqmptid , 
	ip =  stg.ip , 
	seconds =  stg.seconds , 
	loc =  stg.loc , 
	beacon =  stg.beacon , 
	received =  stg.received , 
	sent =  stg.sent , 
	messagebody =  stg.messagebody , 
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.comm_log_id , 
	stg.shiftid , 
	stg.shiftdate , 
	stg.shiftindex , 
	stg.comm_log_timestamp , 
	stg.messagetype , 
	stg.eqmttype , 
	stg.eqmptid , 
	stg.ip , 
	stg.seconds , 
	stg.loc , 
	stg.beacon , 
	stg.received , 
	stg.sent , 
	stg.messagebody , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_comm_log_b  
from 
( select 
stg.site_code , 
stg.comm_log_id , 
stg.comm_log_timestamp,  
stg.shiftid , 
case  
		when stg.change_type in('D')     then
                      case 
                      when stg.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    	else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts ,
stg.change_type
from edw_stage_016.lh2_comm_log stg 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_comm_log_b.site_code and  
stg.comm_log_id = edw_target.lh2_comm_log_b.comm_log_id  
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_config_equip_status_b
as
(
merge into edw_target.lh2_config_equip_status_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.statusenumtypeid ,  
	stg.statusindex ,  
	stg.timecategoryenumtypeid ,  
	stg.timecategoryindex ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_config_equip_status as stg 
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.statusenumtypeid = tgt.statusenumtypeid and 
stg.statusindex = tgt.statusindex)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	timecategoryenumtypeid =  stg.timecategoryenumtypeid , 
	timecategoryindex =  stg.timecategoryindex , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.statusenumtypeid , 
	stg.statusindex , 
	stg.timecategoryenumtypeid , 
	stg.timecategoryindex , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);

--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d


update edw_target.lh2_config_equip_status_b as tgt
set dw_logical_delete_flag ='Y',
    dw_modify_ts =  (select max(dw_modify_ts)  from edw_stage_016 .lh2_config_equip_status)
where 
tgt.dw_logical_delete_flag <>  'Y' 
and not exists 
      (
      select 'X'
      from edw_stage_016.lh2_config_equip_status as stg
      where  stg.site_code = tgt.site_code and  
      stg.statusenumtypeid = tgt.statusenumtypeid and 
      stg.statusindex = tgt.statusindex
      )
and  exists 
      (
      select 'X'
      from edw_stage_016.lh2_config_equip_status as stg
      where  stg.site_code = tgt.site_code 
      );

);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_config_material_b
as
(
merge into edw_target.lh2_config_material_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.materialenumtypeid ,  
	stg.materialidx ,  
	stg.materialgroupenumtypeid ,  
	stg.materialgroupidx ,  
	stg.materialdensity ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_config_material as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.materialenumtypeid = tgt.materialenumtypeid and 
stg.materialidx = tgt.materialidx)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	materialgroupenumtypeid =  stg.materialgroupenumtypeid , 
	materialgroupidx =  stg.materialgroupidx , 
	materialdensity =  stg.materialdensity , 
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.materialenumtypeid , 
	stg.materialidx , 
	stg.materialgroupenumtypeid , 
	stg.materialgroupidx , 
	stg.materialdensity , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_config_material_b  
from edw_stage_016 .lh2_config_material stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_config_material_b.site_code and  
stg.materialenumtypeid = edw_target.lh2_config_material_b.materialenumtypeid and  
stg.materialidx = edw_target.lh2_config_material_b.materialidx and  stg.change_type ='D'   ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_enum_b
as
(
merge into edw_target.lh2_enum_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.enum_id ,  
	stg.enumtypeid ,  
	stg.idx ,  
	coalesce(stg.description,' ') as description ,  
	coalesce(stg.abbreviation,' ') as abbreviation ,  
	stg.flags ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_enum as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.enum_id = tgt.enum_id)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	enumtypeid =  stg.enumtypeid , 
	idx =  stg.idx , 
	description =  stg.description , 
	abbreviation =  stg.abbreviation , 
	flags =  stg.flags , 
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.enum_id , 
	stg.enumtypeid , 
	stg.idx , 
	stg.description , 
	stg.abbreviation , 
	stg.flags , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_enum_b  
from 
edw_stage_016 .lh2_enum as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_enum_b.site_code and  
stg.enum_id = edw_target.lh2_enum_b.enum_id and 
stg.change_type ='D'   ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_enum_type_b
as
(
merge into edw_target.lh2_enum_type_b as tgt 
using 
( 
	select  
	orig_src_id ,  
	site_code ,  
	enum_type_id ,  
	coalesce(enum_type_name,' ') as enum_type_name ,  
	dw_logical_delete_flag ,  
	dw_modify_ts ,  
	dw_load_ts   
	from  edw_stage_016.lh2_enum_type 
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.enum_type_id = tgt.enum_type_id)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	enum_type_name =  stg.enum_type_name , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.enum_type_id , 
	stg.enum_type_name , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);

update edw_target.lh2_enum_type_b  tgt
set
dw_logical_delete_flag =  'Y' , 
dw_modify_ts =  (select max(dw_modify_ts) from edw_stage_016.lh2_enum_type)
where 
tgt.dw_logical_delete_flag <>  'Y' 
and not exists 
      (select 'X'  from edw_stage_016.lh2_enum_type stg 
      where stg. site_code = tgt.site_code
      and stg.enum_type_id = tgt.enum_type_id)       
and  exists 
      (select 'X'  from edw_stage_016.lh2_enum_type stg 
      where stg. site_code = tgt.site_code
      ) ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_exception_log_b
as
( 
merge into edw_target.lh2_exception_log_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.exception_log_id ,  
	stg.shiftid as shiftid ,  
	stg.shiftdate as shiftdate ,  
	stg.shiftindex  as shiftindex , 
	stg.exception_log_timestamp ,  
	coalesce(stg.messagebody,' ') as messagebody ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_exception_log as stg
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.exception_log_id = tgt.exception_log_id)

when matched then 
update set 
orig_src_id =  stg.orig_src_id , 
shiftid = stg.shiftid,
shiftdate = stg.shiftdate,
shiftindex = stg.shiftindex,
exception_log_timestamp =  stg.exception_log_timestamp , 
messagebody =  stg.messagebody , 
src_change_id =  stg.src_change_id , 
dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.exception_log_id , 
	stg.shiftid,
	stg.shiftdate,
	stg.shiftindex,
	stg.exception_log_timestamp , 
	stg.messagebody , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d


update  edw_target.lh2_exception_log_b  
from 
( select 
stg.site_code , 
stg.exception_log_id ,   
CASE  
		WHEN stg.change_type IN('D')     THEN
                      CASE 
                      WHEN stg.shiftdate<(CURRENT_DATE-170) THEN 'A' 
                      ELSE 'Y' ---handles  regular delete 
                      END               
    	ELSE 'U'---- for change type not in (i,u,d)
END as dw_logical_delete_flag,
stg.dw_modify_ts ,
stg.change_type
from edw_stage_016 .lh2_exception_log stg 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
 where 
stg.site_code = edw_target.lh2_exception_log_b.site_code and  
 stg.exception_log_id = edw_target.lh2_exception_log_b.exception_log_id and 
 stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create macro edw_stage_016.m_lh2_pit_loc_b
as
(
merge into edw_target.lh2_pit_loc_b as tgt 
using 
( 
	select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.pit_loc_id ,  
	stg.dbprevious ,  
	stg.dbnext ,  
	stg.dbversion ,  
	coalesce(stg.pit_dbname,' ') as pit_dbname ,  
	stg.dbkey ,  
	coalesce(stg.fieldid,' ') as fieldid ,  
	stg.fieldpit ,  
	stg.fieldregion ,  
	stg.fieldblendrec ,  
	stg.fieldpath ,  
	stg.fieldbean ,  
	stg.fieldinvbean ,  
	stg.fieldhaul ,  
	stg.fieldore ,  
	stg.fielddumpfeed ,  
	stg.fielddumpcapy ,  
	stg.fieldbinsize ,  
	stg.fieldxloc ,  
	stg.fieldyloc ,  
	stg.fieldpathix ,  
	stg.fieldtimedump ,  
	stg.fieldzloc ,  
	stg.fieldsignid ,  
	stg.fieldunit ,  
	stg.fieldload ,  
	stg.fieldistiedown ,  
	stg.fieldstatus ,  
	stg.fieldlinestat ,  
	stg.fieldspillage ,  
	stg.fieldsignpost ,  
	stg.fieldshoptype ,  
	stg.fielddumpqueue ,  
	stg.fieldpctcapy ,  
	stg.fieldbays ,  
	stg.fieldnopenalty ,  
	stg.fieldtimelast ,  
	stg.fieldradius ,  
	stg.fieldgpstype ,  
	stg.fieldreason ,  
	stg.fieldivtrec ,  
	stg.fieldtdset ,  
	stg.fieldprior ,  
	stg.fieldavailbays ,  
	stg.fieldparkqueue ,  
	stg.fieldbcntime ,  
	stg.fieldtagdate ,  
	coalesce(stg.fieldtageqmt,' ') as fieldtageqmt ,  
	stg.fieldtrucksenroute ,  
	stg.fieldlastassign ,  
	stg.fieldlastarrive ,  
	stg.fieldspeedtrap ,  
	stg.fieldlvsproxcnt ,  
	stg.fieldlaststattime ,  
	stg.fieldignunexarr ,  
	coalesce(stg.fieldmetadata,' ') as fieldmetadata ,  
	stg.fielddisablearrchk ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
	from   edw_stage_016.lh2_pit_loc as stg 
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.fieldid = tgt.fieldid)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	pit_loc_id = stg.pit_loc_id ,
	dbprevious =  stg.dbprevious , 
	dbnext =  stg.dbnext , 
	dbversion =  stg.dbversion , 
	pit_dbname =  stg.pit_dbname , 
	dbkey =  stg.dbkey , 
	fieldpit =  stg.fieldpit , 
	fieldregion =  stg.fieldregion , 
	fieldblendrec =  stg.fieldblendrec , 
	fieldpath =  stg.fieldpath , 
	fieldbean =  stg.fieldbean , 
	fieldinvbean =  stg.fieldinvbean , 
	fieldhaul =  stg.fieldhaul , 
	fieldore =  stg.fieldore , 
	fielddumpfeed =  stg.fielddumpfeed , 
	fielddumpcapy =  stg.fielddumpcapy , 
	fieldbinsize =  stg.fieldbinsize , 
	fieldxloc =  stg.fieldxloc , 
	fieldyloc =  stg.fieldyloc , 
	fieldpathix =  stg.fieldpathix , 
	fieldtimedump =  stg.fieldtimedump , 
	fieldzloc =  stg.fieldzloc , 
	fieldsignid =  stg.fieldsignid , 
	fieldunit =  stg.fieldunit , 
	fieldload =  stg.fieldload , 
	fieldistiedown =  stg.fieldistiedown , 
	fieldstatus =  stg.fieldstatus , 
	fieldlinestat =  stg.fieldlinestat , 
	fieldspillage =  stg.fieldspillage , 
	fieldsignpost =  stg.fieldsignpost , 
	fieldshoptype =  stg.fieldshoptype , 
	fielddumpqueue =  stg.fielddumpqueue , 
	fieldpctcapy =  stg.fieldpctcapy , 
	fieldbays =  stg.fieldbays , 
	fieldnopenalty =  stg.fieldnopenalty , 
	fieldtimelast =  stg.fieldtimelast , 
	fieldradius =  stg.fieldradius , 
	fieldgpstype =  stg.fieldgpstype , 
	fieldreason =  stg.fieldreason , 
	fieldivtrec =  stg.fieldivtrec , 
	fieldtdset =  stg.fieldtdset , 
	fieldprior =  stg.fieldprior , 
	fieldavailbays =  stg.fieldavailbays , 
	fieldparkqueue =  stg.fieldparkqueue , 
	fieldbcntime =  stg.fieldbcntime , 
	fieldtagdate =  stg.fieldtagdate , 
	fieldtageqmt =  stg.fieldtageqmt , 
	fieldtrucksenroute =  stg.fieldtrucksenroute , 
	fieldlastassign =  stg.fieldlastassign , 
	fieldlastarrive =  stg.fieldlastarrive , 
	fieldspeedtrap =  stg.fieldspeedtrap , 
	fieldlvsproxcnt =  stg.fieldlvsproxcnt , 
	fieldlaststattime =  stg.fieldlaststattime , 
	fieldignunexarr =  stg.fieldignunexarr , 
	fieldmetadata =  stg.fieldmetadata , 
	fielddisablearrchk =  stg.fielddisablearrchk , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.pit_loc_id , 
	stg.dbprevious , 
	stg.dbnext , 
	stg.dbversion , 
	stg.pit_dbname , 
	stg.dbkey , 
	stg.fieldid , 
	stg.fieldpit , 
	stg.fieldregion , 
	stg.fieldblendrec , 
	stg.fieldpath , 
	stg.fieldbean , 
	stg.fieldinvbean , 
	stg.fieldhaul , 
	stg.fieldore , 
	stg.fielddumpfeed , 
	stg.fielddumpcapy , 
	stg.fieldbinsize , 
	stg.fieldxloc , 
	stg.fieldyloc , 
	stg.fieldpathix , 
	stg.fieldtimedump , 
	stg.fieldzloc , 
	stg.fieldsignid , 
	stg.fieldunit , 
	stg.fieldload , 
	stg.fieldistiedown , 
	stg.fieldstatus , 
	stg.fieldlinestat , 
	stg.fieldspillage , 
	stg.fieldsignpost , 
	stg.fieldshoptype , 
	stg.fielddumpqueue , 
	stg.fieldpctcapy , 
	stg.fieldbays , 
	stg.fieldnopenalty , 
	stg.fieldtimelast , 
	stg.fieldradius , 
	stg.fieldgpstype , 
	stg.fieldreason , 
	stg.fieldivtrec , 
	stg.fieldtdset , 
	stg.fieldprior , 
	stg.fieldavailbays , 
	stg.fieldparkqueue , 
	stg.fieldbcntime , 
	stg.fieldtagdate , 
	stg.fieldtageqmt , 
	stg.fieldtrucksenroute , 
	stg.fieldlastassign , 
	stg.fieldlastarrive , 
	stg.fieldspeedtrap , 
	stg.fieldlvsproxcnt , 
	stg.fieldlaststattime , 
	stg.fieldignunexarr , 
	stg.fieldmetadata , 
	stg.fielddisablearrchk , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)

update edw_target.lh2_pit_loc_b as tgt
set dw_logical_delete_flag ='Y',
    	dw_modify_ts =  (select max(dw_modify_ts)  from edw_stage_016 .lh2_pit_loc)
where 
tgt.dw_logical_delete_flag <>  'Y' 
and not exists 
      (
      select 1
      from edw_stage_016.lh2_pit_loc as stg
      where  stg.site_code = tgt.site_code and  
      coalesce(stg.fieldid,' ') = tgt.fieldid
      )
and  exists 
     (
     select 1
     from edw_stage_016.lh2_pit_loc as stg
     where  stg.site_code = tgt.site_code
     );
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_pit_reason_b
as
(
merge into edw_target.lh2_pit_reason_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.status ,  
 stg.pit_reason_id ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 coalesce(stg.pit_dbname,' ') as pit_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fielddelaytime ,  
 stg.fieldcategory ,  
 coalesce(stg.fieldname,' ') as fieldname ,  
 stg.fieldmainttime ,  
 stg.fieldauto ,  
 stg.fielddfct ,  
 stg.fieldgcincl ,  
 coalesce(stg.fieldaltname,' ') as fieldaltname ,  
 stg.fieldexpectdur ,  
 stg.fieldtask ,  
 stg.fieldlrincl ,  
 coalesce(stg.fieldicon,' ') as fieldicon ,  
 stg.fieldftype ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_pit_reason as stg 
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.status = tgt.status and 
stg.fieldid = tgt.fieldid)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	pit_reason_id =  stg.pit_reason_id , 
	dbprevious =  stg.dbprevious , 
	dbnext =  stg.dbnext , 
	dbversion =  stg.dbversion , 
	pit_dbname =  stg.pit_dbname , 
	dbkey =  stg.dbkey , 
	fielddelaytime =  stg.fielddelaytime , 
	fieldcategory =  stg.fieldcategory , 
	fieldname =  stg.fieldname , 
	fieldmainttime =  stg.fieldmainttime , 
	fieldauto =  stg.fieldauto , 
	fielddfct =  stg.fielddfct , 
	fieldgcincl =  stg.fieldgcincl , 
	fieldaltname =  stg.fieldaltname , 
	fieldexpectdur =  stg.fieldexpectdur , 
	fieldtask =  stg.fieldtask , 
	fieldlrincl =  stg.fieldlrincl , 
	fieldicon =  stg.fieldicon , 
	fieldftype =  stg.fieldftype , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.status , 
	stg.pit_reason_id , 
	stg.dbprevious , 
	stg.dbnext , 
	stg.dbversion , 
	stg.pit_dbname , 
	stg.dbkey , 
	stg.fieldid , 
	stg.fielddelaytime , 
	stg.fieldcategory , 
	stg.fieldname , 
	stg.fieldmainttime , 
	stg.fieldauto , 
	stg.fielddfct , 
	stg.fieldgcincl , 
	stg.fieldaltname , 
	stg.fieldexpectdur , 
	stg.fieldtask , 
	stg.fieldlrincl , 
	stg.fieldicon , 
	stg.fieldftype , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d

update edw_target.lh2_pit_reason_b  as tgt
set dw_logical_delete_flag ='Y',
  	  dw_modify_ts =  (select max(dw_modify_ts)  from edw_stage_016 .lh2_pit_reason)
where 
tgt.dw_logical_delete_flag <>  'Y' 
and not exists 
      (
      select 'X'
      from edw_stage_016.lh2_pit_reason as stg
      where  stg.site_code = tgt.site_code and  
      stg.status = tgt.status and 
      stg.fieldid = tgt.fieldid
      )
and  exists 
     (
     select 'X'
     from edw_stage_016.lh2_pit_reason as stg
     where  stg.site_code = tgt.site_code 
     );
 
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_pit_travel_b
as
(
merge into edw_target.lh2_pit_travel_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.pit_travel_id ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 coalesce(stg.pit_dbname,' ') as pit_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldlocstart ,  
 stg.fieldlocend ,  
 stg.fielddist ,  
 stg.fieldtimeempty ,  
 stg.fieldtimeloaded ,  
 stg.fieldclosed ,  
 stg.fieldfactor ,  
 coalesce(stg.fieldstreet,' ') as fieldstreet ,  
 stg.fieldresist ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_pit_travel as stg 
) as stg 
on ( stg.site_code = tgt.site_code  
and stg.fieldlocstart = tgt.fieldlocstart
and stg.fieldlocend = tgt.fieldlocend)

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 pit_travel_id = stg.pit_travel_id,
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 pit_dbname =  stg.pit_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fielddist =  stg.fielddist , 
 fieldtimeempty =  stg.fieldtimeempty , 
 fieldtimeloaded =  stg.fieldtimeloaded , 
 fieldclosed =  stg.fieldclosed , 
 fieldfactor =  stg.fieldfactor , 
 fieldstreet =  stg.fieldstreet , 
 fieldresist =  stg.fieldresist , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.pit_travel_id , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.pit_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldlocstart , 
  stg.fieldlocend , 
  stg.fielddist , 
  stg.fieldtimeempty , 
  stg.fieldtimeloaded , 
  stg.fieldclosed , 
  stg.fieldfactor , 
  stg.fieldstreet , 
  stg.fieldresist , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
  
--  step 2 ( for  deleted  records)

 update edw_target.lh2_pit_travel_b as tgt
set dw_logical_delete_flag ='Y',
    	dw_modify_ts =  (select max(dw_modify_ts)  from edw_stage_016 .lh2_pit_travel)
where 
tgt.dw_logical_delete_flag <>  'Y' 
and not exists 
        (
        select 'X'
        from edw_stage_016.lh2_pit_travel as stg
        where  stg.site_code = tgt.site_code and  
        stg.fieldlocstart = tgt.fieldlocstart and
        stg.fieldlocend = tgt.fieldlocend
        ) 
and  exists 
        (
        select 'X'
        from edw_stage_016.lh2_pit_travel as stg
        where  stg.site_code = tgt.site_code 
        ) ;        
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_pit_travel_x_graph_array_b
as
(
merge into edw_target.lh2_pit_travel_x_graph_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.fieldlocstart ,  
	stg.fieldlocend ,  
	stg.travel_x_graph_array_id ,  
	stg.travel_x_graph_array_index ,  
	stg.travel_x_graph_array_value ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_pit_travel_x_graph_array as stg 
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.fieldlocstart = tgt.fieldlocstart and 
stg.fieldlocend = tgt.fieldlocend and 
stg.travel_x_graph_array_index = tgt.travel_x_graph_array_index)

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 travel_x_graph_array_id = stg.travel_x_graph_array_id ,  
 travel_x_graph_array_value =  stg.travel_x_graph_array_value , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.fieldlocstart , 
  stg.fieldlocend , 
  stg.travel_x_graph_array_id , 
  stg.travel_x_graph_array_index , 
  stg.travel_x_graph_array_value , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
  
--  step 2 ( for  deleted  records)

update edw_target.lh2_pit_travel_x_graph_array_b as tgt
set dw_logical_delete_flag ='Y',
    dw_modify_ts =  (select max(dw_modify_ts)  from edw_stage_016 .lh2_pit_travel_x_graph_array)
where 
tgt.dw_logical_delete_flag <>  'Y' 
and not exists 
     (
     select 'X'
     from edw_stage_016.lh2_pit_travel_x_graph_array as stg
     where  stg.site_code = tgt.site_code and  
     stg.fieldlocstart = tgt.fieldlocstart and 
     stg.fieldlocend = tgt.fieldlocend and 
	 stg.travel_x_graph_array_index = tgt.travel_x_graph_array_index
     )
and  exists 
     (
     select 'X'
     from edw_stage_016.lh2_pit_travel_x_graph_array as stg
     where  stg.site_code = tgt.site_code 
     );
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_pit_travel_y_graph_array_b
as
(
merge into edw_target.lh2_pit_travel_y_graph_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.fieldlocstart ,  
	stg.fieldlocend ,  
	stg.travel_y_graph_array_id ,  
	stg.travel_y_graph_array_index ,  
	stg.travel_y_graph_array_value ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_pit_travel_y_graph_array as stg 
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.fieldlocstart = tgt.fieldlocstart and 
stg.fieldlocend = tgt.fieldlocend and 
stg.travel_y_graph_array_index = tgt.travel_y_graph_array_index )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 travel_y_graph_array_id = stg.travel_y_graph_array_id ,  
 travel_y_graph_array_value =  stg.travel_y_graph_array_value , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.fieldlocstart , 
  stg.fieldlocend , 
  stg.travel_y_graph_array_id , 
  stg.travel_y_graph_array_index , 
  stg.travel_y_graph_array_value , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);

--  step 2 ( for  deleted  records)

update edw_target.lh2_pit_travel_y_graph_array_b as tgt
set dw_logical_delete_flag ='Y',
   	 dw_modify_ts =  (select max(dw_modify_ts)  from edw_stage_016 .lh2_pit_travel_y_graph_array)
where 
tgt.dw_logical_delete_flag <>  'Y' 
and not exists 
      (
      select 'X'
      from edw_stage_016.lh2_pit_travel_y_graph_array as stg
		where  stg.site_code = tgt.site_code and  
		stg.fieldlocstart = tgt.fieldlocstart and 
		stg.fieldlocend = tgt.fieldlocend and 
		stg.travel_y_graph_array_index = tgt.travel_y_graph_array_index 
      )
and  exists 
     (
     select 'X'
     from edw_stage_016.lh2_pit_travel_y_graph_array as stg
     where  stg.site_code = tgt.site_code
     );  
);
--------------------------------------------------------------------------------

"Request Text"
replace macro  edw_stage_016.m_lh2_shift_aux_b
as
(
merge into edw_target.lh2_shift_aux_b as tgt 
using 
( 
select  
stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_aux_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldpit ,  
 stg.fieldregionlock ,  
 stg.fieldreason ,  
 stg.fieldunit ,  
 stg.fieldstatus ,  
 stg.fieldeqmttype ,  
 coalesce(stg.fieldcomment,' ') as fieldcomment ,  
 stg.fieldreasonrec ,  
 stg.fieldoper ,  
 stg.fieldaudit ,  
 stg.fieldsubcode ,  
 stg.fieldsubcode2 ,  
 coalesce(stg.fieldsituation,' ') as fieldsituation ,  
 stg.fielduser ,  
 stg.fieldmaintstart ,  
 stg.fieldmaintpropose ,  
 stg.fieldwarranty ,  
 stg.fieldenghr ,  
 stg.fieldenghrtime ,  
 (cast (date '1970-01-01' +  cast (floor( cast ( fieldenghrtime  as float) / 86400) as integer) as timestamp (0)) +
 (  (  ( cast ( fieldenghrtime   as number) mod cast (86400 as number) )) * interval '00:00:01' hour to second))  as fieldenghrtime_ts , 
 coalesce(stg.fieldpmid,' ') as fieldpmid ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_aux as stg  
left outer join pddw.lh2_shift_info shift_info
     on (stg.site_code = shift_info.site_code and 
     stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_aux_id = tgt.shift_aux_id 
and stg.shiftid = tgt.shiftid )

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	shiftdate =  stg.shiftdate , 
	dbprevious =  stg.dbprevious , 
	dbnext =  stg.dbnext , 
	dbversion =  stg.dbversion , 
	shift_dbname =  stg.shift_dbname , 
	dbkey =  stg.dbkey , 
	fieldid =  stg.fieldid , 
	fieldpit =  stg.fieldpit , 
	fieldregionlock =  stg.fieldregionlock , 
	fieldreason =  stg.fieldreason , 
	fieldunit =  stg.fieldunit , 
	fieldstatus =  stg.fieldstatus , 
	fieldeqmttype =  stg.fieldeqmttype , 
	fieldcomment =  stg.fieldcomment , 
	fieldreasonrec =  stg.fieldreasonrec , 
	fieldoper =  stg.fieldoper , 
	fieldaudit =  stg.fieldaudit , 
	fieldsubcode =  stg.fieldsubcode , 
	fieldsubcode2 =  stg.fieldsubcode2 , 
	fieldsituation =  stg.fieldsituation , 
	fielduser =  stg.fielduser , 
	fieldmaintstart =  stg.fieldmaintstart , 
	fieldmaintpropose =  stg.fieldmaintpropose , 
	fieldwarranty =  stg.fieldwarranty , 
	fieldenghr =  stg.fieldenghr , 
	fieldenghrtime =  stg.fieldenghrtime , 
	fieldenghrtime_ts =  stg.fieldenghrtime_ts , 
	fieldpmid =  stg.fieldpmid , 
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.shift_aux_id , 
	stg.shiftdate , 
	stg.dbprevious , 
	stg.dbnext , 
	stg.dbversion , 
	stg.shiftid , 
	stg.shift_dbname , 
	stg.dbkey , 
	stg.fieldid , 
	stg.fieldpit , 
	stg.fieldregionlock , 
	stg.fieldreason , 
	stg.fieldunit , 
	stg.fieldstatus , 
	stg.fieldeqmttype , 
	stg.fieldcomment , 
	stg.fieldreasonrec , 
	stg.fieldoper , 
	stg.fieldaudit , 
	stg.fieldsubcode , 
	stg.fieldsubcode2 , 
	stg.fieldsituation , 
	stg.fielduser , 
	stg.fieldmaintstart , 
	stg.fieldmaintpropose , 
	stg.fieldwarranty , 
	stg.fieldenghr , 
	stg.fieldenghrtime , 
	stg.fieldenghrtime_ts , 
	stg.fieldpmid , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_aux_b  
from 
( select 
stg.site_code , 
stg.shift_aux_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    		else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type
from edw_stage_016.lh2_shift_aux stg 
left outer join pddw.lh2_shift_info shift_info
	on (stg.site_code = shift_info.site_code and 
	cast(substr(trim(stg.shift_aux_id),1,9) as integer) = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_aux_b.site_code and  
stg.shift_aux_id = edw_target.lh2_shift_aux_b.shift_aux_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_dump_b
as
(
merge into edw_target.lh2_shift_dump_b as tgt 
using 
( 
select  	
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_dump_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldtruck ,  
 stg.fieldloc ,  
 stg.fieldgrade ,  
 stg.fieldloadrec ,  
 stg.fieldexcav ,  
 stg.fieldblast ,  
 stg.fieldbay ,  
 stg.fieldtons ,  
 stg.fieldtimearrive ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimearrive / 60 as  interval minute(4)) + cast ( (stg.fieldtimearrive  mod 60 ) as interval second(4,3))  as fieldtimearrive_ts ,  
 stg.fieldtimedump ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimedump / 60 as  interval minute(4)) + cast ( (stg.fieldtimedump  mod 60 ) as interval second(4,3))  as fieldtimedump_ts ,  
 stg.fieldtimeempty ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimeempty / 60 as  interval minute(4)) + cast ( (stg.fieldtimeempty  mod 60 ) as interval second(4,3))  as fieldtimeempty_ts ,  
 stg.fieldtimedigest ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimedigest / 60 as  interval minute(4)) + cast ( (stg.fieldtimedigest  mod 60 ) as interval second(4,3))  as fieldtimedigest_ts ,  
 stg.fieldcalctravtime ,  
 shift_info.shiftstartdatetime + cast (stg.fieldcalctravtime / 60 as  interval minute(4)) + cast ( (stg.fieldcalctravtime  mod 60 ) as interval second(4,3))  as fieldcalctravtime_ts ,  
 stg.fieldload ,  
 stg.fieldextraload ,  
 stg.fielddist ,  
 stg.fieldefh ,  
 stg.fieldloadtype ,  
 stg.fieldtoper ,  
 stg.fieldeoper ,  
 coalesce(stg.fieldorigasn,' ') as fieldorigasn ,  
 coalesce(stg.fieldreasnby,' ') as fieldreasnby ,  
 stg.fieldpathtravtime ,  
 coalesce(stg.fieldlocactlc,' ') as fieldlocactlc ,  
 stg.fieldlocacttp ,  
 coalesce(stg.fieldlocactrl,' ') as fieldlocactrl ,  
 stg.fieldaudit ,  
 stg.fieldgpsxtkd ,  
 stg.fieldgpsytkd ,  
 stg.fieldgpsstat ,  
 stg.fieldgpshead ,  
 stg.fieldgpsvel ,  
 stg.fieldlsizetons ,  
 coalesce(stg.fieldlsizeid,' ') as fieldlsizeid ,  
 stg.fieldlsizeversion ,  
 stg.fieldlsizedb ,  
 stg.fieldfactapply ,  
 coalesce(stg.fielddlock,' ') as fielddlock ,  
 coalesce(stg.fieldelock,' ') as fieldelock ,  
 coalesce(stg.fieldedlock,' ') as fieldedlock ,  
 coalesce(stg.fieldrlock,' ') as fieldrlock ,  
 stg.fieldreconstat ,  
 stg.fieldtimearrivemobile ,  
 stg.fieldtimedumpmobile ,  
 stg.fieldtimeemptymobile ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_dump as stg  
left outer join pddw.lh2_shift_info shift_info
     on (stg.site_code = shift_info.site_code and 
     stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code 
and stg.shift_dump_id = tgt.shift_dump_id 
and stg.shiftdate =  tgt.shiftdate 
and stg.shiftid = tgt.shiftid )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldtruck =  stg.fieldtruck , 
 fieldloc =  stg.fieldloc , 
 fieldgrade =  stg.fieldgrade , 
 fieldloadrec =  stg.fieldloadrec , 
 fieldexcav =  stg.fieldexcav , 
 fieldblast =  stg.fieldblast , 
 fieldbay =  stg.fieldbay , 
 fieldtons =  stg.fieldtons , 
 fieldtimearrive =  stg.fieldtimearrive , 
 fieldtimearrive_ts =  stg.fieldtimearrive_ts , 
 fieldtimedump =  stg.fieldtimedump , 
 fieldtimedump_ts =  stg.fieldtimedump_ts , 
 fieldtimeempty =  stg.fieldtimeempty , 
 fieldtimeempty_ts =  stg.fieldtimeempty_ts , 
 fieldtimedigest =  stg.fieldtimedigest , 
 fieldtimedigest_ts =  stg.fieldtimedigest_ts , 
 fieldcalctravtime =  stg.fieldcalctravtime , 
 fieldcalctravtime_ts =  stg.fieldcalctravtime_ts , 
 fieldload =  stg.fieldload , 
 fieldextraload =  stg.fieldextraload , 
 fielddist =  stg.fielddist , 
 fieldefh =  stg.fieldefh , 
 fieldloadtype =  stg.fieldloadtype , 
 fieldtoper =  stg.fieldtoper , 
 fieldeoper =  stg.fieldeoper , 
 fieldorigasn =  stg.fieldorigasn , 
 fieldreasnby =  stg.fieldreasnby , 
 fieldpathtravtime =  stg.fieldpathtravtime , 
 fieldlocactlc =  stg.fieldlocactlc , 
 fieldlocacttp =  stg.fieldlocacttp , 
 fieldlocactrl =  stg.fieldlocactrl , 
 fieldaudit =  stg.fieldaudit , 
 fieldgpsxtkd =  stg.fieldgpsxtkd , 
 fieldgpsytkd =  stg.fieldgpsytkd , 
 fieldgpsstat =  stg.fieldgpsstat , 
 fieldgpshead =  stg.fieldgpshead , 
 fieldgpsvel =  stg.fieldgpsvel , 
 fieldlsizetons =  stg.fieldlsizetons , 
 fieldlsizeid =  stg.fieldlsizeid , 
 fieldlsizeversion =  stg.fieldlsizeversion , 
 fieldlsizedb =  stg.fieldlsizedb , 
 fieldfactapply =  stg.fieldfactapply , 
 fielddlock =  stg.fielddlock , 
 fieldelock =  stg.fieldelock , 
 fieldedlock =  stg.fieldedlock , 
 fieldrlock =  stg.fieldrlock , 
 fieldreconstat =  stg.fieldreconstat , 
 fieldtimearrivemobile =  stg.fieldtimearrivemobile , 
 fieldtimedumpmobile =  stg.fieldtimedumpmobile , 
 fieldtimeemptymobile =  stg.fieldtimeemptymobile , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_dump_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldtruck , 
  stg.fieldloc , 
  stg.fieldgrade , 
  stg.fieldloadrec , 
  stg.fieldexcav , 
  stg.fieldblast , 
  stg.fieldbay , 
  stg.fieldtons , 
  stg.fieldtimearrive , 
  stg.fieldtimearrive_ts , 
  stg.fieldtimedump , 
  stg.fieldtimedump_ts , 
  stg.fieldtimeempty , 
  stg.fieldtimeempty_ts , 
  stg.fieldtimedigest , 
  stg.fieldtimedigest_ts , 
  stg.fieldcalctravtime , 
  stg.fieldcalctravtime_ts , 
  stg.fieldload , 
  stg.fieldextraload , 
  stg.fielddist , 
  stg.fieldefh , 
  stg.fieldloadtype , 
  stg.fieldtoper , 
  stg.fieldeoper , 
  stg.fieldorigasn , 
  stg.fieldreasnby , 
  stg.fieldpathtravtime , 
  stg.fieldlocactlc , 
  stg.fieldlocacttp , 
  stg.fieldlocactrl , 
  stg.fieldaudit , 
  stg.fieldgpsxtkd , 
  stg.fieldgpsytkd , 
  stg.fieldgpsstat , 
  stg.fieldgpshead , 
  stg.fieldgpsvel , 
  stg.fieldlsizetons , 
  stg.fieldlsizeid , 
  stg.fieldlsizeversion , 
  stg.fieldlsizedb , 
  stg.fieldfactapply , 
  stg.fielddlock , 
  stg.fieldelock , 
  stg.fieldedlock , 
  stg.fieldrlock , 
  stg.fieldreconstat , 
  stg.fieldtimearrivemobile , 
  stg.fieldtimedumpmobile , 
  stg.fieldtimeemptymobile , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_dump_b  
from 
( select stg.site_code ,
stg.shift_dump_id ,   
case  when stg.change_type in('D')     then
                            case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type
from edw_stage_016.lh2_shift_dump stg 
left outer join pddw.lh2_shift_info shift_info
     on (stg.site_code = shift_info.site_code and 
    cast(substr(trim(stg.shift_dump_id),1,9) as integer) = shift_info.shiftid) ) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
 where 
stg.site_code = edw_target.lh2_shift_dump_b.site_code and  
 stg.shift_dump_id = edw_target.lh2_shift_dump_b.shift_dump_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_dump_lift_array_b
as
( 
merge into edw_target.lh2_shift_dump_lift_array_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.dump_lift_array_id ,  
 stg.dump_lift_array_index ,  
 stg.shiftid ,
 stg.dump_lift_array_value , 
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_dump_lift_array as stg    
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.dump_lift_array_id = tgt.dump_lift_array_id and 
stg.dump_lift_array_index = tgt.dump_lift_array_index)

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftid = stg.shiftid ,
 dump_lift_array_value =  stg.dump_lift_array_value ,
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.dump_lift_array_id , 
  stg.dump_lift_array_index , 
  stg.shiftid ,
  stg.dump_lift_array_value , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_dump_lift_array_b  
from 
( select stg.site_code , 
stg.dump_lift_array_id , 
stg.dump_lift_array_index ,  
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_shift_dump_lift_array stg 
left outer join pddw. lh2_shift_info as shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid= shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_dump_lift_array_b.site_code and  
stg.dump_lift_array_id = edw_target.lh2_shift_dump_lift_array_b.dump_lift_array_id and  
stg.dump_lift_array_index = edw_target.lh2_shift_dump_lift_array_b.dump_lift_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_dump_lift_dist_array_b
as
(
merge into edw_target.lh2_shift_dump_lift_dist_array_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.dump_lift_dist_array_id ,  
 stg.dump_lift_dist_array_index ,  
 stg.shiftid ,
  stg.dump_lift_dist_array_value , 
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_dump_lift_dist_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.dump_lift_dist_array_id = tgt.dump_lift_dist_array_id and 
stg.dump_lift_dist_array_index = tgt.dump_lift_dist_array_index)

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 dump_lift_dist_array_value =  stg.dump_lift_dist_array_value ,
 shiftid = stg.shiftid ,
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.dump_lift_dist_array_id , 
  stg.dump_lift_dist_array_index , 
  stg.shiftid,
  stg.dump_lift_dist_array_value , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_dump_lift_dist_array_b  
from 
( select stg.site_code , 
stg.dump_lift_dist_array_id , 
stg.dump_lift_dist_array_index ,  
case  when stg.change_type in('D')     then
                       case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
          else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,stg.dw_modify_ts,  stg.change_type 
from edw_stage_016 .lh2_shift_dump_lift_dist_array stg 
left outer join pddw.lh2_shift_info as shift_info 
on (stg.site_code = shift_info.site_code and 
stg.shiftid= shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_dump_lift_dist_array_b.site_code and  
stg.dump_lift_dist_array_id = edw_target.lh2_shift_dump_lift_dist_array_b.dump_lift_dist_array_id and  
stg.dump_lift_dist_array_index = edw_target.lh2_shift_dump_lift_dist_array_b.dump_lift_dist_array_index and
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_dump_tbars_array_b
as
(
merge into edw_target.lh2_shift_dump_tbars_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.dump_tbars_array_id ,  
	stg.dump_tbars_array_index ,  
	stg.shiftid ,
	coalesce(stg.dump_tbars_array_value,' ') as dump_tbars_array_value ,
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_shift_dump_tbars_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.dump_tbars_array_id = tgt.dump_tbars_array_id and 
stg.dump_tbars_array_index = tgt.dump_tbars_array_index)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	dump_tbars_array_value =  stg.dump_tbars_array_value ,
	shiftid = stg.shiftid ,
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.dump_tbars_array_id , 
	stg.dump_tbars_array_index , 
	stg.shiftid ,
	stg.dump_tbars_array_value , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_dump_tbars_array_b  
from 
( select stg.site_code , 
stg.dump_tbars_array_id , 
stg.dump_tbars_array_index ,  
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    		else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,stg.dw_modify_ts,  stg.change_type 
from edw_stage_016 .lh2_shift_dump_tbars_array stg 
left outer join pddw.lh2_shift_info as shift_info 
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_dump_tbars_array_b.site_code and  
stg.dump_tbars_array_id = edw_target.lh2_shift_dump_tbars_array_b.dump_tbars_array_id and  
stg.dump_tbars_array_index = edw_target.lh2_shift_dump_tbars_array_b.dump_tbars_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro edw_stage_016.m_lh2_shift_dump_tmbars_array_b
as
(
merge into edw_target.lh2_shift_dump_tmbars_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.dump_tmbars_array_id ,  
	stg.dump_tmbars_array_index ,  
	stg.shiftid ,
	stg.dump_tmbars_array_value ,
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_shift_dump_tmbars_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.dump_tmbars_array_id = tgt.dump_tmbars_array_id and 
stg.dump_tmbars_array_index = tgt.dump_tmbars_array_index)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	dump_tmbars_array_value =  stg.dump_tmbars_array_value ,
	shiftid = stg.shiftid ,
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.dump_tmbars_array_id , 
	stg.dump_tmbars_array_index , 
	stg.shiftid ,
	stg.dump_tmbars_array_value , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_dump_tmbars_array_b  
from 
( select stg.site_code , 
stg.dump_tmbars_array_id , 
stg.dump_tmbars_array_index ,  
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_shift_dump_tmbars_array stg 
left outer join pddw.lh2_shift_info as shift_info 
on (stg.site_code = shift_info.site_code and 
stg.shiftid  = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_dump_tmbars_array_b.site_code and  
stg.dump_tmbars_array_id = edw_target.lh2_shift_dump_tmbars_array_b.dump_tmbars_array_id and  
stg.dump_tmbars_array_index = edw_target.lh2_shift_dump_tmbars_array_b.dump_tmbars_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
replace macro  edw_stage_016.m_lh2_shift_eqmt_b
as
(
merge into edw_target.lh2_shift_eqmt_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_eqmt_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldpit ,  
 stg.fieldregionlock ,  
 stg.fieldsize ,  
 stg.fieldtmph ,  
 stg.fieldreason ,  
 stg.fieldunit ,  
 stg.fieldstatus ,  
 stg.fieldextraload ,  
 stg.fieldnoassign ,  
 stg.fieldloadstart ,  
 stg.fieldeqmttype ,  
 coalesce(stg.fieldcomment,' ') as fieldcomment ,  
 stg.fieldreasonrec ,  
 stg.fieldoper ,  
 stg.fieldaudit ,  
 stg.fieldsubcode ,  
 stg.fieldsubcode2 ,  
 coalesce(stg.fieldsituation,' ') as fieldsituation ,  
 stg.fielduser ,  
 stg.fieldmaintstart ,  
 stg.fieldmaintpropose ,  
 stg.fieldwarranty ,  
 stg.fieldenghr ,  
 stg.fieldenghr2 ,  
 stg.fieldenghrtime ,  
(cast (date '1970-01-01' +  cast (floor( cast ( fieldenghrtime  as float) / 86400) as integer) as timestamp (0))
+ (  (  ( cast ( fieldenghrtime   as number) mod cast (86400 as number) )) * interval '00:00:01' hour to second))  as fieldenghrtime_ts ,  
 stg.fieldenghrtime2 ,  
(cast (date '1970-01-01' +  cast (floor( cast ( fieldenghrtime2  as float) / 86400) as integer) as timestamp (0))
+ (  (  ( cast ( fieldenghrtime2   as number) mod cast (86400 as number) )) * interval '00:00:01' hour to second)) as fieldenghrtime2_ts ,  
 stg.fieldisauxil ,  
 coalesce(stg.fieldpmid,' ') as fieldpmid ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_eqmt as stg  
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_eqmt_id = tgt.shift_eqmt_id 
and stg.shiftid = tgt.shiftid )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftdate =  stg.shiftdate , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldpit =  stg.fieldpit , 
 fieldregionlock =  stg.fieldregionlock , 
 fieldsize =  stg.fieldsize , 
 fieldtmph =  stg.fieldtmph , 
 fieldreason =  stg.fieldreason , 
 fieldunit =  stg.fieldunit , 
 fieldstatus =  stg.fieldstatus , 
 fieldextraload =  stg.fieldextraload , 
 fieldnoassign =  stg.fieldnoassign , 
 fieldloadstart =  stg.fieldloadstart , 
 fieldeqmttype =  stg.fieldeqmttype , 
 fieldcomment =  stg.fieldcomment , 
 fieldreasonrec =  stg.fieldreasonrec , 
 fieldoper =  stg.fieldoper , 
 fieldaudit =  stg.fieldaudit , 
 fieldsubcode =  stg.fieldsubcode , 
 fieldsubcode2 =  stg.fieldsubcode2 , 
 fieldsituation =  stg.fieldsituation , 
 fielduser =  stg.fielduser , 
 fieldmaintstart =  stg.fieldmaintstart , 
 fieldmaintpropose =  stg.fieldmaintpropose , 
 fieldwarranty =  stg.fieldwarranty , 
 fieldenghr =  stg.fieldenghr , 
 fieldenghr2 =  stg.fieldenghr2 , 
 fieldenghrtime =  stg.fieldenghrtime , 
 fieldenghrtime_ts =  stg.fieldenghrtime_ts , 
 fieldenghrtime2 =  stg.fieldenghrtime2 , 
 fieldenghrtime2_ts =  stg.fieldenghrtime2_ts , 
 fieldisauxil =  stg.fieldisauxil , 
 fieldpmid =  stg.fieldpmid , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_eqmt_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldpit , 
  stg.fieldregionlock , 
  stg.fieldsize , 
  stg.fieldtmph , 
  stg.fieldreason , 
  stg.fieldunit , 
  stg.fieldstatus , 
  stg.fieldextraload , 
  stg.fieldnoassign , 
  stg.fieldloadstart , 
  stg.fieldeqmttype , 
  stg.fieldcomment , 
  stg.fieldreasonrec , 
  stg.fieldoper , 
  stg.fieldaudit , 
  stg.fieldsubcode , 
  stg.fieldsubcode2 , 
  stg.fieldsituation , 
  stg.fielduser , 
  stg.fieldmaintstart , 
  stg.fieldmaintpropose , 
  stg.fieldwarranty , 
  stg.fieldenghr , 
  stg.fieldenghr2 , 
  stg.fieldenghrtime , 
  stg.fieldenghrtime_ts , 
  stg.fieldenghrtime2 , 
  stg.fieldenghrtime2_ts , 
  stg.fieldisauxil , 
  stg.fieldpmid , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_eqmt_b  
from 
( select stg.site_code , 
stg.shift_eqmt_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type
from edw_stage_016.lh2_shift_eqmt stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
cast(substr(trim(stg.shift_eqmt_id),1,9) as integer) = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_eqmt_b.site_code and  
stg.shift_eqmt_id = edw_target.lh2_shift_eqmt_b.shift_eqmt_id and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_fuel_array_b
as
(
merge into edw_target.lh2_shift_fuel_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.shift_fuel_array_id ,  
	stg.shift_fuel_array_index ,  
	stg.shiftid ,
	stg.shift_fuel_array_value ,
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_shift_fuel_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_fuel_array_id = tgt.shift_fuel_array_id and 
stg.shift_fuel_array_index = tgt.shift_fuel_array_index)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	shift_fuel_array_value =  stg.shift_fuel_array_value , 
	shiftid = stg.shiftid ,
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.shift_fuel_array_id , 
	stg.shift_fuel_array_index , 
	stg.shiftid ,
	stg.shift_fuel_array_value , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_fuel_array_b  
from 
( select stg.site_code , 
stg.shift_fuel_array_id , 
stg.shift_fuel_array_index ,  
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts, 
stg.change_type 
from edw_stage_016 .lh2_shift_fuel_array stg 
left outer join pddw.lh2_shift_info as shift_info 
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid)
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_fuel_array_b.site_code and  
stg.shift_fuel_array_id = edw_target.lh2_shift_fuel_array_b.shift_fuel_array_id and  
stg.shift_fuel_array_index = edw_target.lh2_shift_fuel_array_b.shift_fuel_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_fuel_b
as
(
merge into edw_target.lh2_shift_fuel_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_fuel_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldauxeqmt ,  
 stg.fieldeqmt ,  
 stg.fieldtimestart ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimestart / 60 as  interval minute(4)) + cast ( (stg.fieldtimestart  mod 60 ) as interval second(4,3))  as fieldtimestart_ts ,  
 stg.fieldtimeend ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimeend / 60 as  interval minute(4)) + cast ( (stg.fieldtimeend  mod 60 ) as interval second(4,3))  as fieldtimeend_ts ,  
 stg.fieldaudit ,  
 stg.fieldenghr ,  
 stg.fieldenghr2 ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_fuel as stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_fuel_id = tgt.shift_fuel_id 
and stg.shiftid = tgt.shiftid )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftdate =  stg.shiftdate , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldauxeqmt =  stg.fieldauxeqmt , 
 fieldeqmt =  stg.fieldeqmt , 
 fieldtimestart =  stg.fieldtimestart , 
 fieldtimestart_ts =  stg.fieldtimestart_ts , 
 fieldtimeend =  stg.fieldtimeend , 
 fieldtimeend_ts =  stg.fieldtimeend_ts , 
 fieldaudit =  stg.fieldaudit , 
 fieldenghr =  stg.fieldenghr , 
 fieldenghr2 =  stg.fieldenghr2 , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_fuel_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldauxeqmt , 
  stg.fieldeqmt , 
  stg.fieldtimestart , 
  stg.fieldtimestart_ts , 
  stg.fieldtimeend , 
  stg.fieldtimeend_ts , 
  stg.fieldaudit , 
  stg.fieldenghr , 
  stg.fieldenghr2 , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_fuel_b  
from 
( select stg.site_code , 
stg.shift_fuel_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    	else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts, 
stg.change_type
from edw_stage_016.lh2_shift_fuel stg 
	left outer join pddw.lh2_shift_info shift_info
	on (stg.site_code = shift_info.site_code and 
	cast(substr(trim(stg.shift_fuel_id),1,9) as integer) = shift_info.shiftid)
	) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_fuel_b.site_code and  
stg.shift_fuel_id = edw_target.lh2_shift_fuel_b.shift_fuel_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_grade_array_b
as
(
merge into edw_target.lh2_shift_grade_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.shift_grade_array_id ,  
	stg.shift_grade_array_index ,  
	stg.shiftid ,
	stg.shift_grade_array_value ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_shift_grade_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_grade_array_id = tgt.shift_grade_array_id and 
stg.shift_grade_array_index = tgt.shift_grade_array_index)

when matched then 
update set 
orig_src_id =  stg.orig_src_id , 
shift_grade_array_value =  stg.shift_grade_array_value , 
shiftid = stg.shiftid ,
src_change_id =  stg.src_change_id , 
dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
stg.orig_src_id , 
stg.site_code , 
stg.shift_grade_array_id , 
stg.shift_grade_array_index , 
stg.shiftid ,
stg.shift_grade_array_value ,
stg.src_change_id , 
stg.dw_logical_delete_flag , 
stg.dw_modify_ts , 
stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_grade_array_b  
from 
( select stg.site_code , 
stg.shift_grade_array_id , 
stg.shift_grade_array_index ,  
case  when stg.change_type in('D')     then
                       case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    	else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_shift_grade_array stg 
left outer join pddw.lh2_shift_info as shift_info 
on (stg.site_code = shift_info.site_code and 
stg.shiftid  = shift_info.shiftid)
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_grade_array_b.site_code and  
stg.shift_grade_array_id = edw_target.lh2_shift_grade_array_b.shift_grade_array_id and  
stg.shift_grade_array_index = edw_target.lh2_shift_grade_array_b.shift_grade_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_grade_b
as
(
merge into edw_target.lh2_shift_grade_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_grade_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldloc ,  
 stg.fielddump ,  
 stg.fieldinv ,  
 stg.fieldspgr ,  
 stg.fieldload ,  
 stg.fieldblend ,  
 stg.fielddensity ,  
 stg.fieldthickness ,  
 stg.fieldshot ,  
 coalesce(stg.fieldproperty,' ') as fieldproperty ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_grade as stg  
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_grade_id = tgt.shift_grade_id 
and stg.shiftid = tgt.shiftid )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftdate =  stg.shiftdate , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldloc =  stg.fieldloc , 
 fielddump =  stg.fielddump , 
 fieldinv =  stg.fieldinv , 
 fieldspgr =  stg.fieldspgr , 
 fieldload =  stg.fieldload , 
 fieldblend =  stg.fieldblend , 
 fielddensity =  stg.fielddensity , 
 fieldthickness =  stg.fieldthickness , 
 fieldshot =  stg.fieldshot , 
 fieldproperty =  stg.fieldproperty , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_grade_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldloc , 
  stg.fielddump , 
  stg.fieldinv , 
  stg.fieldspgr , 
  stg.fieldload , 
  stg.fieldblend , 
  stg.fielddensity , 
  stg.fieldthickness , 
  stg.fieldshot , 
  stg.fieldproperty , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_grade_b  
from 
( select stg.site_code , 
stg.shift_grade_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016.lh2_shift_grade stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
cast(substr(trim(stg.shift_grade_id),1,9) as integer) = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_grade_b.site_code and  
stg.shift_grade_id = edw_target.lh2_shift_grade_b.shift_grade_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"


create  macro edw_stage_016.m_lh2_shift_info_b
as
(
merge into edw_target.lh2_shift_info_b  as tgt 
using 
( 
select  
orig_src_id ,  
site_code ,  
shiftid ,  
cast(shiftstartdate as date) as shiftdate ,  -- changed from shiftdate to shiftstartdate  as we get native language description for month abbrevation on 10/30/2019
shiftdate as shiftdate_string, -- Included on 10/30/2019 to handle native language description for month abbrevation in hist_exproot  collection
coalesce(shiftname,' ') as shiftname ,  
coalesce(shift_dbname,' ') as shift_dbname ,  
shiftyear ,  
shiftmonth ,  
shiftday ,  
coalesce(shiftsuffix,' ') as shiftsuffix ,  
coalesce(fullshiftsuffix,' ') as fullshiftsuffix ,  
shiftstartsecsincemidnight ,  
shiftstarttimestamp ,  
shiftstartdate ,  
shiftstartdatetime ,  
--2019-11-04 Anandhi Changing the logic to fix the day-light saving issue
--(shiftstartdatetime + cast( shiftduration/3600 as interval hour )+ cast( shiftduration mod 3600 as interval second(4) )) shiftenddatetime,
case when shiftid = max(shiftid) over ( partition by site_code order by shiftid)
then (shiftstartdatetime + cast( shiftduration/3600 as interval hour )+ cast( shiftduration mod 3600 as interval second(4) ))
else max(shiftstartdatetime) over (partition by site_Code order by shiftid rows between 1 following  and 1 following)
end shiftenddatetime,
coalesce(fullshiftname,' ') as fullshiftname ,  
holiday ,  
coalesce(crew,' ') as crew ,  
shiftduration ,  
dw_logical_delete_flag ,  
dw_modify_ts ,  
dw_load_ts   
from  edw_stage_016.lh2_shift_info 
) as stg 
 on ( stg.site_code = tgt.site_code 
 and stg.shiftid = tgt.shiftid)

when matched then 
update 
set 
orig_src_id =  stg.orig_src_id , 
shiftdate =  stg.shiftdate , 
shiftdate_string =  stg.shiftdate_string , 
shiftname =  stg.shiftname , 
shift_dbname =  stg.shift_dbname , 
shiftyear =  stg.shiftyear , 
shiftmonth =  stg.shiftmonth , 
shiftday =  stg.shiftday , 
shiftsuffix =  stg.shiftsuffix , 
fullshiftsuffix =  stg.fullshiftsuffix , 
shiftstartsecsincemidnight =  stg.shiftstartsecsincemidnight ,
shiftstarttimestamp =  stg.shiftstarttimestamp , 
shiftstartdate =  stg.shiftstartdate , 
shiftstartdatetime =  stg.shiftstartdatetime , 
shiftenddatetime =  stg.shiftenddatetime , 
fullshiftname =  stg.fullshiftname , 
holiday =  stg.holiday , 
crew =  stg.crew , 
shiftduration =  stg.shiftduration , 
dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert 
values (
stg.orig_src_id , 
stg.site_code , 
stg.shiftid , 
stg.shiftdate , 
stg.shiftdate_string , 
stg.shiftname , 
stg.shift_dbname , 
stg.shiftyear , 
stg.shiftmonth , 
stg.shiftday , 
stg.shiftsuffix , 
stg.fullshiftsuffix , 
stg.shiftstartsecsincemidnight , 
stg.shiftstarttimestamp , 
stg.shiftstartdate , 
stg.shiftstartdatetime , 
stg.shiftenddatetime , 
stg.fullshiftname , 
stg.holiday , 
stg.crew , 
stg.shiftduration , 
stg.dw_logical_delete_flag , 
stg.dw_modify_ts , 
stg.dw_load_ts);

update  edw_target.lh2_shift_info_b  
from 
     (
     select    
	 site_code,
	 shiftid, case 
                           when dw_load_ts <  (current_date-170)  then 'A' --archive
                           when dw_load_ts > (current_date - 170) then 'Y' ---handles  regular delete 
                           else 'N'  end  as dw_logical_delete_flag 
     from edw_target.lh2_shift_info_b 
     where dw_logical_delete_flag =  'N'  
     )  as src
set
dw_logical_delete_flag =   src.dw_logical_delete_flag
,dw_modify_ts =  ( select max(dw_modify_ts)  from edw_stage_016.lh2_shift_info)
where 
  src.site_code = edw_target.lh2_shift_info_b.site_code
 and src.shiftid=edw_target.lh2_shift_info_b.shiftid
 and edw_target.lh2_shift_info_b.dw_logical_delete_flag =  'N'  
 and not exists 
        (
        select 'X'  
        from edw_stage_016.lh2_shift_info stg 
        where stg.site_code = edw_target.lh2_shift_info_b.site_code
         and stg.shiftid = edw_target.lh2_shift_info_b.shiftid
        )
  and exists 
        (
        select 'X'  
        from edw_stage_016.lh2_shift_info stg 
        where stg.site_code = edw_target.lh2_shift_info_b.site_code
        );
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_load_b
as
(
merge into edw_target.lh2_shift_load_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_load_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldtruck ,  
 stg.fieldexcav ,  
 stg.fieldgrade ,  
 stg.fieldloc ,  
 stg.fielddumprec ,  
 stg.fieldtons ,  
 stg.fieldtimearrive ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimearrive / 60 as  interval minute(4)) + cast ( (stg.fieldtimearrive  mod 60 ) as interval second(4,3))  as fieldtimearrive_ts ,  
 stg.fieldtimeload ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimeload / 60 as  interval minute(4)) + cast ( (stg.fieldtimeload  mod 60 ) as interval second(4,3))  as fieldtimeload_ts ,  
 stg.fieldtimefull ,  
 shift_info.shiftstartdatetime + cast (stg.fieldtimefull / 60 as  interval minute(4)) + cast ( (stg.fieldtimefull  mod 60 ) as interval second(4,3))  as fieldtimefull_ts ,  
 stg.fieldcalctravtime ,  
 shift_info.shiftstartdatetime + cast (stg.fieldcalctravtime / 60 as  interval minute(4)) + cast ( (stg.fieldcalctravtime  mod 60 ) as interval second(4,3))  as fieldcalctravtime_ts ,  
 stg.fieldload ,  
 stg.fieldextraload ,  
 stg.fieldloadtype ,  
 stg.fielddist ,  
 stg.fieldefh ,  
 stg.fieldtoper ,  
 stg.fieldeoper ,  
 coalesce(stg.fieldorigasn,' ') as fieldorigasn ,  
 coalesce(stg.fieldreasnby,' ') as fieldreasnby ,  
 stg.fieldpathtravtime ,  
 coalesce(stg.fieldlocactlc,' ') as fieldlocactlc ,  
 stg.fieldlocacttp ,  
 coalesce(stg.fieldlocactrl,' ') as fieldlocactrl ,  
 stg.fieldfirstdipper ,  
 stg.fieldlastdipper ,  
 stg.fieldbktcnt ,  
 coalesce(stg.fieldpandhbucketloads,' ') as fieldpandhbucketloads ,  
 stg.fieldaudit ,  
 stg.fieldweightst ,  
 stg.fieldweightmeas ,  
 stg.fieldmeasuretime ,  
 stg.fieldgpsxtkl ,  
 stg.fieldgpsytkl ,  
 stg.fieldgpsxex ,  
 stg.fieldgpsyex ,  
 stg.fieldgpsstatex ,  
 stg.fieldgpsstattk ,  
 stg.fieldgpsheadtk ,  
 stg.fieldgpsveltk ,  
 coalesce(stg.fieldpvs3id,' ') as fieldpvs3id ,  
 stg.fieldbktsum ,  
 stg.fielddumpasn ,  
 stg.fieldlsizetons ,  
 coalesce(stg.fieldlsizeid,' ') as fieldlsizeid ,  
 stg.fieldlsizeversion ,  
 stg.fieldlsizedb ,  
 stg.fieldfuelremain ,  
 stg.fieldfactapply ,  
 coalesce(stg.fielddlock,' ') as fielddlock ,  
 coalesce(stg.fieldelock,' ') as fieldelock ,  
 coalesce(stg.fieldedlock,' ') as fieldedlock ,  
 coalesce(stg.fieldrlock,' ') as fieldrlock ,  
 stg.fieldreconstat ,  
 stg.fieldtimearrivemobile ,  
 stg.fieldtimeloadmobile ,  
 stg.fieldtimefullmobile ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_load as stg  
	left outer join pddw.lh2_shift_info shift_info
	on (stg.site_code = shift_info.site_code and 
	stg.shiftid = shift_info.shiftid )   where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_load_id = tgt.shift_load_id and 
stg.shiftid = tgt.shiftid and  
stg.shiftdate =  tgt.shiftdate )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldtruck =  stg.fieldtruck , 
 fieldexcav =  stg.fieldexcav , 
 fieldgrade =  stg.fieldgrade , 
 fieldloc =  stg.fieldloc , 
 fielddumprec =  stg.fielddumprec , 
 fieldtons =  stg.fieldtons , 
 fieldtimearrive =  stg.fieldtimearrive , 
 fieldtimearrive_ts =  stg.fieldtimearrive_ts , 
 fieldtimeload =  stg.fieldtimeload , 
 fieldtimeload_ts =  stg.fieldtimeload_ts , 
 fieldtimefull =  stg.fieldtimefull , 
 fieldtimefull_ts =  stg.fieldtimefull_ts , 
 fieldcalctravtime =  stg.fieldcalctravtime , 
 fieldcalctravtime_ts =  stg.fieldcalctravtime_ts , 
 fieldload =  stg.fieldload , 
 fieldextraload =  stg.fieldextraload , 
 fieldloadtype =  stg.fieldloadtype , 
 fielddist =  stg.fielddist , 
 fieldefh =  stg.fieldefh , 
 fieldtoper =  stg.fieldtoper , 
 fieldeoper =  stg.fieldeoper , 
 fieldorigasn =  stg.fieldorigasn , 
 fieldreasnby =  stg.fieldreasnby , 
 fieldpathtravtime =  stg.fieldpathtravtime , 
 fieldlocactlc =  stg.fieldlocactlc , 
 fieldlocacttp =  stg.fieldlocacttp , 
 fieldlocactrl =  stg.fieldlocactrl , 
 fieldfirstdipper =  stg.fieldfirstdipper , 
 fieldlastdipper =  stg.fieldlastdipper , 
 fieldbktcnt =  stg.fieldbktcnt , 
 fieldpandhbucketloads =  stg.fieldpandhbucketloads , 
 fieldaudit =  stg.fieldaudit , 
 fieldweightst =  stg.fieldweightst , 
 fieldweightmeas =  stg.fieldweightmeas , 
 fieldmeasuretime =  stg.fieldmeasuretime , 
 fieldgpsxtkl =  stg.fieldgpsxtkl , 
 fieldgpsytkl =  stg.fieldgpsytkl , 
 fieldgpsxex =  stg.fieldgpsxex , 
 fieldgpsyex =  stg.fieldgpsyex , 
 fieldgpsstatex =  stg.fieldgpsstatex , 
 fieldgpsstattk =  stg.fieldgpsstattk , 
 fieldgpsheadtk =  stg.fieldgpsheadtk , 
 fieldgpsveltk =  stg.fieldgpsveltk , 
 fieldpvs3id =  stg.fieldpvs3id , 
 fieldbktsum =  stg.fieldbktsum , 
 fielddumpasn =  stg.fielddumpasn , 
 fieldlsizetons =  stg.fieldlsizetons , 
 fieldlsizeid =  stg.fieldlsizeid , 
 fieldlsizeversion =  stg.fieldlsizeversion , 
 fieldlsizedb =  stg.fieldlsizedb , 
 fieldfuelremain =  stg.fieldfuelremain , 
 fieldfactapply =  stg.fieldfactapply , 
 fielddlock =  stg.fielddlock , 
 fieldelock =  stg.fieldelock , 
 fieldedlock =  stg.fieldedlock , 
 fieldrlock =  stg.fieldrlock , 
 fieldreconstat =  stg.fieldreconstat , 
 fieldtimearrivemobile =  stg.fieldtimearrivemobile , 
 fieldtimeloadmobile =  stg.fieldtimeloadmobile , 
 fieldtimefullmobile =  stg.fieldtimefullmobile , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_load_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldtruck , 
  stg.fieldexcav , 
  stg.fieldgrade , 
  stg.fieldloc , 
  stg.fielddumprec , 
  stg.fieldtons , 
  stg.fieldtimearrive , 
  stg.fieldtimearrive_ts , 
  stg.fieldtimeload , 
  stg.fieldtimeload_ts , 
  stg.fieldtimefull , 
  stg.fieldtimefull_ts , 
  stg.fieldcalctravtime , 
  stg.fieldcalctravtime_ts , 
  stg.fieldload , 
  stg.fieldextraload , 
  stg.fieldloadtype , 
  stg.fielddist , 
  stg.fieldefh , 
  stg.fieldtoper , 
  stg.fieldeoper , 
  stg.fieldorigasn , 
  stg.fieldreasnby , 
  stg.fieldpathtravtime , 
  stg.fieldlocactlc , 
  stg.fieldlocacttp , 
  stg.fieldlocactrl , 
  stg.fieldfirstdipper , 
  stg.fieldlastdipper , 
  stg.fieldbktcnt , 
  stg.fieldpandhbucketloads , 
  stg.fieldaudit , 
  stg.fieldweightst , 
  stg.fieldweightmeas , 
  stg.fieldmeasuretime , 
  stg.fieldgpsxtkl , 
  stg.fieldgpsytkl , 
  stg.fieldgpsxex , 
  stg.fieldgpsyex , 
  stg.fieldgpsstatex , 
  stg.fieldgpsstattk , 
  stg.fieldgpsheadtk , 
  stg.fieldgpsveltk , 
  stg.fieldpvs3id , 
  stg.fieldbktsum , 
  stg.fielddumpasn , 
  stg.fieldlsizetons , 
  stg.fieldlsizeid , 
  stg.fieldlsizeversion , 
  stg.fieldlsizedb , 
  stg.fieldfuelremain , 
  stg.fieldfactapply , 
  stg.fielddlock , 
  stg.fieldelock , 
  stg.fieldedlock , 
  stg.fieldrlock , 
  stg.fieldreconstat , 
  stg.fieldtimearrivemobile , 
  stg.fieldtimeloadmobile , 
  stg.fieldtimefullmobile , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_load_b  
from 
( select 
stg.site_code , 
stg.shift_load_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type
from edw_stage_016.lh2_shift_load stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
cast(substr(trim(stg.shift_load_id),1,9) as integer) = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_load_b.site_code and  
stg.shift_load_id = edw_target.lh2_shift_load_b.shift_load_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_load_lift_array_b
as
(
merge into edw_target.lh2_shift_load_lift_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.load_lift_array_id ,  
	stg.load_lift_array_index ,  
	stg.shiftid ,
	stg.load_lift_array_value , 
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_shift_load_lift_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.load_lift_array_id = tgt.load_lift_array_id and
stg.load_lift_array_index = tgt.load_lift_array_index )

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	load_lift_array_value =  stg.load_lift_array_value , 
	shiftid = stg.shiftid ,
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.load_lift_array_id , 
	stg.load_lift_array_index , 
	stg.shiftid ,
	stg.load_lift_array_value , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_load_lift_array_b  
from 
( select stg.site_code , 
stg.load_lift_array_id , 
stg.load_lift_array_index,  
case  when stg.change_type in('D')     then
                       case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts, 
stg.change_type 
from edw_stage_016 .lh2_shift_load_lift_array stg 
left outer join pddw.lh2_shift_info as shift_info 
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_load_lift_array_b.site_code and  
stg.load_lift_array_id = edw_target.lh2_shift_load_lift_array_b.load_lift_array_id and 
stg.load_lift_array_index = edw_target.lh2_shift_load_lift_array_b.load_lift_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_load_lift_dist_array_b
as
(
merge into edw_target.lh2_shift_load_lift_dist_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.load_lift_dist_array_id ,  
	stg.load_lift_dist_array_index ,  
	stg.shiftid ,
	stg.load_lift_dist_array_value ,
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_shift_load_lift_dist_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.load_lift_dist_array_id = tgt.load_lift_dist_array_id and 
stg.load_lift_dist_array_index =  tgt.load_lift_dist_array_index )

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	load_lift_dist_array_value =  stg.load_lift_dist_array_value ,
	shiftid = stg.shiftid ,
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.load_lift_dist_array_id , 
	stg.load_lift_dist_array_index , 
	stg.shiftid ,
	stg.load_lift_dist_array_value ,
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_load_lift_dist_array_b  
from 
( select stg.site_code , 
stg.load_lift_dist_array_id , 
stg.load_lift_dist_array_index , 
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,stg.dw_modify_ts,  stg.change_type 
from edw_stage_016 .lh2_shift_load_lift_dist_array stg 
left outer join pddw.lh2_shift_info as shift_info 
on (stg.site_code = shift_info.site_code and 
	stg.shiftid = shift_info.shiftid)
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_load_lift_dist_array_b.site_code and  
stg.load_lift_dist_array_id = edw_target.lh2_shift_load_lift_dist_array_b.load_lift_dist_array_id and
stg.load_lift_dist_array_index = edw_target.lh2_shift_load_lift_dist_array_b.load_lift_dist_array_index and 
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_load_tbars_array_b
as
(
merge into edw_target.lh2_shift_load_tbars_array_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.load_tbars_array_id ,  
	stg.load_tbars_array_index ,  
	stg.shiftid ,
	coalesce(stg.load_tbars_array_value,' ') as load_tbars_array_value ,
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_shift_load_tbars_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.load_tbars_array_id = tgt.load_tbars_array_id and 
stg.load_tbars_array_index = tgt.load_tbars_array_index)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	load_tbars_array_value =  stg.load_tbars_array_value ,
	shiftid = stg.shiftid ,
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.load_tbars_array_id , 
	stg.load_tbars_array_index , 
	stg.shiftid ,
	stg.load_tbars_array_value ,
    stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_load_tbars_array_b  
from 
( select stg.site_code , 
stg.load_tbars_array_id , 
stg.load_tbars_array_index ,  
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_shift_load_tbars_array stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
	stg.shiftid= shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_load_tbars_array_b.site_code and  
stg.load_tbars_array_id = edw_target.lh2_shift_load_tbars_array_b.load_tbars_array_id and  
stg.load_tbars_array_index = edw_target.lh2_shift_load_tbars_array_b.load_tbars_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_shift_load_tmbars_array_b
as
(
merge into edw_target.lh2_shift_load_tmbars_array_b as tgt 
using 
( 
select  
stg.orig_src_id ,  
stg.site_code ,  
stg.load_tmbars_array_id ,  
stg.load_tmbars_array_index ,  
stg.shiftid ,
stg.load_tmbars_array_value ,  
stg.src_change_id ,  
stg.dw_logical_delete_flag ,  
stg.dw_modify_ts ,  
stg.dw_load_ts   
from   edw_stage_016.lh2_shift_load_tmbars_array as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.load_tmbars_array_id = tgt.load_tmbars_array_id and 
stg.load_tmbars_array_index = tgt.load_tmbars_array_index)

when matched then 
update set 
orig_src_id =  stg.orig_src_id , 
load_tmbars_array_value =  stg.load_tmbars_array_value ,
shiftid = stg.shiftid ,
src_change_id =  stg.src_change_id , 
dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
stg.orig_src_id , 
stg.site_code , 
stg.load_tmbars_array_id , 
stg.load_tmbars_array_index , 
stg.shiftid ,
stg.load_tmbars_array_value ,
stg.src_change_id , 
stg.dw_logical_delete_flag , 
stg.dw_modify_ts , 
stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_load_tmbars_array_b  
from 
( select stg.site_code , 
stg.load_tmbars_array_id , 
stg.load_tmbars_array_index , 
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_shift_load_tmbars_array stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_load_tmbars_array_b.site_code and  
stg.load_tmbars_array_id = edw_target.lh2_shift_load_tmbars_array_b.load_tmbars_array_id and  
stg.load_tmbars_array_index = edw_target.lh2_shift_load_tmbars_array_b.load_tmbars_array_index and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_loc_b
as
(
merge into edw_target.lh2_shift_loc_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_loc_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldpit ,  
 stg.fieldregion ,  
 stg.fieldelev ,  
 stg.fieldunit ,  
 stg.fieldaudit ,  
 coalesce(stg.fieldmetadata,' ') as fieldmetadata ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_loc as stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_loc_id = tgt.shift_loc_id 
and stg.shiftid = tgt.shiftid )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftdate =  stg.shiftdate , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldpit =  stg.fieldpit , 
 fieldregion =  stg.fieldregion , 
 fieldelev =  stg.fieldelev , 
 fieldunit =  stg.fieldunit , 
 fieldaudit =  stg.fieldaudit , 
 fieldmetadata =  stg.fieldmetadata , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_loc_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldpit , 
  stg.fieldregion , 
  stg.fieldelev , 
  stg.fieldunit , 
  stg.fieldaudit , 
  stg.fieldmetadata , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_loc_b  
from 
( select stg.site_code , 
stg.shift_loc_id ,   
case  when stg.change_type in('D')     then
                       case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,stg.dw_modify_ts,  stg.change_type
from edw_stage_016.lh2_shift_loc stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
cast(substr(trim(stg.shift_loc_id),1,9) as integer) = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_loc_b.site_code and  
stg.shift_loc_id = edw_target.lh2_shift_loc_b.shift_loc_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_oper_b
as
(
merge into edw_target.lh2_shift_oper_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_oper_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldeqmt ,  
 stg.fieldauxeqmt ,  
 stg.fieldlogin ,  
 shift_info.shiftstartdatetime + cast (stg.fieldlogin / 60 as  interval minute(4)) + cast ( (stg.fieldlogin  mod 60 ) as interval second(4,3))  as fieldlogin_ts ,  
 stg.fieldstatus ,  
 coalesce(stg.fieldname,' ') as fieldname ,  
 stg.fieldcrew ,  
 stg.fielddept ,  
 stg.fieldaudit ,  
 stg.fieldenghr ,  
 stg.fieldenghr2 ,  
 stg.fieldarea ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_oper as stg  
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_oper_id = tgt.shift_oper_id and 
stg.shiftid = tgt.shiftid )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftdate =  stg.shiftdate , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldeqmt =  stg.fieldeqmt , 
 fieldauxeqmt =  stg.fieldauxeqmt , 
 fieldlogin =  stg.fieldlogin , 
 fieldlogin_ts =  stg.fieldlogin_ts , 
 fieldstatus =  stg.fieldstatus , 
 fieldname =  stg.fieldname , 
 fieldcrew =  stg.fieldcrew , 
 fielddept =  stg.fielddept , 
 fieldaudit =  stg.fieldaudit , 
 fieldenghr =  stg.fieldenghr , 
 fieldenghr2 =  stg.fieldenghr2 , 
 fieldarea =  stg.fieldarea , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
 stg.orig_src_id , 
  stg.site_code , 
  stg.shift_oper_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldeqmt , 
  stg.fieldauxeqmt , 
  stg.fieldlogin , 
  stg.fieldlogin_ts , 
  stg.fieldstatus , 
  stg.fieldname , 
  stg.fieldcrew , 
  stg.fielddept , 
  stg.fieldaudit , 
  stg.fieldenghr , 
  stg.fieldenghr2 , 
  stg.fieldarea , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_oper_b  
from 
( select stg.site_code , 
stg.shift_oper_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type
from edw_stage_016.lh2_shift_oper stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
cast(substr(trim(stg.shift_oper_id),1,9) as integer) = shift_info.shiftid)
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_oper_b.site_code and  
stg.shift_oper_id = edw_target.lh2_shift_oper_b.shift_oper_id and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_reason_b
as
(
merge into edw_target.lh2_shift_reason_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_reason_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldreason ,  
 stg.fieldstatus ,  
 stg.fielddelaytime ,  
 stg.fieldcategory ,  
 coalesce(stg.fieldname,' ') as fieldname ,  
 stg.fieldmainttime ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_reason as stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_reason_id = tgt.shift_reason_id 
and stg.shiftid = tgt.shiftid )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftdate =  stg.shiftdate , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldreason =  stg.fieldreason , 
 fieldstatus =  stg.fieldstatus , 
 fielddelaytime =  stg.fielddelaytime , 
 fieldcategory =  stg.fieldcategory , 
 fieldname =  stg.fieldname , 
 fieldmainttime =  stg.fieldmainttime , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_reason_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldreason , 
  stg.fieldstatus , 
  stg.fielddelaytime , 
  stg.fieldcategory , 
  stg.fieldname , 
  stg.fieldmainttime , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_reason_b  
from 
( select stg.site_code , 
stg.shift_reason_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type
from edw_stage_016.lh2_shift_reason stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
cast(substr(trim(stg.shift_reason_id),1,9) as integer) = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_reason_b.site_code and  
stg.shift_reason_id = edw_target.lh2_shift_reason_b.shift_reason_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro  edw_stage_016.m_lh2_shift_state_b
as
(
merge into edw_target.lh2_shift_state_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.shift_state_id ,  
 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  
 stg.dbprevious ,  
 stg.dbnext ,  
 stg.dbversion ,  
 stg.shiftid ,  
 coalesce(stg.shift_dbname,' ') as shift_dbname ,  
 stg.dbkey ,  
 coalesce(stg.fieldid,' ') as fieldid ,  
 stg.fieldeqmt ,  
 stg.fieldauxeqmt ,  
 stg.fieldtime ,  
 cast(cast(shift_info.shiftstartdatetime + cast (stg.fieldtime / 60 as  interval minute(4)) + cast ( (stg.fieldtime  mod 60 ) as interval second(4,3)) as varchar(19)) as timestamp(0)) as fieldtime_ts ,  
 stg.fieldreason ,  
 stg.fieldstatus ,  
 coalesce(stg.fieldcomment,' ') as fieldcomment ,  
 stg.fieldreasonrec ,  
 stg.fieldoper ,  
 stg.fieldaudit ,  
 stg.fieldsubcode ,  
 stg.fieldsubcode2 ,  
 coalesce(stg.fieldsituation,' ') as fieldsituation ,  
 stg.fielduser ,  
 stg.fieldmaintstart ,  
 stg.fieldmaintpropose ,  
 stg.fieldwarranty ,  
 stg.fieldgpsx ,  
 stg.fieldgpsy ,  
 stg.fieldgpsstat ,  
 stg.fieldgpshead ,  
 stg.fieldgpsvel ,  
 stg.fieldenghr ,  
 stg.fieldenghr2 ,  
 stg.fieldisauxil ,  
 coalesce(stg.fieldpmid,' ') as fieldpmid ,  
 stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_shift_state as stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid )   
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.shift_state_id = tgt.shift_state_id and 
stg.shiftid = tgt.shiftid  and 
stg.shiftdate =  tgt.shiftdate )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 dbprevious =  stg.dbprevious , 
 dbnext =  stg.dbnext , 
 dbversion =  stg.dbversion , 
 shift_dbname =  stg.shift_dbname , 
 dbkey =  stg.dbkey , 
 fieldid =  stg.fieldid , 
 fieldeqmt =  stg.fieldeqmt , 
 fieldauxeqmt =  stg.fieldauxeqmt , 
 fieldtime =  stg.fieldtime , 
 fieldtime_ts =  stg.fieldtime_ts , 
 fieldreason =  stg.fieldreason , 
 fieldstatus =  stg.fieldstatus , 
 fieldcomment =  stg.fieldcomment , 
 fieldreasonrec =  stg.fieldreasonrec , 
 fieldoper =  stg.fieldoper , 
 fieldaudit =  stg.fieldaudit , 
 fieldsubcode =  stg.fieldsubcode , 
 fieldsubcode2 =  stg.fieldsubcode2 , 
 fieldsituation =  stg.fieldsituation , 
 fielduser =  stg.fielduser , 
 fieldmaintstart =  stg.fieldmaintstart , 
 fieldmaintpropose =  stg.fieldmaintpropose , 
 fieldwarranty =  stg.fieldwarranty , 
 fieldgpsx =  stg.fieldgpsx , 
 fieldgpsy =  stg.fieldgpsy , 
 fieldgpsstat =  stg.fieldgpsstat , 
 fieldgpshead =  stg.fieldgpshead , 
 fieldgpsvel =  stg.fieldgpsvel , 
 fieldenghr =  stg.fieldenghr , 
 fieldenghr2 =  stg.fieldenghr2 , 
 fieldisauxil =  stg.fieldisauxil , 
 fieldpmid =  stg.fieldpmid , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.shift_state_id , 
  stg.shiftdate , 
  stg.dbprevious , 
  stg.dbnext , 
  stg.dbversion , 
  stg.shiftid , 
  stg.shift_dbname , 
  stg.dbkey , 
  stg.fieldid , 
  stg.fieldeqmt , 
  stg.fieldauxeqmt , 
  stg.fieldtime , 
  stg.fieldtime_ts , 
  stg.fieldreason , 
  stg.fieldstatus , 
  stg.fieldcomment , 
  stg.fieldreasonrec , 
  stg.fieldoper , 
  stg.fieldaudit , 
  stg.fieldsubcode , 
  stg.fieldsubcode2 , 
  stg.fieldsituation , 
  stg.fielduser , 
  stg.fieldmaintstart , 
  stg.fieldmaintpropose , 
  stg.fieldwarranty , 
  stg.fieldgpsx , 
  stg.fieldgpsy , 
  stg.fieldgpsstat , 
  stg.fieldgpshead , 
  stg.fieldgpsvel , 
  stg.fieldenghr , 
  stg.fieldenghr2 , 
  stg.fieldisauxil , 
  stg.fieldpmid , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_shift_state_b  
from 
( select stg.site_code , 
stg.shift_state_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,
stg.change_type
from edw_stage_016.lh2_shift_state stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
cast(substr(trim(stg.shift_state_id),1,9) as integer) = shift_info.shiftid)
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_shift_state_b.site_code and  
stg.shift_state_id = edw_target.lh2_shift_state_b.shift_state_id and 
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_sum_shift_dump_b
as
(
merge into edw_target.lh2_sum_shift_dump_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.sum_shift_dump_id ,  
  stg.shiftid ,
 stg.fulltravelnwtime ,  
 stg.queuenwtime ,  
 stg.dumpingnwtime ,  
 stg.prevloadid ,  
 stg.truckfulltimestamp ,  
 stg.truckoperid ,  
 coalesce(stg.materialmovementtype,' ') as materialmovementtype ,  
 coalesce(stg.materialmovementsubtype,' ') as materialmovementsubtype , 
stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from   edw_stage_016.lh2_sum_shift_dump as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.sum_shift_dump_id = tgt.sum_shift_dump_id)

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftid = stg.shiftid ,
 fulltravelnwtime =  stg.fulltravelnwtime , 
 queuenwtime =  stg.queuenwtime , 
 dumpingnwtime =  stg.dumpingnwtime , 
 prevloadid =  stg.prevloadid , 
 truckfulltimestamp =  stg.truckfulltimestamp , 
 truckoperid =  stg.truckoperid , 
 materialmovementtype =  stg.materialmovementtype , 
 materialmovementsubtype =  stg.materialmovementsubtype ,
  src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.sum_shift_dump_id , 
   stg.shiftid ,
   stg.fulltravelnwtime , 
  stg.queuenwtime , 
  stg.dumpingnwtime , 
  stg.prevloadid , 
  stg.truckfulltimestamp , 
  stg.truckoperid , 
  stg.materialmovementtype , 
  stg.materialmovementsubtype , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_sum_shift_dump_b  
from 
( select stg.site_code , 
stg.sum_shift_dump_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_sum_shift_dump stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
stg.shiftid = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_sum_shift_dump_b.site_code and  
stg.sum_shift_dump_id = edw_target.lh2_sum_shift_dump_b.sum_shift_dump_id and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
replace macro  edw_stage_016.m_lh2_sum_shift_load_b
as
(
merge into edw_target.lh2_sum_shift_load_b as tgt 
using 
( 
select  
 stg.orig_src_id ,  
 stg.site_code ,  
 stg.sum_shift_load_id ,  
 stg.shiftid ,
  stg.timespot ,  
(cast (date '1970-01-01' +  cast (floor( cast ( timespot  as float) / 86400) as integer) as timestamp (0))
+ (  (  ( cast ( timespot   as number) mod cast (86400 as number) )) * interval '00:00:01' hour to second))   as timespot_ts,
 stg.emptytravelnwtime ,  
 stg.queuenwtime ,  
 stg.spotnwtime ,  
 stg.loadingnwtime ,  
 stg.truckidletime ,  
 stg.shovelidletime ,  
 stg.prevdumpid ,  
 stg.nextdumpid ,  
 stg.truckassigntimestamp ,  
 stg.truckoperid ,  
 stg.excavoperid ,
stg.src_change_id ,  
 stg.dw_logical_delete_flag ,  
 stg.dw_modify_ts ,  
 stg.dw_load_ts   
from edw_stage_016 .lh2_sum_shift_load stg 
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.sum_shift_load_id = tgt.sum_shift_load_id)

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
  shiftid = stg.shiftid ,
 timespot =  stg.timespot , 
 timespot_ts =  stg.timespot_ts , 
 emptytravelnwtime =  stg.emptytravelnwtime , 
 queuenwtime =  stg.queuenwtime , 
 spotnwtime =  stg.spotnwtime , 
 loadingnwtime =  stg.loadingnwtime , 
 truckidletime =  stg.truckidletime , 
 shovelidletime =  stg.shovelidletime , 
 prevdumpid =  stg.prevdumpid , 
 nextdumpid =  stg.nextdumpid , 
 truckassigntimestamp =  stg.truckassigntimestamp , 
 truckoperid =  stg.truckoperid , 
 excavoperid =  stg.excavoperid , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.sum_shift_load_id , 
  stg.shiftid ,
  stg.timespot , 
  stg.timespot_ts , 
  stg.emptytravelnwtime , 
  stg.queuenwtime , 
  stg.spotnwtime , 
  stg.loadingnwtime , 
  stg.truckidletime , 
  stg.shovelidletime , 
  stg.prevdumpid , 
  stg.nextdumpid , 
  stg.truckassigntimestamp , 
  stg.truckoperid , 
  stg.excavoperid , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_sum_shift_load_b  
from 
( select stg.site_code , 
stg.sum_shift_load_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_sum_shift_load stg 
left outer join pddw.lh2_shift_info shift_info
on (stg.site_code = shift_info.site_code and 
  stg.shiftid  = shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_sum_shift_load_b.site_code and  
stg.sum_shift_load_id = edw_target.lh2_sum_shift_load_b.sum_shift_load_id and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_sum_shift_status_b
as
(
merge into edw_target.lh2_sum_shift_status_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.sum_shift_status_id ,  
	stg.shiftid ,
	stg.duration ,  
	stg.eqmtoperid ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_sum_shift_status as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.sum_shift_status_id = tgt.sum_shift_status_id)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	duration =  stg.duration , 
	eqmtoperid =  stg.eqmtoperid , 
	shiftid = stg.shiftid ,
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.sum_shift_status_id , 
	stg.shiftid ,
	stg.duration , 
	stg.eqmtoperid , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_sum_shift_status_b  
from 
( select stg.site_code , 
stg.sum_shift_status_id ,   
case  when stg.change_type in('D')     then
                      case 
                      when shift_info.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016 .lh2_sum_shift_status stg 
left outer join pddw.lh2_shift_info shift_info 
on (stg.site_code = shift_info.site_code and 
stg.shiftid= shift_info.shiftid) 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_sum_shift_status_b.site_code and  
stg.sum_shift_status_id = edw_target.lh2_sum_shift_status_b.sum_shift_status_id and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create   macro  edw_stage_016.m_lh2_transaction_log_b
as
(
merge into edw_target.lh2_transaction_log_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.transaction_log_id , 
	stg.shiftid  ,  
	stg.shiftdate  ,  
	stg.shiftindex   , 
	stg.transaction_log_timestamp ,  
	stg.messagetype ,  
	coalesce(stg.messagebody,' ') as messagebody ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_transaction_log as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.transaction_log_id = tgt.transaction_log_id)

when matched then 
update set 
	orig_src_id =  stg.orig_src_id , 
	shiftid = stg.shiftid,
	shiftdate = stg.shiftdate,
	shiftindex = stg.shiftindex,
	transaction_log_timestamp =  stg.transaction_log_timestamp , 
	messagetype =  stg.messagetype , 
	messagebody =  stg.messagebody , 
	src_change_id =  stg.src_change_id , 
	dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
	dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
	stg.orig_src_id , 
	stg.site_code , 
	stg.transaction_log_id , 
	stg.shiftid,
	stg.shiftdate,
	stg.shiftindex,
	stg.transaction_log_timestamp , 
	stg.messagetype , 
	stg.messagebody , 
	stg.src_change_id , 
	stg.dw_logical_delete_flag , 
	stg.dw_modify_ts , 
	stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_transaction_log_b  
from 
( select 
stg.site_code ,
stg.transaction_log_id ,   
stg.shiftindex , 
case  when stg.change_type in('D')     then
	                  case 
	                  when stg.shiftdate<(current_date-170) then 'A' 
	                  else 'Y' ---handles  regular delete 
	                  end               
		else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016.lh2_transaction_log stg 
) as stg  
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_transaction_log_b.site_code and  
stg.transaction_log_id = edw_target.lh2_transaction_log_b.transaction_log_id and  
stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_user_log_app_type_b
as
(
merge into edw_target.lh2_user_log_app_type_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.app_type_id ,  
	coalesce(stg.app_type_name,' ') as app_type_name ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_user_log_app_type as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.app_type_id = tgt.app_type_id)

when matched then 
update set 
orig_src_id =  stg.orig_src_id , 
app_type_name =  stg.app_type_name , 
src_change_id =  stg.src_change_id , 
dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
stg.orig_src_id , 
stg.site_code , 
stg.app_type_id , 
stg.app_type_name , 
stg.src_change_id , 
stg.dw_logical_delete_flag , 
stg.dw_modify_ts , 
stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
update  edw_target.lh2_user_log_app_type_b  
from edw_stage_016 .lh2_user_log_app_type stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_user_log_app_type_b.site_code and  
stg.site_code = edw_target.lh2_user_log_app_type_b.site_code and  
stg.app_type_id = edw_target.lh2_user_log_app_type_b.app_type_id
and  stg.change_type ='D' ;
);
--------------------------------------------------------------------------------

"Request Text"
create  macro edw_stage_016.m_lh2_user_log_event_type_b
as
(
merge into edw_target.lh2_user_log_event_type_b as tgt 
using 
( 
select  
stg.orig_src_id ,  
stg.site_code ,  
stg.event_type_id ,  
coalesce(stg.event_type_name,' ') as event_type_name ,  
stg.src_change_id ,  
stg.dw_logical_delete_flag ,  
stg.dw_modify_ts ,  
stg.dw_load_ts   
from   edw_stage_016.lh2_user_log_event_type as stg     
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.event_type_id = tgt.event_type_id)

when matched then 
update set 
orig_src_id =  stg.orig_src_id , 
event_type_name =  stg.event_type_name , 
src_change_id =  stg.src_change_id , 
dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
stg.orig_src_id , 
stg.site_code , 
stg.event_type_id , 
stg.event_type_name , 
stg.src_change_id , 
stg.dw_logical_delete_flag , 
stg.dw_modify_ts , 
stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d
 
update  edw_target.lh2_user_log_event_type_b  
from edw_stage_016 .lh2_user_log_event_type stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg. dw_modify_ts 
where 
stg.site_code = edw_target.lh2_user_log_event_type_b.site_code and  
stg.site_code = edw_target.lh2_user_log_event_type_b.site_code and  
stg.event_type_id = edw_target.lh2_user_log_event_type_b.event_type_id and  
stg.change_type ='D'  ; 
  
);
--------------------------------------------------------------------------------

"Request Text"
create   macro edw_stage_016.m_lh2_user_log_session_event_b
as
(
merge into edw_target.lh2_user_log_session_event_b as tgt 
using 
( 
select  
	stg.orig_src_id ,  
	stg.site_code ,  
	stg.session_event_id ,  
	stg.shiftid , 
	stg.shiftdate ,
	stg.shiftindex  ,
	coalesce(stg.sessionid,' ') as sessionid ,  
	coalesce(stg.session_event_username,' ') as session_event_username ,  
	coalesce(stg.machinename,' ') as machinename ,  
	stg.applicationtypeid ,  
	coalesce(stg.applicationversion,' ') as applicationversion ,  
	stg.eventtypeid ,  
	stg.eventtime ,  
	coalesce(stg.dispatcherprofile,' ') as dispatcherprofile ,  
	coalesce(stg.primarydispatcher,' ') as primarydispatcher ,  
	stg.src_change_id ,  
	stg.dw_logical_delete_flag ,  
	stg.dw_modify_ts ,  
	stg.dw_load_ts   
from   edw_stage_016.lh2_user_log_session_event as stg 
where stg.change_type in ('I','U')
) as stg 
on ( stg.site_code = tgt.site_code and 
stg.session_event_id = tgt.session_event_id )

when matched then 
update set 
 orig_src_id =  stg.orig_src_id , 
 shiftid =  stg.shiftid , 
 shiftdate =  stg.shiftdate , 
 shiftindex =  stg.shiftindex , 
 sessionid =  stg.sessionid , 
 session_event_username =  stg.session_event_username , 
 machinename =  stg.machinename , 
 applicationtypeid =  stg.applicationtypeid , 
 applicationversion =  stg.applicationversion , 
 eventtypeid =  stg.eventtypeid , 
 eventtime =  stg.eventtime , 
 dispatcherprofile =  stg.dispatcherprofile , 
 primarydispatcher =  stg.primarydispatcher , 
 src_change_id =  stg.src_change_id , 
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 
 dw_modify_ts =  stg.dw_modify_ts 

when not matched then 
insert values (
  stg.orig_src_id , 
  stg.site_code , 
  stg.session_event_id , 
  stg.shiftid , 
  stg.shiftdate , 
  stg.shiftindex , 
  stg.sessionid , 
  stg.session_event_username , 
  stg.machinename , 
  stg.applicationtypeid , 
  stg.applicationversion , 
  stg.eventtypeid , 
  stg.eventtime , 
  stg.dispatcherprofile , 
  stg.primarydispatcher , 
  stg.src_change_id , 
  stg.dw_logical_delete_flag , 
  stg.dw_modify_ts , 
  stg.dw_load_ts);
--  step 2 ( for  deleted  records)
--  it  is based on incrementaly  loaded records in  stage
--  includes all the change type   ---   d

update  edw_target.lh2_user_log_session_event_b 
from 
(
 select stg.site_code , 
 stg.session_event_id ,  
 stg.shiftid , 
 case  when stg.change_type in('D')     then
                      case 
                      when stg.shiftdate<(current_date-170) then 'A' 
                      else 'Y' ---handles  regular delete 
                      end               
    else 'U'---- for change type not in (i,u,d)
end as dw_logical_delete_flag,
stg.dw_modify_ts,  
stg.change_type 
from edw_stage_016.lh2_user_log_session_event stg 
) as stg 
set 
dw_logical_delete_flag = stg.dw_logical_delete_flag , 
dw_modify_ts = stg.dw_modify_ts 
where 
stg.site_code = edw_target.lh2_user_log_session_event_b .site_code and  
stg.session_event_id = edw_target.lh2_user_log_session_event_b .session_event_id and  
stg.change_type ='D' ;
);