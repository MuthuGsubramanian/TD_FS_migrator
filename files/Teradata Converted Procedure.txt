create or replace procedure freeport.edw_etl.lh2_dump_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$
 /****************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey 
* PURPOSE : Load the lh2_dump_c collection table from  lh2_dump_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_dump_b
*                      
* Usage :  
call edw_etl.lh2_dump_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' );
call edw_etl.lh2_dump_c_ds6_sp (null,null,null ,'Delta' )
 Procedure Steps:
 Initial: Set the procedure run time 
    Get the max of modify time from base table
            check  job execution mode and define the filter 
Step1: Delete the stage table
Step2: insert the data set into stage table based on the filter condition
Step3: merge into target table
Step4: Capture the deleted rows
Step5: Cleanup the target table 
Step6: update the di job contorl entry ts base table
* CREATE/CHANGE LOG : 
* DATE                     MOD BY                               GCC                           DESC
*-------------------------------------   -----------------------------------   -----------------------------------   
*    2019-03-08       Kali D         Initial version
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.)
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code
															Previous filter was made only with the driving table;
															If non-driving table gets refreshed there wont be any impact in this stored procedure 
															so driving table will be up to date whereas non-driving table will not get latest data
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure
*    *****************************************************************************************************************************************************/ 

try {
      //setting up the variables
//var proc_var_dw_modify_ts = snowflake.createStatement( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"} ).execute() ;
//https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html

var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1);
        
var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_dump_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_dump_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_dump_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1);
     
   if (extract_mode =='FULL')
        {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         }
   else 
        {
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                }
           
        //Sabarish S 2019-08-30 added as part of incremental load enhancement
        //return proc_var_ds6_base_max_dw_modify_ts;
        var proc_var_filter_list = `( shiftid , site_code ) in  (\
                                    select shiftid,site_code from edw_target.lh2_shift_dump_b   where dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_dump_tbars_array_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_dump_tmbars_array_b   where dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_dump_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_load_b   where dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_eqmt_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_loc_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_grade_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_dump_lift_array_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_dump_lift_dist_array_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_shift_oper_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
                                    select shiftid,site_code from edw_target.lh2_sum_shift_dump_b  where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`') ;`;
        //return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_dump_ds6;"} );
 
 
//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `  insert into edw_stage.lh2_dump_ds6 ( shiftindex, \
  shiftdate, \
  site_code, \
  cliid, \
  ddbkey, \
  dumpid, \
  bay, \
  blast, \
  dump_blast, \
  calctravti, \
  dist, \
  dumpingtim, \
  dumptons, \
  efh, \
  eoper, \
  excav, \
  excav_orig, \
  extraload, \
  grade, \
  hos, \
  idletime, \
  idmp, \
  intvl, \
  lift_down, \
  lift_up, \
  liftdist_d, \
  liftdist_u, \
  load, \
  loadnumber, \
  loadold, \
  loadrec, \
  loadtype, \
  loc, \
  measureton, \
  oper, \
  shiftlink, \
  timearrive, \
  timearrive_ts, \
  timedigest, \
  timedigest_ts, \
  timedump, \
  timedump_ts, \
  timeempty, \
  timeempty_ts, \
  truck, \
  truck_orig, \
  val_dmp, \
  gpsx, \
  gpsy, \
  dlock, \
  elock, \
  edlock, \
  rlock, \
  gpsstat, \
  tbars0, \
  tbars1, \
  tbars2, \
  tbars3, \
  "blend#", \
  blend, \
  "tmbars0#", \
  tmbars0, \
  "tmbars1#", \
  tmbars1, \
  "tmbars2#", \
  tmbars2, \
  "tmbars3#", \
  tmbars3, \
  "tmbars4#", \
  tmbars4, \
  "tmbars5#", \
  tmbars5, \
  system_version, \
  dw_logical_delete_flag, \
  dw_modify_ts, \
   dw_load_ts )\
 select distinct  shiftindex, \
   shiftdate, \
   site_code, \
   cliid, \
   ddbkey, \
   dumpid, \
   bay, \
   blast, \
   dump_blast, \
   calctravti, \
   dist, \
   dumpingtim, \
   dumptons, \
   efh, \
   eoper, \
   excav, \
   excav_orig, \
   extraload, \
   grade, \
   hos, \
   idletime, \
   idmp, \
   intvl, \
   lift_down, \
   lift_up, \
   liftdist_d, \
   liftdist_u, \
   load, \
   loadnumber, \
   loadold, \
   loadrec, \
   loadtype, \
   loc, \
   measureton, \
   oper, \
   shiftlink, \
   timearrive, \
   timearrive_ts, \
   timedigest, \
   timedigest_ts, \
   timedump, \
   timedump_ts, \
   timeempty, \
   timeempty_ts, \
   truck, \
   truck_orig, \
   val_dmp, \
   gpsx, \
   gpsy, \
   dlock, \
   elock, \
   edlock, \
   rlock, \
   gpsstat, \
   tbars0, \
   tbars1, \
   tbars2, \
   tbars3, \
  "blend#", \
  blend, \
  "tmbars0#", \
  tmbars0, \
  "tmbars1#", \
  tmbars1, \
  "tmbars2#", \
  tmbars2, \
  "tmbars3#", \
  tmbars3, \
  "tmbars4#", \
  tmbars4, \
  "tmbars5#", \
   tmbars5, \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
  timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_dump_ds6_etl \
where ` +  proc_var_filter_list ;

`
\
\
snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = `merge into edw_target.lh2_dump_c as tgt \
using \
( \
select  \
shiftindex ,  \
 shiftdate ,  \
 site_code ,  \
 cliid ,  \
 ddbkey ,  \
 dumpid ,  \
 bay ,  \
 blast ,  \
 dump_blast ,  \
 calctravti ,  \
 dist ,  \
 dumpingtim ,  \
 dumptons ,  \
 efh ,  \
 eoper ,  \
 excav ,  \
 excav_orig ,  \
 extraload ,  \
 grade ,  \
 hos ,  \
 idletime ,  \
 idmp ,  \
 intvl ,  \
 lift_down ,  \
 lift_up ,  \
 liftdist_d ,  \
 liftdist_u ,  \
 load ,  \
 loadnumber ,  \
 loadold ,  \
 loadrec ,  \
 loadtype ,  \
 loc ,  \
 measureton ,  \
 oper ,  \
 shiftlink ,  \
 timearrive ,  \
 timearrive_ts ,  \
 timedigest ,  \
 timedigest_ts ,  \
 timedump ,  \
 timedump_ts ,  \
 timeempty ,  \
 timeempty_ts ,  \
 truck ,  \
 truck_orig ,  \
 val_dmp ,  \
 gpsx ,  \
 gpsy ,  \
 dlock ,  \
 elock ,  \
 edlock ,  \
 rlock ,  \
 gpsstat ,  \
 tbars0 ,  \
 tbars1 ,  \
 tbars2 ,  \
 tbars3 ,  \
 "blend#" ,  \
 blend ,  \
 "tmbars0#" ,  \
 tmbars0 ,  \
 "tmbars1#" ,  \
 tmbars1 ,  \
 "tmbars2#" ,  \
 tmbars2 ,  \
 "tmbars3#" ,  \
 tmbars3 ,  \
 "tmbars4#" ,  \
 tmbars4 ,  \
 "tmbars5#" ,  \
 tmbars5 ,  \
 system_version ,  \
 dw_logical_delete_flag ,  \
 dw_modify_ts ,  \
 dw_load_ts   \
from  edw_stage.lh2_dump_ds6 \
) as stg \
ON ( stg.shiftindex = tgt.shiftindex and \
stg.cliid = tgt.cliid and \
stg.ddbkey = tgt.ddbkey)\
\
WHEN MATCHED THEN \
UPDATE SET \
shiftdate =  stg.shiftdate , \
 site_code =  stg.site_code , \
 dumpid =  stg.dumpid , \
 bay =  stg.bay , \
 blast =  stg.blast , \
 dump_blast =  stg.dump_blast , \
 calctravti =  stg.calctravti , \
 dist =  stg.dist , \
 dumpingtim =  stg.dumpingtim , \
 dumptons =  stg.dumptons , \
 efh =  stg.efh , \
 eoper =  stg.eoper , \
 excav =  stg.excav , \
 excav_orig =  stg.excav_orig , \
 extraload =  stg.extraload , \
 grade =  stg.grade , \
 hos =  stg.hos , \
 idletime =  stg.idletime , \
 idmp =  stg.idmp , \
 intvl =  stg.intvl , \
 lift_down =  stg.lift_down , \
 lift_up =  stg.lift_up , \
 liftdist_d =  stg.liftdist_d , \
 liftdist_u =  stg.liftdist_u , \
 load =  stg.load , \
 loadnumber =  stg.loadnumber , \
 loadold =  stg.loadold , \
 loadrec =  stg.loadrec , \
 loadtype =  stg.loadtype , \
 loc =  stg.loc , \
 measureton =  stg.measureton , \
 oper =  stg.oper , \
 shiftlink =  stg.shiftlink , \
 timearrive =  stg.timearrive , \
 timearrive_ts =  stg.timearrive_ts , \
 timedigest =  stg.timedigest , \
 timedigest_ts =  stg.timedigest_ts , \
 timedump =  stg.timedump , \
 timedump_ts =  stg.timedump_ts , \
 timeempty =  stg.timeempty , \
 timeempty_ts =  stg.timeempty_ts , \
 truck =  stg.truck , \
 truck_orig =  stg.truck_orig , \
 val_dmp =  stg.val_dmp , \
 gpsx =  stg.gpsx , \
 gpsy =  stg.gpsy , \
 dlock =  stg.dlock , \
 elock =  stg.elock , \
 edlock =  stg.edlock , \
 rlock =  stg.rlock , \
 gpsstat =  stg.gpsstat , \
 tbars0 =  stg.tbars0 , \
 tbars1 =  stg.tbars1 , \
 tbars2 =  stg.tbars2 , \
 tbars3 =  stg.tbars3 , \
 "blend#" =  stg."blend#" , \
 blend =  stg.blend , \
 "tmbars0#" =  stg."tmbars0#" , \
 tmbars0 =  stg.tmbars0 , \
 "tmbars1#" =  stg."tmbars1#" , \
 tmbars1 =  stg.tmbars1 , \
 "tmbars2#" =  stg."tmbars2#" , \
 tmbars2 =  stg.tmbars2 , \
 "tmbars3#" =  stg."tmbars3#" , \
 tmbars3 =  stg.tmbars3 , \
 "tmbars4#" =  stg."tmbars4#" , \
 tmbars4 =  stg.tmbars4 , \
 "tmbars5#" =  stg."tmbars5#" , \
 tmbars5 =  stg.tmbars5 , \
 system_version =  stg.system_version , \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag , \
 dw_modify_ts =  stg.dw_modify_ts \
\
WHEN NOT MATCHED THEN \
INSERT VALUES (\
 stg.shiftindex , \
  stg.shiftdate , \
  stg.site_code , \
  stg.cliid , \
  stg.ddbkey , \
  stg.dumpid , \
  stg.bay , \
  stg.blast , \
  stg.dump_blast , \
  stg.calctravti , \
  stg.dist , \
  stg.dumpingtim , \
  stg.dumptons , \
  stg.efh , \
  stg.eoper , \
  stg.excav , \
  stg.excav_orig , \
  stg.extraload , \
  stg.grade , \
  stg.hos , \
  stg.idletime , \
  stg.idmp , \
  stg.intvl , \
  stg.lift_down , \
  stg.lift_up , \
  stg.liftdist_d , \
  stg.liftdist_u , \
  stg.load , \
  stg.loadnumber , \
  stg.loadold , \
  stg.loadrec , \
  stg.loadtype , \
  stg.loc , \
  stg.measureton , \
  stg.oper , \
  stg.shiftlink , \
  stg.timearrive , \
  stg.timearrive_ts , \
  stg.timedigest , \
  stg.timedigest_ts , \
  stg.timedump , \
  stg.timedump_ts , \
  stg.timeempty , \
  stg.timeempty_ts , \
  stg.truck , \
  stg.truck_orig , \
  stg.val_dmp , \
  stg.gpsx , \
  stg.gpsy , \
  stg.dlock , \
  stg.elock , \
  stg.edlock , \
  stg.rlock , \
  stg.gpsstat , \
  stg.tbars0 , \
  stg.tbars1 , \
  stg.tbars2 , \
  stg.tbars3 , \
  stg."blend#" , \
  stg.blend , \
  stg."tmbars0#" , \
  stg.tmbars0 , \
  stg."tmbars1#" , \
  stg.tmbars1 , \
  stg."tmbars2#" , \
  stg.tmbars2 , \
  stg."tmbars3#" , \
  stg.tmbars3 , \
  stg."tmbars4#" , \
  stg.tmbars4 , \
  stg."tmbars5#" , \
  stg.tmbars5 , \
  stg.system_version , \
  stg.dw_logical_delete_flag , \
  stg.dw_modify_ts , \
  stg.dw_load_ts)`;

snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_dump_c  as tgt \
set dw_logical_delete_flag = 'Y' ,\
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where \
tgt.dw_logical_delete_flag <>'Y'\
and not exists\
      (select 1\
      from edw_stage.lh2_dump_ds6 as stg \
      where stg.shiftindex = tgt.shiftindex \
      and stg.cliid = tgt.cliid \
      and stg.ddbkey = tgt.ddbkey \
         )  \
and  exists\
     (\
     select 'X'\
     from edw_stage.lh2_dump_ds6  stg1 \
     where  stg1.shiftindex = tgt.shiftindex\
     and stg1.cliid = tgt.cliid\
     )   ; ` ;

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = ` delete  from edw_target.lh2_dump_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_dump_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_dump_c_ds6_sp'; `;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
;




create or  replace procedure freeport.edw_etl.lh2_deltac_sum_c_sp  ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$


/**************************************************************************************************************************************************** 
* PK of extension table: cliid , shiftindex, ddbkey ( Is actually driving table's ID columns) 
* PURPOSE : Load the lh2_deltac_sum_c_sp collection table from  lh2_deltac_sum_etl view based on dw_modify_ts of base table  edw_target.lh2_load_c  
*                   
* Usage :   
call   edw_etl.lh2_deltac_sum_c_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,43195,1554590','FULL' ); \
call   edw_etl.lh2_deltac_sum_c_sp (null,null,null ,'Delta' ) 
 Procedure Steps: 
 Initial: Set the procedure run time  
    Get the max of modify time from base table
            check  job execution mode and define the filter  
--Step 1 : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
--Step 2 : Delete lh_target_load_shift_new table for shiftindex and cliid, 
			for which we are going to rebuild the table 
--Step 3: Delete lh_target_time_shift_new table for shiftindex and cliid,
			for which we are going to rebuild the table 
--Step 4 : Insert lh_target_load_shift_new table for shiftindex and cliid used as parameter for the procedure 
--Step 5 : Insert lh_target_time_shift_new table for shiftindex and cliid used as parameter for the procedure 
--Step 6: Delete the delta c  stage table
--Step 7: insert the data set into stage table based on the filter condition
--Step 8: merge into target table
--Step 9: Capture the deleted rows
--Step 10: Cleanup the target table 
--Step 11: update the di job contorl entry ts base table 

While upgrading Dispatch 6 for the last site, We can remove the process of restricting the number of shift to be process. \
Currently we have legacy job which is causing us to reprocess 30 days of data,. 

* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D                Initial version \
*    2019-07-30       Anandhi P         Included timestamp columns (timefull_ts, load_timearrive_ts, timeload_ts, beginspot_ts, dump_timearrive_ts, timedump_ts, timeempty_ts) \
"*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.) 
"															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code 
"															Previous filter was made only with the driving table; 
"															If non-driving table gets refreshed there wont be any impact in this stored procedure  
"															so driving table will be up to date whereas non-driving table will not get latest data 
"															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure 
*    *****************************************************************************************************************************************************/   \

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_deltac_sum_c_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_deltac_sum_c_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

//-- commented because of performance issue set proc_var_rt_max_dw_load_ts =  (select max(dw_modify_ts) from edw_target.lh2_load_c   where shiftindex=shiftindex and dw_logical_delete_flag ='N'  ); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;       
//--Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_deltac_sum_shift_pre_stage "} );

 var_sql_insert_pre_stage_ds6 = `  insert into edw_stage.lh2_deltac_sum_shift_pre_stage  \
 (cliid,shiftindex)  \
 select	 cliid ,shiftindex \
 from edw_target.lh2_load_c \   
 where	shiftindex = shiftindex  \
 and dw_logical_delete_flag ='N' \
 and ` + proc_var_filter_list  +` group by 1,2 \ 
union \
 select	 cliid ,shiftindex \  
 from edw_target.lh2_dump_c   \
 where	shiftindex = shiftindex \ 
 and dw_logical_delete_flag = 'N' \
 and ` + proc_var_filter_list  +` group by 1,2 \ 
union \
 select	 cliid ,shiftindex \ 
 from edw_target.lh2_location_c   \
 where	shiftindex = shiftindex \
 and dw_logical_delete_flag = 'N' \
 and ` + proc_var_filter_list  +` group by 1,2 \ 
union \					 
 select	 cliid ,shiftindex \ 
 from edw_target.lh2_oper_list_c   \
 where	shiftindex = shiftindex \ 
and dw_logical_delete_flag = 'N' \
 and ` + proc_var_filter_list  +` group by 1,2 \ 
		;` ; 
 snowflake.execute( {sqlText: var_sql_insert_pre_stage_ds6 } );		

  
//  	--                 if  (select cast( proc_var_rt_max_dw_load_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time) 
 //   --                        then
  //  --                      set proc_var_rt_max_dw_load_ts = proc_var_di_last_run_ts ;
  //  --                end if;
       } 
 else 
 {
 //--Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_deltac_sum_shift_pre_stage "} );
 var_sql_insert_pre_stage_ds6 = `  insert into edw_stage.lh2_deltac_sum_shift_pre_stage  \
 (cliid,shiftindex)  \
 select		 cliid ,shiftindex \
 from edw_target.lh2_load_c   \
 where	shiftindex = shiftindex \
 and dw_logical_delete_flag = 'N' \ 
 and dw_modify_ts >=  timestamp ' + proc_var_di_last_run_ts  +'  group by 1,2 \ 
Union \
 select	 cliid ,shiftindex'  
 from edw_target.lh2_dump_c   ' 
 where	shiftindex = shiftindex \
 and dw_logical_delete_flag = 'N' \ 
 and dw_modify_ts >=  timestamp ' + proc_var_di_last_run_ts  +'  group by 1,2 \ 
Union \
 select	 cliid ,shiftindex'  
 from edw_target.lh2_location_c   ' 
 where	shiftindex = shiftindex \
 and dw_logical_delete_flag = 'N' \ 
 and dw_modify_ts >=  timestamp ' + proc_var_di_last_run_ts  +'  group by 1,2 \ 
Union \
 select	 cliid ,shiftindex'  
 from edw_target.lh2_oper_list_c   ' 
 where	shiftindex = shiftindex \
 and dw_logical_delete_flag = 'N' \ 
 and dw_modify_ts >=  timestamp ' + proc_var_di_last_run_ts  +'  group by 1,2 \ 
		;` ; 
snowflake.execute( {sqlText: var_sql_insert_pre_stage_ds6 } );	
}


//--Step 2 : Delete lh_target_load_shift_new table for shiftindex and cliid, for which we are going to rebuilt the table
snowflake.execute( {sqlText: " delete from  prod_pddw.lh_target_load_shift_new  where ( shiftindex, cliid) in   ( select shiftindex, cliid from  edw_stage.lh2_deltac_sum_shift_pre_stage group by 1,2 ) ;"} );	

 //--Step 3: Delete lh_target_time_shift_new table for shiftindex and cliid, for which we are going to rebuilt the table
snowflake.execute( {sqlText: " delete from  prod_pddw.lh_target_time_shift_new  where ( shiftindex, cliid) in   ( select shiftindex, cliid from  edw_stage.lh2_deltac_sum_shift_pre_stage  group by 1,2 ) ;"} );	


//-- Do table inserts into shift tables from base tables via shiftindex 
//--  prod_pddw.lh_target_load_shift ETL 
//--Step 4 : Insert lh_target_load_shift_new table for shiftindex and cliid used as parameter for the procedure 
 var_sql_insert_load_shift_new_ds6 = `  insert into prod_pddw.lh_target_load_shift_new \
(\ 
cliid \
,"eqmttype#" \
,shiftindex \
,site_code \
,fleet \
,ops_portal_euip_grp \
,ops_portal_equip_grp_id \
,size_cu_yd \
,secs_per_pass \
,idle_time \
,spot_time \
,load_time \
,dump_time_dump \
,dump_time_crusher \
,dump_time_upper_limiit \
,spot_time_upper_limiit \
,flat_loaded \
,down_loaded \
,up_loaded \
,flat_empty \
,up_empty \
,down_empty \
,hours_per_day \
,min_payload \
,target_payload \
,target_payload_range \
,measure_43_constant \
,efh_conv_downhill \
,efh_conv_uphill \
,payload_comp_target \
,lower_tar_prod \
,upper_tar_prod \
,last_modified_ts \
 		) \
select  \
t.cliid \
,tr."eqmttype#" \
, t.shiftindex \
, tr.site_code  \
, tr.fleet  \
, tr.ops_portal_euip_grp  \
, tr.ops_portal_equip_grp_id  \
, tr.size_cu_yd  \
, tr.secs_per_pass  \
, tr.idle_time  \
, tr.spot_time  \
, tr.load_time  \
, tr.dump_time_dump  \
, tr.dump_time_crusher \ 
, tr.dump_time_upper_limiit  \
, tr.spot_time_upper_limiit  \
, tr.flat_loaded  \
, tr.down_loaded  \
, tr.up_loaded  \
, tr.flat_empty  \
, tr.up_empty  \
, tr.down_empty  \
, tr.hours_per_day \ 
, tr.min_payload  \
, tr.target_payload \ 
, tr.target_payload_range  \
, tr.measure_43_constant  \
, tr.efh_conv_downhill  \
, tr.efh_conv_uphill  \
, tr.payload_comp_target  \
, tr.lower_tar_prod  \
, tr.upper_tar_prod  \
 ,timestamp '`+ proc_var_dw_modify_ts +`'  as last_modified_ts  \
from prod_pddw.lh_target_load_base_new tr  \
inner join   edw_stage.lh2_deltac_sum_shift_pre_stage  as t  \
on tr.cliid = t.cliid \
where t.shiftindex >= tr.start_shiftindex  \
and t.shiftindex <= tr.end_shiftindex ; `;
snowflake.execute( {sqlText: var_sql_insert_load_shift_new_ds6 + ";"} );


//--  prod_pddw.lh_target_time_shift ETL 
//--Step 5 : Insert lh_target_time_shift_new table for shiftindex and cliid used as parameter for the procedure 
 var_sql_insert_time_shift_new_ds6 = ` insert into prod_pddw.lh_target_time_shift_new \
(\ 
cliid \
,""shovel_eqmttype#"" \
,ops_portal_shvl_grp_id \
,""truck_eqmttype#"" \
,ops_portal_trck_grp_id \
,shiftindex \
,site_code \
,target_load_time \
,last_modified_ts \
		) \
select  \
	t.cliid 
,tr.""shovel_eqmttype#"" 
,tr.ops_portal_shvl_grp_id 
,tr.""truck_eqmttype#"" 
,tr.ops_portal_trck_grp_id 
,t.shiftindex 
,tr.site_code 
,tr.target_load_time 
 ,timestamp '`+ proc_var_dw_modify_ts +`' as  last_modified_ts 
from prod_pddw.lh_target_time_base_new tr  \
inner join   edw_stage.lh2_deltac_sum_shift_pre_stage  as t  \
on tr.cliid = t.cliid \
where t.shiftindex >= tr.start_shiftindex  \
and t.shiftindex <= tr.end_shiftindex ;`;
snowflake.execute( {sqlText: var_sql_insert_time_shift_new_ds6 + ";"} );

//--Step 6: Delete the delta c  stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_deltac_sum_pre_stage;"} );

//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate  edw_stage.lh2_deltac_sum;"} );


//--Step 7: insert the data set into stage table based on the filter condition
  var_sql_insert_stage_ds6 = ` insert into edw_stage.lh2_deltac_sum_pre_stage (  \
shiftindex, \
shiftdate, \
site_code, \
cliid, \
ddbkey, \
"year#", \
"month#", \
months, \
shift, \
"shift#", \
"crew#", \
crew, \
harvhos, \
digtype, \
dipper, \
payload, \
idletime, \
spottime, \
loadtime, \
dumpingtime, \
crusheridle, \
travelempty, \
travelloaded, \
totalcycle, \
loads_disteh, \
loads_lift_down, \
loads_lift_up, \
dumps_dist, \
dumps_lift_down, \
dumps_lift_up, \
hos, \
timefull, \
timefull_ts, \
timeloaded, \
excav, \
eoper, \
truck, \
toperid, \
toper, \
"load#", \
material, \
bench, \
"unit#", \
unit, \
dumpname, \
load_seq_no, \
grade, \
extraload, \
loadtype, \
loadtons, \
measuretons_shovel, \
over_truck_flag, \
under_truck_flag, \
dump_flag, \
shovel_idle, \
crusher_dump_flag, \
dump_number, \
ldump_hos, \
dump_hos, \
dump_oper_id, \
eliftup, \
eliftdown, \
distloaded, \
fliftup, \
fliftdown, \
distempty, \
emptyhaul, \
fullhaul, \
load_timearrive, \
load_timearrive_ts, \
timeload, \
timeload_ts, \
beginspot, \
beginspot_ts, \
hangtime, \
dump_timearrive, \
dump_timearrive_ts, \
timedump, \
timedump_ts, \
timeempty, \
timeempty_ts, \
material_name, \
start_date_ts, \
end_date_ts, \
system_version, \
dw_logical_delete_flag, \
dw_modify_ts, \
dw_load_ts) \
select \
 //-- We have duplicate in oper_list table
loads.shiftindex, \
loads.shiftdate , \
loads.site_code , \
loads.cliid , \
loads.ddbkey , \
extract(year from shift_date.shiftdate) as "year#", --- year number \
shift_date."month#", ---month number \
shift_date.months, ---month \
shift_date.shift, ---shift (day - night) \
shift_date."shift#", ---shift numer ( 1 - 2) \
shift_date."crew#", ---crew number \
shift_date.crew, ---crew name \
(case \
			when shift_date."shift#" = 2 
		then loads.hos + 12 
			else loads.hos 
end \
) as harvhos,  \
null as digtype, \
0 as dipper,-- was harded in bteq 4B \
case when loads.cliid in (32578, 19259, 1554590, 42468) 
coalesce(nullif(loads.dcstons,0),dumps.measureton)  / (1.10231)  \
else coalesce(nullif(loads.dcstons,0),dumps.measureton)  end as payload,  -- tons in truck \
zeroifnull(loads.queuetime / 60) as idletime, --- truck idle time at shovel \
zeroifnull(loads.spottime / 60) as spottime, --- truck spot time at shovel \
zeroifnull(loads.loadingtim / 60) as loadtime, --- time to load truck \
zeroifnull(case \
	when loc."unit#" in (3, 5) 
	then (zeroifnull(dumps.dumpingtim) + zeroifnull(dumps.idletime)) / 60.0
	else 
end) as dumpingtime, --- dumping time at waste and stockpile locations \
zeroifnull(case \
	when loc."unit#" = 4 
	then (zeroifnull(dumps.dumpingtim)  + zeroifnull(dumps.idletime)) / 60.0
	else 
end) as crusheridle, --- dumping time at crushers \
zeroifnull(loads.emptyhaul / 60) as travelempty, ---actual travel time empty \
zeroifnull(loads.fullhaul / 60) as travelloaded, ---actual travel time loaded \
(dumpingtime + crusheridle + zeroifnull(loads.queuetime / 60) + zeroifnull(loads.spottime / 60)  + zeroifnull(loads.loadingtim / 60) + zeroifnull(loads.emptyhaul / 60)  + zeroifnull(loads.fullhaul / 60) )  as totalcycle, \
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.disteh      / (3.28084) else loads.disteh      end  as loads_disteh,  \
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_down / (3.28084) else loads.lift_down end  / 50 as loads_lift_down, \
(case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_up / (3.28084) else loads.lift_up end / 50) as loads_lift_up, \
(case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.dist/ (3.28084) else dumps.dist end) dumps_dist , \
(case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_down / (3.28084) else dumps.lift_down end / 50) dumps_lift_down, \
(case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_up / (3.28084) else dumps.lift_up end / 50)dumps_lift_up, \
loads.hos, ---hour of shift \
loads.timefull, ---time truck loaded (seconds into  shift) \
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(loads.timefull as number) / 60 as  interval minute(4)) + cast ( (cast(loads.timefull as number)  mod 60 ) as interval second(4,3)) as timefull_ts, --Included on 07/29/2019 \
((((shift_date.starts + loads.timefull)(int)) / 3600) (format 'zzzz99')) \
|| ((((shift_date.starts + loads.timefull)(int)) mod 3600) / 60 (format ':99')) \
|| (((shift_date.starts + loads.timefull)(int)) mod 60 (format ':99')) as timeloaded, -- Only adding hours to start time  \
loads.excav, --- shovel \
loads.eoper, \
loads.truck, \
truck_oper.operid as toperid, \
truck_oper.name as toper, \
loads.load as "load#", --- material number \
mat.name as material, --Load_type table column name = Material \
loads.loc as bench, --- shovel bench name \
loc."unit#", --- location unit number (3, 4, 5) \
loc.unit, --- location unit (waste,  \
dumps.loc as dumpname, --- name of dumping location      \
0 as load_seq_no, \
loads.grade, \
loads.extraload, \
loads.loadtype, \
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.loadtons_us / (1.10231) else loadtons_us end as loadtons, \
0 as measuretons_shovel, \
loads.ot as over_truck_flag, \
loads.ut as under_truck_flag, \
loads.dmp as dump_flag, \
((loads.idletime / 60) + (loads.hangtime / 60)) as shovel_idle, \
(case \
	when loc."unit#" = 4 
	then 1 
	else 
end) as crusher_dump_flag, \
dumps.dumpid as dump_number, \
null as ldump_hos, \
dumps.hos as dump_hos, \
dumps.oper as dump_oper_id, \
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_up/ (3.28084) else loads.lift_up     end as eliftup, ---feet traveled empty up hill \
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.lift_down /(3.28084) else loads.lift_down end  as eliftdown, ---feet traveled empty down hill \
case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.dist/ (3.28084) else dumps.dist end as distloaded, ---total feet traveled loaded to dumping location \
case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_up /(3.28084) else dumps.lift_up end as fliftup, ---feet traveled loaded up hill \
case when dumps.cliid in (32578, 19259, 1554590, 42468) then dumps.lift_down /(3.28084) else dumps.lift_down end as fliftdown, ---feet traveled loaded down hill \
case when loads.cliid in (32578, 19259, 1554590, 42468) then loads.disteh / (3.28084) else loads.disteh      end  as distempty, ---total feet traveled empty to shovel \
zeroifnull(loads.emptyhaul) as emptyhaul, \
zeroifnull(loads.fullhaul) as fullhaul, \
loads.timearrive as load_timearrive, \
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(loads.timearrive as number) / 60 as  interval minute(4)) + cast ( (cast(loads.timearrive as number)  mod 60 ) as interval second(4,3)) as load_timearrive_ts, --Included on 07/29/2019 \
loads.timeload as timeload, \
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(loads.timeload as number) / 60 as  interval minute(4)) + cast ( (cast(loads.timeload as number)  mod 60 ) as interval second(4,3)) as timeload_ts, --Included on 07/29/2019 \
zeroifnull(loads.beginspot) as beginspot, \
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(zeroifnull(loads.beginspot) as number) / 60 as  interval minute(4)) + cast ( (cast(zeroifnull(loads.beginspot) as number)  mod 60 ) as interval second(4,3)) as beginspot_ts, --Included on 07/29/2019 \
zeroifnull(loads.hangtime) as hangtime, \
dumps.timearrive as dump_timearrive, \
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(dumps.timearrive as number) / 60 as  interval minute(4)) + cast ( (cast(dumps.timearrive as number)  mod 60 ) as interval second(4,3)) as dump_timearrive_ts, --Included on 07/29/2019 \
dumps.timedump as timedump, \
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(dumps.timedump as number) / 60 as  interval minute(4)) + cast ( (cast(dumps.timedump as number)  mod 60 ) as interval second(4,3)) as timedump_ts, --Included on 07/29/2019 \
dumps.timeempty as timeempty, \
cast(shift_date.start_date_ts as timestamp(0)) + cast (cast(dumps.timeempty as number) / 60 as  interval minute(4)) + cast ( (cast(dumps.timeempty as number)  mod 60 ) as interval second(4,3)) as timeempty_ts, --Included on 07/29/2019 \
mat.colloquial_name as  material_name, \
shift_date.start_date_ts, \
shift_date.end_date_ts , \
loads.system_version, \
'N' as dw_logical_delete_flag, \
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
  timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts \
--select loads.site_code\
from \
pddw.lh_load as loads \
-- filter  condition to restict the number of shift\
inner join edw_stage.lh2_deltac_sum_shift_pre_stage stg \
on stg.cliid = loads.cliid \
and stg.shiftindex = loads.shiftindex \

inner join \
pddw.lh_shift_date2_view as shift_date \
on loads.shiftindex = shift_date.shiftindex \
and loads.cliid = shift_date.cliid \

inner join \
pddw.lh_dump as dumps \
on loads.shiftindex = dumps.shiftindex \
and loads.dumprec = dumps.ddbkey \
and loads.cliid = dumps.cliid \

inner join \
pddw.lh_location as loc \
on dumps.shiftindex = loc.shiftindex \
and dumps.cliid = loc.cliid \
and dumps.loc = loc.locid \


inner join  \
pddw.lh_oper_list as truck_oper \
on loads.shiftindex = truck_oper.shiftindex \
and loads.cliid = truck_oper.cliid \
and loads.oper = truck_oper.operid \

inner join \
app_ops_portal.load_type as mat \
on loads.load = mat.num \
and loads.cliid = mat.cliid \

where \
-- load where dump is completed
loads.extraload <>1 \
and loads.dumprec <> 
and loads.loadtype <>1 \
and dumps.loadtype <> 1 \
; `;
snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 

 var_sql_insert_stage2_ds6 = `insert into edw_stage.lh2_deltac_sum \
(shiftindex, \
shiftdate, \
site_code, \
cliid, \
ddbkey, \
"year#", \
"month#", \
months, \
shift, \
"shift#", \
"crew#", \
crew, \
harvhos, \
digtype, \
shvtype, \
dipper, \
trktype, \
payload, \
idletime, \
spottime, \
loadtime, \
dumpingtime, \
crusheridle, \
travelempty, \
travelloaded, \
totalcycle, \
calctravempty, \
calctravloaded, \
hos, \
timefull, \
timefull_ts, \
timeloaded, \
excav, \
soperid, \
soper, \
truck, \
toperid, \
toper, \
"load#", \
material, \
bench, \
"unit#", \
unit, \
dumpname, \
idledelta, \
spotdelta, \
loaddelta, \
dumpdelta, \
et_delta, \
lt_delta, \
delta_c, \
toavgdeltac, \
tostdevdeltac, \
toavgidledelta, \
tostdevidledelta, \
toavgspotdelta, \
tostdevspotdelta, \
toavgloaddelta, \
tostdevloaddelta, \
toavgetdelta, \
tostdevetdelta, \
toavgltdelta, \
tostdevltdelta, \
toavgdumpdelta, \
tostdevdumpdelta, \
vtodeltac3, \
load_seq_no, \
grade, \
extraload, \
loadtype, \
loadtons, \
measuretons_shovel, \
over_truck_flag, \
under_truck_flag, \
dump_flag, \
shovel_idle, \
crusher_dump_flag, \
dump_number, \
ldump_hos, \
dump_hos, \
dump_oper_id, \
"shovel_eqmttype#", \
"truck_eqmttype#", \
"shvl_ops_prtl_equip_group_no#", \
"trk_ops_prtl_equip_group_no#", \
shovel_idledelta, \
eliftup, \
eliftdown, \
distloaded, \
fliftup, \
fliftdown, \
distempty, \
emptyhaul, \
load_timearrive, \
load_timearrive_ts, \
timeload, \
timeload_ts, \
beginspot, \
beginspot_ts, \
hangtime, \
dump_timearrive, \
dump_timearrive_ts, \
timedump, \
timedump_ts, \
timeempty, \
timeempty_ts, \
material_name, \
start_date_ts, \
end_date_ts, \
system_version, \
dw_logical_delete_flag, \
dw_modify_ts, \
dw_load_ts) \
select \
 -- We have duplicate in oper_list table\
loads.shiftindex, \
loads.shiftdate , \
loads.site_code , \
loads.cliid , \
loads.ddbkey , \
loads."year#", --- year number \
loads."month#", ---month number \
loads.months, ---month \
loads.shift, ---shift (day - night) \
loads."shift#", ---shift numer ( 1 - 2) \
loads."crew#", ---crew number \
loads.crew, ---crew name \
loads.harvhos,  \
loads.digtype, \
-- calculate in stage 2 \
equip_list_excav.ops_prtl_equip_group as shvtype, -- shovel group \
loads.dipper,-- was harded in bteq 4B \
-- calculate in stage 2 \
equip_list_truck.ops_prtl_equip_group as trktype, -- Truck group \
loads.payload,  -- tons in truck \
loads.idletime, --- truck idle time at shovel \
loads.spottime, --- truck spot time at shovel \
loads.loadtime, --- time to load truck \
loads.dumpingtime, --- dumping time at waste and stockpile locations \
loads.crusheridle, --- dumping time at crushers \
loads.travelempty, ---actual travel time empty \
loads.travelloaded, ---actual travel time loaded \
loads.totalcycle, \
--(loads.lift_up / 50) as adv_empty, ---number of benches traveled up empty\
--(loads.lift_down / 50) as fav_empty, ---number of benches traveled down empty\
--(dumps.lift_up / 50) as adv_loaded, ---number of benches traveled up loaded\
--(dumps.lift_down / 50) as fav_loaded, ---number of benches traveled down empty\
--(((distempty- ((fav_empty+adv_empty)*500))*60/5280/speed.flat_empty + fav_empty*500*60/5280/speed.down_empty + adv_empty*500*60/5280/speed.up_empty))  	  As CalcTravEmpty,\
((loads_disteh  -  \
(loads_lift_down  \
+ loads_lift_up )*500)*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end/speed.flat_empty) \
+ (loads_lift_down) *500*60/case when loads.cliid in (32578, 19259,22362, 1554590, 42468) then 1000 else 5280 end/speed.down_empty  \
+ (loads_lift_up)*500*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end/speed.up_empty  as calctravempty, \
--(((distloaded-((fav_loaded+adv_loaded)*500))*60/5280/speed.flat_loaded + fav_loaded*500*60/5280/speed.down_loaded + adv_loaded*500*60/5280/speed.up_loaded)) 	  As calcTravLoaded,\
(dumps_dist  \
- (( \
    (dumps_lift_down)  \
	+ (dumps_lift_up) 
	) * 50.0
	) 
	)*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end /speed.flat_loaded \
+ (dumps_lift_down) *500*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end /speed.down_loaded \
+ (dumps_lift_up)*500*60/case when loads.cliid in (32578, 19259, 22362,1554590, 42468) then 1000 else 5280 end /speed.up_loaded as calctravloaded, \
loads.hos, ---hour of shift \
loads.timefull, ---time truck loaded (seconds into  shift) \
loads.timefull_ts,  \
loads.timeloaded, -- Only adding hours to start time  \
loads.excav, --- shovel \
excav_oper.operid as soperid, \
excav_oper.name as soper, \
loads.truck, \
loads.toperid, \
loads.toper, \
loads."load#", --- material number \
loads.material, --Load_type table column name = Material \
loads.bench, --- shovel bench name \
loads."unit#", --- location unit number (3, 4, 5) \
loads.unit, --- location unit (waste,  \
loads.dumpname, --- name of dumping location      \
loads.idletime - truck_std_time.idle_time as idledelta, \
loads.spottime - truck_std_time.spot_time as spotdelta, \
loads.loadtime  - excav_std_load_time.target_load_time as loaddelta, \
(case \
when	loads."unit#"=4 
-- crusheridle and dumpingtime are calculated above\
then crusheridle - truck_std_time.dump_time_crusher \
else dumpingtime - truck_std_time.dump_time_dump \
end) as dumpdelta, \
-- calctravempty and calctravloaded are calculated above\
zeroifnull(loads.emptyhaul / 60)  - calctravempty as et_delta, \
zeroifnull(loads.fullhaul / 60) - calctravloaded as lt_delta, \
(case \
when	loads."unit#" in(3,5)  \
totalcycle  \
- (calctravempty + calctravloaded + truck_std_time.idle_time + truck_std_time.spot_time + excav_std_load_time.target_load_time + truck_std_time.dump_time_dump) \
else \	 
totalcycle  \
- (calctravempty + calctravloaded + truck_std_time.idle_time + truck_std_time.spot_time + excav_std_load_time.target_load_time + truck_std_time.dump_time_crusher) \
end) as delta_c, \
avg(delta_c) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgdeltac,         \
stddev_samp(delta_c) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as tostdevdeltac, \
avg(idledelta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgidledelta, \
stddev_samp(idledelta)over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevidledelta, \
avg(spotdelta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgspotdelta, \
stddev_samp(spotdelta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as tostdevspotdelta, \
avg(loaddelta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgloaddelta, \
stddev_samp(loaddelta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as tostdevloaddelta, \
avg(et_delta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgetdelta, \
stddev_samp(et_delta)over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevetdelta, \
avg(lt_delta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex ) as toavgltdelta, \
stddev_samp(lt_delta) over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevltdelta, \
avg(dumpdelta)over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as toavgdumpdelta, \
stddev_samp(dumpdelta)over(partition by loads.cliid,loads.shiftindex,loads."crew#", loads.toperid,loads.truck order by  loads.cliid,loads.shiftindex )  as tostdevdumpdelta, \
(case \
when	delta_c <= toavgdeltac + (tostdevdeltac*3)	and delta_c >= toavgdeltac - (tostdevdeltac*3) \
then 'Y' \
else 'N' \
end) as vtodeltac3, \
loads.load_seq_no, \
loads.grade, \
loads.extraload, \
loads.loadtype, \
loads.loadtons, \
loads.measuretons_shovel, \
loads.over_truck_flag, \
loads.under_truck_flag, \
loads.dump_flag, \
loads.shovel_idle, \
loads.crusher_dump_flag, \
loads.dump_number, \
loads. ldump_hos, \
loads.dump_hos, \
loads.dump_oper_id, \
equip_list_excav.lh_equip_class as "shovel_eqmttype#", -- shovel group \
equip_list_truck.lh_equip_class as "truck_eqmttype#", -- Truck group \
equip_list_excav.ops_prtl_equip_group_no  as "shvl_ops_prtl_equip_group_no#", \
equip_list_truck.ops_prtl_equip_group_no as "trk_ops_prtl_equip_group_no#", \
shovel_idle - shovel_std_time.idle_time   as shovel_idledelta, \
loads.eliftup, ---feet traveled empty up hill \
loads.eliftdown, ---feet traveled empty down hill \
loads.distloaded, ---total feet traveled loaded to dumping location \
loads.fliftup, ---feet traveled loaded up hill \
loads.fliftdown, ---feet traveled loaded down hill \
loads.distempty, ---total feet traveled empty to shovel \
loads.emptyhaul, \
loads.load_timearrive, \
loads.load_timearrive_ts, \
loads.timeload, \
loads.timeload_ts, \
loads.beginspot, \
loads.beginspot_ts, \
loads.hangtime, \
loads.dump_timearrive, \
loads.dump_timearrive_ts, \
loads.timedump, \
loads.timedump_ts, \
loads.timeempty, \
loads.timeempty_ts, \
loads.material_name, \
loads.start_date_ts, \
loads.end_date_ts , \
loads.system_version, \
loads.dw_logical_delete_flag, \
loads.dw_modify_ts, \
loads.dw_load_ts \
from \
edw_stage.lh2_deltac_sum_pre_stage as loads \
inner join \
 prod_mapping.ops_portal_equipment_list as equip_list_excav \
on	loads.excav = equip_list_excav.lh_equip_id \
and loads.cliid = equip_list_excav.lh_cliid \

inner join \
prod_mapping.ops_portal_equipment_list as equip_list_truck \
on	loads.truck = equip_list_truck.lh_equip_id \
and loads.cliid = equip_list_truck.lh_cliid \

inner join pddw.lh_target_time_base_view	as 	excav_std_load_time \
on	loads.cliid = excav_std_load_time.cliid \
and	loads.shiftindex >= excav_std_load_time.start_shiftindex \
and	loads.shiftindex <= excav_std_load_time.end_shiftindex \
and	equip_list_excav.ops_prtl_equip_group_no  = excav_std_load_time.ops_portal_shvl_grp_id \
and	equip_list_truck.ops_prtl_equip_group_no = excav_std_load_time.ops_portal_trck_grp_id \

inner join pddw.lh_target_load_base_view  truck_std_time \
on loads.cliid=truck_std_time.cliid and \
loads.shiftindex>=truck_std_time.start_shiftindex and \
loads.shiftindex<=truck_std_time.end_shiftindex and \
equip_list_truck.ops_prtl_equip_group_no = truck_std_time.ops_portal_equip_grp_id \

inner join pddw.lh_target_load_base_view  shovel_std_time \
on loads.cliid=shovel_std_time.cliid and \
loads.shiftindex>=shovel_std_time.start_shiftindex and \
loads.shiftindex<=shovel_std_time.end_shiftindex and \
equip_list_excav.ops_prtl_equip_group_no = shovel_std_time.ops_portal_equip_grp_id \

inner join  \
 pddw.lh_oper_list as excav_oper \
on loads.shiftindex = excav_oper.shiftindex \
and loads.eoper = excav_oper.operid \
and loads.cliid = excav_oper.cliid \

--rt_deltac_calcs_mor_15min \
--Get the average timing for an equipment group \
inner join \
    (select \
            target_load.cliid, \
            target_load.shiftindex, \
            site_code, \
            ops_portal_euip_grp, \
            ops_portal_equip_grp_id, \
            target_payload_range , \
            max(last_modified_ts) as last_modified_ts, \
            avg(size_cu_yd) as size_cu_yd, \
            avg(secs_per_pass) as secs_per_pass, \
            avg(idle_time) as idle_time, \
            avg(spot_time) as spot_time, \
            avg(load_time) as load_time, \
            avg(dump_time_dump) as dump_time_dump, \
            avg(dump_time_crusher) as dump_time_crusher, \
            avg(dump_time_upper_limiit) as dump_time_upper_limiit, \
            avg(spot_time_upper_limiit) as spot_time_upper_limiit, \
            avg(flat_loaded) as flat_loaded, \
            avg(down_loaded) as down_loaded, \
            avg(up_loaded) as up_loaded, \
            avg(flat_empty) as flat_empty, \
            avg(up_empty) as up_empty, \
            avg(down_empty) as down_empty, \
            avg(hours_per_day) as hours_per_day, \
            avg(min_payload) as min_payload, \
            avg(target_payload) as target_payload, \
            avg(measure_43_constant) as measure_43_constant, \
            avg(efh_conv_downhill) as efh_conv_downhill, \
            avg(efh_conv_uphill) as efh_conv_uphill, \
            avg(payload_comp_target) as payload_comp_target, \
            avg(lower_tar_prod) as lower_tar_prod, \
            avg(upper_tar_prod) as upper_tar_prod \
        from \
		prod_pddw.lh_target_load_shift_new target_load \
		--- to reduce the number of rows to process \
		inner join edw_stage.lh2_deltac_sum_shift_pre_stage stg \
		on stg.cliid = target_load.cliid \
		and stg.shiftindex = target_load.shiftindex \
		group by 1,2,3,4,5,6 \
    ) as speed \
		on loads.cliid = speed.cliid \
		and loads.shiftindex = speed.shiftindex \
		and equip_list_truck.ops_prtl_equip_group_no = speed. ops_portal_equip_grp_id \
;  `
snowflake.execute( {sqlText: var_sql_insert_stage2_ds6 + ";"} );
//return var_sql_insert_stage2_ds6;

//--Step 8: merge into target table
 

var_sql_merge_target_ds6 = ` merge into edw_target.lh2_deltac_sum_c as tgt \
using  \
( \
select * from ( \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 "year#" ,   \
 "month#" ,   \
 months ,   \
 shift ,   \
 "shift#" ,   \
 "crew#" ,   \
 crew ,   \
 harvhos ,   \
 digtype ,   \
 shvtype ,   \
 dipper ,   \
 trktype ,   \
 payload ,   \
 idletime ,   \
 spottime ,   \
 loadtime ,   \
 dumpingtime ,   \
 crusheridle ,   \
 travelempty ,   \
 travelloaded ,   \
 totalcycle ,   \
 calctravempty ,   \
 calctravloaded ,   \
 hos ,   \
 timefull ,   \
 timefull_ts , \
 timeloaded ,   \
 excav ,   \
 soperid ,   \
 soper ,   \
 truck ,   \
 toperid ,   \
 toper ,   \
 "load#" ,   \
 material ,   \
 bench ,   \
 "unit#" ,   \
 unit ,   \
 dumpname ,   \
 idledelta ,   \
 spotdelta ,   \
 loaddelta ,   \
 dumpdelta ,   \
 et_delta ,   \
 lt_delta ,   \
 delta_c ,   \
 toavgdeltac ,   \
 tostdevdeltac ,   \
 toavgidledelta ,   \
 tostdevidledelta ,   \
 toavgspotdelta ,   \
 tostdevspotdelta ,   \
 toavgloaddelta ,   \
 tostdevloaddelta ,   \
 toavgetdelta ,   \
 tostdevetdelta ,   \
 toavgltdelta ,   \
 tostdevltdelta ,   \
 toavgdumpdelta ,   \
 tostdevdumpdelta ,   \
 vtodeltac3 ,   \
 load_seq_no ,   \
 grade ,   \
 extraload ,   \
 loadtype ,   \
 loadtons ,   \
 measuretons_shovel ,   \
 over_truck_flag ,   \
 under_truck_flag ,   \
 dump_flag ,   \
 shovel_idle ,   \
 crusher_dump_flag ,   \
 dump_number ,   \
 ldump_hos ,   \
 dump_hos ,   \
 dump_oper_id ,   \
 "shovel_eqmttype#" ,   \
 "truck_eqmttype#" ,   \
 "shvl_ops_prtl_equip_group_no#", \
 "trk_ops_prtl_equip_group_no#", \
 shovel_idledelta ,   \
 eliftup ,   \
 eliftdown ,   \
 distloaded ,   \
 fliftup ,   \
 fliftdown ,   \
 distempty ,   \
 emptyhaul ,   \
 load_timearrive ,  \
 load_timearrive_ts , \
 timeload ,   \
 timeload_ts , \
 beginspot ,   \
 beginspot_ts , \
 hangtime ,   \
 dump_timearrive ,   \
 dump_timearrive_ts , \
 timedump ,  \
 timedump_ts , \
 timeempty ,   \
 timeempty_ts , \
 material_name ,   \
 start_date_ts , \
 end_date_ts, \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts   , \
 row_number() over (partition by cliid,shiftindex,ddbkey order by toper desc,soper desc) qual_1\
from  edw_stage.lh2_deltac_sum )\
--qualify( row_number() over (partition by cliid,shiftindex,ddbkey order by toper desc,soper desc) =1)
where qual_1 =1  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey  \
 ) \
WHEN MATCHED then \
UPDATE SET  \
 site_code =  stg.site_code ,  \
 shiftdate =  stg.shiftdate, \
excav = stg.excav ,  \
truck = stg.truck, \
 "year#" =  stg."year#" ,  \
 "month#" =  stg."month#" ,  \
 months =  stg.months ,  \
 shift =  stg.shift ,  \
 "shift#" =  stg."shift#" ,  \
 "crew#" =  stg."crew#" ,  \
 crew =  stg.crew ,  \
 harvhos =  stg.harvhos ,  \
 digtype =  stg.digtype ,  \
 shvtype =  stg.shvtype ,  \
 dipper =  stg.dipper ,  \
 trktype =  stg.trktype ,  \
 payload =  stg.payload ,  \
 idletime =  stg.idletime ,  \
 spottime =  stg.spottime ,  \
 loadtime =  stg.loadtime ,  \
 dumpingtime =  stg.dumpingtime ,  \
 crusheridle =  stg.crusheridle ,  \
 travelempty =  stg.travelempty ,  \
 travelloaded =  stg.travelloaded ,  \
 totalcycle =  stg.totalcycle ,  \
 calctravempty =  stg.calctravempty ,  \
 calctravloaded =  stg.calctravloaded ,  \
 hos =  stg.hos ,  \
 timefull =  stg.timefull ,  \
 timefull_ts =  stg.timefull_ts ,  \
 timeloaded =  stg.timeloaded ,  \
 soperid =  stg.soperid ,  \
 soper =  stg.soper ,  \
 toperid =  stg.toperid ,  \
 toper =  stg.toper ,  \
 "load#" =  stg."load#" ,  \
 material =  stg.material ,  \
 bench =  stg.bench ,  \
 "unit#" =  stg."unit#" ,  \
 unit =  stg.unit ,  \
 dumpname =  stg.dumpname ,  \
 idledelta =  stg.idledelta ,  \
 spotdelta =  stg.spotdelta ,  \
 loaddelta =  stg.loaddelta ,  \
 dumpdelta =  stg.dumpdelta ,  \
 et_delta =  stg.et_delta ,  \
 lt_delta =  stg.lt_delta ,  \
 delta_c =  stg.delta_c ,  \
 toavgdeltac =  stg.toavgdeltac ,  \
 tostdevdeltac =  stg.tostdevdeltac ,  \
 toavgidledelta =  stg.toavgidledelta ,  \
 tostdevidledelta =  stg.tostdevidledelta ,  \
 toavgspotdelta =  stg.toavgspotdelta ,  \
 tostdevspotdelta =  stg.tostdevspotdelta ,  \
 toavgloaddelta =  stg.toavgloaddelta ,  \
 tostdevloaddelta =  stg.tostdevloaddelta ,  \
 toavgetdelta =  stg.toavgetdelta ,  \
 tostdevetdelta =  stg.tostdevetdelta ,  \
 toavgltdelta =  stg.toavgltdelta ,  \
 tostdevltdelta =  stg.tostdevltdelta ,  \
 toavgdumpdelta =  stg.toavgdumpdelta ,  \
 tostdevdumpdelta =  stg.tostdevdumpdelta ,  \
 vtodeltac3 =  stg.vtodeltac3 ,  \
 load_seq_no =  stg.load_seq_no ,  \
 grade =  stg.grade ,  \
 extraload =  stg.extraload ,  \
 loadtype =  stg.loadtype ,  \
 loadtons =  stg.loadtons ,  \
 measuretons_shovel =  stg.measuretons_shovel ,  \
 over_truck_flag =  stg.over_truck_flag ,  \
 under_truck_flag =  stg.under_truck_flag ,  \
 dump_flag =  stg.dump_flag ,  \
 shovel_idle =  stg.shovel_idle ,  \
 crusher_dump_flag =  stg.crusher_dump_flag ,  \
 dump_number =  stg.dump_number ,  \
 ldump_hos =  stg.ldump_hos ,  \
 dump_hos =  stg.dump_hos ,  \
 dump_oper_id =  stg.dump_oper_id ,  \
 "shovel_eqmttype#" =  stg."shovel_eqmttype#" ,  \
 "truck_eqmttype#" =  stg."truck_eqmttype#" ,  \
 "shvl_ops_prtl_equip_group_no#" =  stg."shvl_ops_prtl_equip_group_no#", \
 "trk_ops_prtl_equip_group_no#" =   stg."trk_ops_prtl_equip_group_no#", \
 shovel_idledelta =  stg.shovel_idledelta ,  \
 eliftup =  stg.eliftup ,  \
 eliftdown =  stg.eliftdown ,  \
 distloaded =  stg.distloaded ,  \
 fliftup =  stg.fliftup ,  \
 fliftdown =  stg.fliftdown ,  \
 distempty =  stg.distempty ,  \
 emptyhaul =  stg.emptyhaul ,  \
 load_timearrive =  stg.load_timearrive ,  \
 load_timearrive_ts =  stg.load_timearrive_ts ,  \
 timeload =  stg.timeload ,  \
 timeload_ts =  stg.timeload_ts ,  \
 beginspot =  stg.beginspot ,  \
 beginspot_ts =  stg.beginspot_ts ,  \
 hangtime =  stg.hangtime ,  \
 dump_timearrive =  stg.dump_timearrive ,  \
 dump_timearrive_ts =  stg.dump_timearrive_ts ,  \
 timedump =  stg.timedump ,  \
 timedump_ts =  stg.timedump_ts ,  \
 timeempty =  stg.timeempty ,  \
 timeempty_ts =  stg.timeempty_ts ,  \
 material_name =  stg.material_name ,  \
 start_date_ts =  stg.start_date_ts , \
 end_date_ts =  stg.end_date_ts, \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN  \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg."year#" ,  \
  stg."month#" ,  \
  stg.months ,  \
  stg.shift ,  \
  stg."shift#" ,  \
  stg."crew#" ,  \
  stg.crew ,  \
  stg.harvhos ,  \
  stg.digtype ,  \
  stg.shvtype ,  \
  stg.dipper ,  \
  stg.trktype ,  \
  stg.payload ,  \
  stg.idletime ,  \
  stg.spottime ,  \
  stg.loadtime ,  \
  stg.dumpingtime ,  \
  stg.crusheridle ,  \
  stg.travelempty ,  \
  stg.travelloaded ,  \
  stg.totalcycle ,  \
  stg.calctravempty ,  \
  stg.calctravloaded ,  \
  stg.hos ,  \
  stg.timefull ,  \
  stg.timefull_ts ,  \
  stg.timeloaded ,  \
  stg.excav ,  \
  stg.soperid ,  \
  stg.soper ,  \
  stg.truck ,  \
  stg.toperid ,  \
  stg.toper ,  \
  stg."load#" ,  \
  stg.material ,  \
  stg.bench ,  \
  stg."unit#" ,  \
  stg.unit ,  \
  stg.dumpname ,  \
  stg.idledelta ,  \
  stg.spotdelta ,  \
  stg.loaddelta ,  \
  stg.dumpdelta ,  \
  stg.et_delta ,  \
  stg.lt_delta ,  \
  stg.delta_c ,  \
  stg.toavgdeltac ,  \
  stg.tostdevdeltac ,  \
  stg.toavgidledelta ,  \
  stg.tostdevidledelta ,  \
  stg.toavgspotdelta ,  \
  stg.tostdevspotdelta ,  \
  stg.toavgloaddelta ,  \
  stg.tostdevloaddelta ,  \
  stg.toavgetdelta ,  \
  stg.tostdevetdelta ,  \
  stg.toavgltdelta ,  \
  stg.tostdevltdelta ,  \
  stg.toavgdumpdelta ,  \
  stg.tostdevdumpdelta ,  \
  stg.vtodeltac3 ,  \
  stg.load_seq_no ,  \
  stg.grade ,  \
  stg.extraload ,  \
  stg.loadtype ,  \
  stg.loadtons ,  \
  stg.measuretons_shovel ,  \
  stg.over_truck_flag ,  \
  stg.under_truck_flag ,  \
  stg.dump_flag ,  \
  stg.shovel_idle ,  \
  stg.crusher_dump_flag ,  \
  stg.dump_number ,  \
  stg.ldump_hos ,  \
  stg.dump_hos ,  \
  stg.dump_oper_id ,  \
  stg."shovel_eqmttype#" ,  \
  stg."truck_eqmttype#" ,  \
  stg."shvl_ops_prtl_equip_group_no#", \
  stg."trk_ops_prtl_equip_group_no#", \
  stg.shovel_idledelta ,  \
  stg.eliftup ,  \
  stg.eliftdown ,  \
  stg.distloaded ,  \
  stg.fliftup ,  \
  stg.fliftdown ,  \
  stg.distempty ,  \
  stg.emptyhaul ,  \
  stg.load_timearrive ,  \
  stg.load_timearrive_ts ,  \
  stg.timeload ,  \
  stg.timeload_ts ,  \
  stg.beginspot ,  \
  stg.beginspot_ts ,  \
  stg.hangtime ,  \
  stg.dump_timearrive ,  \
  stg.dump_timearrive_ts ,  \
  stg.timedump ,  \
  stg.timedump_ts ,  \
  stg.timeempty ,  \
  stg.timeempty_ts ,  \
  stg.material_name ,  \
  stg.start_date_ts , \
  stg.end_date_ts, \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts); `;
  
 snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} );
//return var_sql_merge_target_ds6;

//--Step 9: Capture the deleted rows
var_sql_capture_logical_delete = ` update edw_target.lh2_deltac_sum_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_deltac_sum as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_deltac_sum  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     )  ` ;

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step 10: Cleanup the target table 
var_sql_physical_delete = ` delete  from   edw_target.lh2_deltac_sum_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step 11: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_load_ts) from edw_stage.lh2_deltac_sum),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_deltac_sum_c_sp'`; 
snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------

create or replace procedure freeport.edw_etl.lh2_enum_c_ds6_sp("filter_cliid" string, "extract_mode" string)
 returns string
    language javascript
    strict
    execute as owner
    as
    $$
/*************************************************************************************************************************************************
* PK of collection table: cliid , num, enumname  
* PURPOSE : Load the lh2_enum_c collection table from  lh2_enum_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_enum_b 
                     
* Usage :   
call edw_etl.lh2_enum_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); 
call edw_etl.lh2_enum_c_ds6_sp (null,null,null ,'Delta' ) 
 Procedure Steps: 
 Initial: Set the procedure run time  
    Get the max of modify time from base table 
            check  job execution mode and define the filter  
Step1: Delete the stage table 
Step2: insert the data set into stage table based on the filter condition 
Step3: merge into target table 
Step4: Capture the deleted rows 
Step5: Cleanup the target table  
Step6: update the di job contorl entry ts base table 
* CREATE/CHANGE LOG :  
* DATE                     MOD BY                               GCC                           DESC 
*-------------------------------------   ------------------------------------  ------------------------------------   
*    2019-03-08       Kali D         Initial version 
*    *****************************************************************************************************************************************************/

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_enum_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_enum_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_enum_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 

if (extract_mode =='FULL') 
   {
     proc_var_filter_list = ` cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
   }
   else  
	{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                  
   proc_var_filter_list = ` (  site_code ) in   ( select   site_code  from  edw_target.lh2_enum_b      where  dw_modify_ts  >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' group by 1 ) ;`;
    //return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
snowflake.execute( {sqlText: "truncate edw_stage.lh2_enum_ds6;"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `   insert into edw_stage.lh2_enum_ds6 ( shiftindex ,\
  shiftdate,  \
  site_code,  \
  cliid,  \
  enumname,  \
  num,  \
  name,  \
  abbrev,  \
  flags,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
  select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   enumname,  \
   num,  \
   name,  \
   abbrev,  \
   flags,  \
  'Dispatch 6' as system_version,\
  'N'as dw_logical_delete_flag,\
   timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_enum_ds6_etl   \
  where ` +  proc_var_filter_list ;
  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_enum_c as tgt 
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 enumname ,   \
 num ,   \
 name ,   \
 abbrev ,   \
 flags ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_enum_ds6  \
) as stg  \
ON ( stg.cliid = tgt.cliid and  \
stg.enumname = tgt.enumname and  \
stg.num = tgt.num) \
\
WHEN MATCHED THEN \
UPDATE SET  \
shiftindex =  stg.shiftindex ,  \
 shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 name =  stg.name ,  \
 abbrev =  stg.abbrev ,  \
 flags =  stg.flags ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.enumname ,  \
  stg.num ,  \
  stg.name ,  \
  stg.abbrev ,  \
  stg.flags ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`; 

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_enum_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_enum_ds6 as stg  \
      where stg.cliid = tgt.cliid  \
and stg.enumname = tgt.enumname  
      and stg.num = tgt.num  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_enum_ds6  stg1  \
     where   stg1.cliid = tgt.cliid \
     )`   ;  


//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
//var_sql_physical_delete = `"
//--Kali D 2019-05-08 for now we are keeping the unavailable enum in pv5 
//--delete   edw_target.lh2_enum_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= ( cast(proc_var_dw_modify_ts as timestamp(0)) - interval '3' day );

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_enum_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_enum_c_ds6_sp';`;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 

--------------------------------------------------------------------------------

create or replace procedure freeport.edw_etl.lh2_equip_cat_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$
/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, eqmtid,hos \
* PURPOSE : Load the lh2_equip_cat_c collection table from  lh2_equip_cat_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_state_b \
*                       \
* Usage :   \
call edw_etl.lh2_equip_cat_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_equip_cat_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
"	Step 1a: Before actual table we have to bulit the  stage lh2_equip_state_oper_equip_cat 
"	Step 1b: insert into  lh2_equip_state_oper_equip_cat for better performance  
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D         Initial version \
"*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.) 
"															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code 
"															Previous filter was made only with the driving table; 
"															If non-driving table gets refreshed there wont be any impact in this stored procedure  
"															so driving table will be up to date whereas non-driving table will not get latest data 
"															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure 
*    *****************************************************************************************************************************************************/   
try {
var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_equip_cat_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_equip_cat_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_eqmt_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                }       
   //-- Sabarish S 2019-08-30 added as part of incremental load enhancement  
//return proc_var_ds6_base_max_dw_modify_ts;"
 proc_var_filter_list = ` ( shiftid, site_code) in \  
(select shiftid,site_code from edw_target.lh2_shift_aux_b  where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_state_b  where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_reason_b  where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_eqmt_b  where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_oper_b  where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`') ;`;
//return proc_var_filter_list;
            
       }   

//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_equip_state_oper_equip_cat;"} );

//--Step 1b: insert the data set into stage table based on the filter condition
   
var_sql_pre_insert_stage_ds6 = `  insert into edw_stage.lh2_equip_state_oper_equip_cat ( site_code , \
  shiftindex,  \
  shiftid,  \
  shiftdate,  \
  eqmt_id,  \
  cliid,  \
  eqmt_name,  \
  eqmt_enum_type,  \
  eqmt_enum_type_code,  \
  enum_timecat_code,  \
  enum_timecat_descr,  \
  status_event_start_time,  \
  status_event_end_time,  \
  status_event_duration_sec,  \
  fieldreason,  \
  fieldreasonrec,  \
  state_enum_status_code,  \
  fieldcomment,  \
  oper_login_num,  \
  oper_logout_num,  \
  oper_id,  \
  oper_name,  \
  oper_start_time,  \
  oper_end_time,  \
  starttime_time,  \
  starttime_num,  \
  endtime_time,  \
  endtime_num,  \
  oper_available_time,  \
  oper_available_time_sec,  \
  tmcat01,  \
  tmcat02,  \
  tmcat03,  \
  tmcat04,  \
  tmcat05,  \
  tmcat06,  \
  tmcat07,  \
  tmcat08,  \
  tmcat09,  \
  tmcat10,  \
  tmcat11,  \
  tmcat12,  \
  tmcat13,  \
  tmcat14,  \
  tmcat15,  \
  tmcat16,  \
  tmcat17,  \
  tmcat18,  \
   tmcat19 ) \
 select  site_code,   \
   shiftindex,  \
   shiftid,  \
   shiftdate,  \
   eqmt_id,  \
   cliid,  \
   eqmt_name,  \
   eqmt_enum_type,  \
   eqmt_enum_type_code,  \
   enum_timecat_code,  \
   enum_timecat_descr,  \
   status_event_start_time,  \
   status_event_end_time,  \
   status_event_duration_sec,  \
   fieldreason,  \
   fieldreasonrec,  \
   state_enum_status_code,  \
   fieldcomment,  \
   oper_login_num,  \
   oper_logout_num,  \
   oper_id,  \
   oper_name,  \
   oper_start_time,  \
   oper_end_time,  \
   starttime_time,  \
   starttime_num,  \
   endtime_time,  \
   endtime_num,  \
   oper_available_time,  \
   oper_available_time_sec,  \
   tmcat01,  \
   tmcat02,  \
   tmcat03,  \
   tmcat04,  \
   tmcat05,  \
   tmcat06,  \
   tmcat07,  \
   tmcat08,  \
   tmcat09,  \
   tmcat10,  \
   tmcat11,  \
   tmcat12,  \
   tmcat13,  \
   tmcat14,  \
   tmcat15,  \
   tmcat16,  \
   tmcat17,  \
   tmcat18,  \
   tmcat19 from edw_etl_view.lh2_equip_state_oper_etl  \
 where ` +  proc_var_filter_list ;

snowflake.execute( {sqlText: var_sql_pre_insert_stage_ds6 + ";"} );
//return var_sql_pre_insert_stage_ds6; 

//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_equip_cat_ds6 "} );

//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = ` insert into edw_stage.lh2_equip_cat_ds6 ( shiftindex,\
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  eqmtid,  \
  eqmtid_orig,  \
  hos,  \
  intvl,  \
  tmcat00,  \
  tmcat01,  \
  tmcat02,  \
  tmcat03,  \
  tmcat04,  \
  tmcat05,  \
  tmcat06,  \
  tmcat07,  \
  tmcat08,  \
  tmcat09,  \
  tmcat10,  \
  tmcat11,  \
  tmcat12,  \
  tmcat13,  \
  tmcat14,  \
  tmcat15,  \
  tmcat16,  \
  tmcat17,  \
  tmcat18,  \
  tmcat19,  \
  unit,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   eqmtid,  \
   eqmtid_orig,  \
   hos,  \
   intvl,  \
   tmcat00,  \
   tmcat01,  \
   tmcat02,  \
   tmcat03,  \
   tmcat04,  \
   tmcat05,  \
   tmcat06,  \
   tmcat07,  \
   tmcat08,  \
   tmcat09,  \
   tmcat10,  \
   tmcat11,  \
   tmcat12,  \
   tmcat13,  \
   tmcat14,  \
   tmcat15,  \
   tmcat16,  \
   tmcat17,  \
   tmcat18,  \
   tmcat19,  \
   unit,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
 timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_equip_cat_ds6_etl  \
where ` +  proc_var_filter_list ;

snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_equip_cat_c as tgt 
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 eqmtid ,   \
 eqmtid_orig ,   \
 hos ,   \
 intvl ,   \
 tmcat00 ,   \
 tmcat01 ,   \
 tmcat02 ,   \
 tmcat03 ,   \
 tmcat04 ,   \
 tmcat05 ,   \
 tmcat06 ,   \
 tmcat07 ,   \
 tmcat08 ,   \
 tmcat09 ,   \
 tmcat10 ,   \
 tmcat11 ,   \
 tmcat12 ,   \
 tmcat13 ,   \
 tmcat14 ,   \
 tmcat15 ,   \
 tmcat16 ,   \
 tmcat17 ,   \
 tmcat18 ,   \
 tmcat19 ,   \
 unit ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_equip_cat_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey and  \
stg.eqmtid = tgt.eqmtid and  \
stg.hos = tgt.hos \
) \
\
WHEN MATCHED then \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 eqmtid =  stg.eqmtid ,  \
 eqmtid_orig =  stg.eqmtid_orig ,  \
 hos =  stg.hos ,  \
 intvl =  stg.intvl ,  \
 tmcat00 =  stg.tmcat00 ,  \
 tmcat01 =  stg.tmcat01 ,  \
 tmcat02 =  stg.tmcat02 ,  \
 tmcat03 =  stg.tmcat03 ,  \
 tmcat04 =  stg.tmcat04 ,  \
 tmcat05 =  stg.tmcat05 ,  \
 tmcat06 =  stg.tmcat06 ,  \
 tmcat07 =  stg.tmcat07 ,  \
 tmcat08 =  stg.tmcat08 ,  \
 tmcat09 =  stg.tmcat09 ,  \
 tmcat10 =  stg.tmcat10 ,  \
 tmcat11 =  stg.tmcat11 ,  \
 tmcat12 =  stg.tmcat12 ,  \
 tmcat13 =  stg.tmcat13 ,  \
 tmcat14 =  stg.tmcat14 ,  \
 tmcat15 =  stg.tmcat15 ,  \
 tmcat16 =  stg.tmcat16 ,  \
 tmcat17 =  stg.tmcat17 ,  \
 tmcat18 =  stg.tmcat18 ,  \
 tmcat19 =  stg.tmcat19 ,  \
 unit =  stg.unit ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN  \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.eqmtid ,  \
  stg.eqmtid_orig ,  \
  stg.hos ,  \
  stg.intvl ,  \
  stg.tmcat00 ,  \
  stg.tmcat01 ,  \
  stg.tmcat02 ,  \
  stg.tmcat03 ,  \
  stg.tmcat04 ,  \
  stg.tmcat05 ,  \
  stg.tmcat06 ,  \
  stg.tmcat07 ,  \
  stg.tmcat08 ,  \
  stg.tmcat09 ,  \
  stg.tmcat10 ,  \
  stg.tmcat11 ,  \
  stg.tmcat12 ,  \
  stg.tmcat13 ,  \
  stg.tmcat14 ,  \
  stg.tmcat15 ,  \
  stg.tmcat16 ,  \
  stg.tmcat17 ,  \
  stg.tmcat18 ,  \
  stg.tmcat19 ,  \
  stg.unit ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts); `;

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows
var_sql_capture_logical_delete = ` update edw_target.lh2_equip_cat_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_equip_cat_ds6 as stg  \
		where stg.shiftindex = tgt.shiftindex \ 
	and stg.cliid = tgt.cliid  \
		and stg.ddbkey = tgt.ddbkey   \
		and stg.eqmtid = tgt.eqmtid  \
		and stg.hos = tgt.hos \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_equip_cat_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     )`   ;  

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = ` delete from  edw_target.lh2_equip_cat_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_equip_cat_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_equip_cat_c_ds6_sp';`;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------


create or replace procedure freeport.edw_etl.lh2_fueling_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$
/***************************************************************************************************************************************************
* PK of collection table: cliid , shiftindex, ddbkey  \
* PURPOSE : Load the lh2_fueling_c collection table from  lh2_fueling_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_fuel_b \
*                       \
* Usage :   \
call edw_etl.lh2_fueling_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_fueling_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D                Initial version \
*    2019-07-30       Anandhi P         Included timestamp field timestart_ts & timeend_ts from edw_target.lh2_shift_fuel_b. \
*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.) 
															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code 
															Previous filter was made only with the driving table; 
															If non-driving table gets refreshed there wont be any impact in this stored procedure  
															so driving table will be up to date whereas non-driving table will not get latest data 
															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure 
*    *****************************************************************************************************************************************************/   
try {
var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_fueling_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_fueling_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_fuel_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
 else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                       
   // -- Sabarish S 2019-08-30 added as part of incremental load enhancement
//return proc_var_ds6_base_max_dw_modify_ts;"
 var proc_var_filter_list = `( shiftid , site_code ) in  (\
select shiftid,site_code from edw_target.lh2_shift_fuel_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_eqmt_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_aux_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_fuel_array_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`') `;
 }
 //return proc_var_filter_list;
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_fueling_ds6;"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `   insert into edw_stage.lh2_fueling_ds6 ( shiftindex, \
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  fuelid,  \
  eqmt,  \
  unit,  \
  timestart,  \
  timestart_ts,  \
  timeend,  \
  timeend_ts,  \
  fuel00,  \
  fuel01,  \
  fuel02,  \
  fuel03,  \
  fuel04,  \
  fuel05,  \
  fuel06,  \
  fuel07,  \
  fuel08,  \
  fuel09,  \
  fuel10,  \
  fuel11,  \
  fuel12,  \
  fuel13,  \
  fuel14,  \
  fuel15,  \
  fuel16,  \
  fuel17,  \
  fuel18,  \
  fuel19,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   fuelid,  \
   eqmt,  \
   unit,  \
   timestart,  \
   timestart_ts,  \
   timeend,  \
   timeend_ts,  \
   fuel00,  \
   fuel01,  \
   fuel02,  \
   fuel03,  \
   fuel04,  \
   fuel05,  \
   fuel06,  \
   fuel07,  \
   fuel08,  \
   fuel09,  \
   fuel10,  \
   fuel11,  \
   fuel12,  \
   fuel13,  \
   fuel14,  \
   fuel15,  \
   fuel16,  \
   fuel17,  \
   fuel18,  \
   fuel19,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts  from edw_etl_view.lh2_fueling_ds6_etl \
where ` +  proc_var_filter_list ;
   snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_fueling_c as tgt
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 fuelid ,   \
 eqmt ,   \
 unit ,   \
 timestart ,   \
 timestart_ts ,   \
 timeend ,   \
 timeend_ts ,  \
 fuel00 ,   \
 fuel01 ,   \
 fuel02 ,   \
 fuel03 ,   \
 fuel04 ,   \
 fuel05 ,   \
 fuel06 ,   \
 fuel07 ,   \
 fuel08 ,   \
 fuel09 ,   \
 fuel10 ,   \
 fuel11 ,   \
 fuel12 ,   \
 fuel13 ,   \
 fuel14 ,   \
 fuel15 ,   \
 fuel16 ,   \
 fuel17 ,   \
 fuel18 ,   \
 fuel19 ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_fueling_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey ) \
\
WHEN MATCHED then \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 fuelid =  stg.fuelid ,  \
 eqmt =  stg.eqmt ,  \
 unit =  stg.unit ,  \
 timestart =  stg.timestart ,  \
 timestart_ts =  stg.timestart_ts ,  \
 timeend =  stg.timeend ,  \
 timeend_ts =  stg.timeend_ts ,  \
 fuel00 =  stg.fuel00 ,  \
 fuel01 =  stg.fuel01 ,  \
 fuel02 =  stg.fuel02 ,  \
 fuel03 =  stg.fuel03 ,  \
 fuel04 =  stg.fuel04 ,  \
 fuel05 =  stg.fuel05 ,  \
 fuel06 =  stg.fuel06 ,  \
 fuel07 =  stg.fuel07 ,  \
 fuel08 =  stg.fuel08 ,  \
 fuel09 =  stg.fuel09 ,  \
 fuel10 =  stg.fuel10 ,  \
 fuel11 =  stg.fuel11 ,  \
 fuel12 =  stg.fuel12 ,  \
 fuel13 =  stg.fuel13 ,  \
 fuel14 =  stg.fuel14 ,  \
 fuel15 =  stg.fuel15 ,  \
 fuel16 =  stg.fuel16 ,  \
 fuel17 =  stg.fuel17 ,  \
 fuel18 =  stg.fuel18 ,  \
 fuel19 =  stg.fuel19 ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.fuelid ,  \
  stg.eqmt ,  \
  stg.unit ,  \
  stg.timestart ,  \
  stg.timestart_ts ,  \
  stg.timeend ,  \
  stg.timeend_ts ,  \
  stg.fuel00 ,  \
  stg.fuel01 ,  \
  stg.fuel02 ,  \
  stg.fuel03 ,  \
  stg.fuel04 ,  \
  stg.fuel05 ,  \
  stg.fuel06 ,  \
  stg.fuel07 ,  \
  stg.fuel08 ,  \
  stg.fuel09 ,  \
  stg.fuel10 ,  \
  stg.fuel11 ,  \
  stg.fuel12 ,  \
  stg.fuel13 ,  \
  stg.fuel14 ,  \
  stg.fuel15 ,  \
  stg.fuel16 ,  \
  stg.fuel17 ,  \
  stg.fuel18 ,  \
  stg.fuel19 ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`; 

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_fueling_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_fueling_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_fueling_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     )  ` ;  
//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = ` delete from   edw_target.lh2_fueling_c   where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_fueling_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_fueling_c_ds6_sp';`;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------


create or replace procedure freeport.edw_etl.lh2_grade_list_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$
/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey  \
* PURPOSE : Load the lh2_grade_list_c collection table from  lh2_grade_list_ds6_etl view based on dw_modify_ts of base table  edw_target.lh2_shift_grade_b  \
*                       \
* Usage :   \
call edw_etl.lh2_grade_list_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_grade_list_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------   -----------------------------------   -----------------------------------    \
*    2019-03-08       Kali D         Initial version \
"*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.) 
"															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code 
"															Previous filter was made only with the driving table; 
"															If non-driving table gets refreshed there wont be any impact in this stored procedure  
"															so driving table will be up to date whereas non-driving table will not get latest data 
"															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure 
*    *****************************************************************************************************************************************************/  

try {
var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_grade_list_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_grade_list_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_grade_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                            
                            
                        
     //-- Sabarish S 2019-08-30 added as part of incremental load enhancement
//return proc_var_ds6_base_max_dw_modify_ts;
var proc_var_filter_list = `( shiftid , site_code ) in  (\
select shiftid,site_code from edw_target.lh2_shift_grade_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_grade_array_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_loc_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`') ;`;
//return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_grade_list_ds6;"} );

//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `  insert into edw_stage.lh2_grade_list_ds6 ( shiftindex, \
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  blend,  \
  "blend#",  \
  dumps,  \
  grade00,  \
  grade01,  \
  grade02,  \
  grade03,  \
  grade04,  \
  grade05,  \
  grade06,  \
  grade07,  \
  grade08,  \
  grade09,  \
  grade10,  \
  grade11,  \
  grade12,  \
  grade13,  \
  grade14,  \
  grade15,  \
  grade16,  \
  grade17,  \
  grade18,  \
  grade19,  \
  grade20,  \
  grade21,  \
  grade22,  \
  grade23,  \
  grade24,  \
  gradeid,  \
  inv,  \
  "load#",  \
  loads,  \
  loc,  \
  spgr,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   blend,  \
   "blend#",  \
   dumps,  \
   grade00,  \
   grade01,  \
   grade02,  \
   grade03,  \
   grade04,  \
   grade05,  \
   grade06,  \
   grade07,  \
   grade08,  \
   grade09,  \
   grade10,  \
   grade11,  \
   grade12,  \
   grade13,  \
   grade14,  \
   grade15,  \
   grade16,  \
   grade17,  \
   grade18,  \
   grade19,  \
   grade20,  \
   grade21,  \
   grade22,  \
   grade23,  \
   grade24,  \
   gradeid,  \
   inv,  \
   "load#",  \
   loads,  \
   loc,  \
   spgr,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_grade_list_ds6_etl   \
where ` +  proc_var_filter_list ;

  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_grade_list_c as tgt 
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 blend ,   \
 "blend#" ,   \
 dumps ,   \
 grade00 ,   \
 grade01 ,   \
 grade02 ,   \
 grade03 ,   \
 grade04 ,   \
 grade05 ,   \
 grade06 ,   \
 grade07 ,   \
 grade08 ,   \
 grade09 ,   \
 grade10 ,   \
 grade11 ,   \
 grade12 ,   \
 grade13 ,   \
 grade14 ,   \
 grade15 ,   \
 grade16 ,   \
 grade17 ,   \
 grade18 ,   \
 grade19 ,   \
 grade20 ,   \
 grade21 ,   \
 grade22 ,   \
 grade23 ,   \
 grade24 ,   \
 gradeid ,   \
 inv ,   \
 "load#" ,   \
 loads ,   \
 loc ,   \
 spgr ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_grade_list_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey) \

WHEN MATCHED THEN \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 blend =  stg.blend ,  \
 "blend#" =  stg."blend#" ,  \
 dumps =  stg.dumps ,  \
 grade00 =  stg.grade00 ,  \
 grade01 =  stg.grade01 ,  \
 grade02 =  stg.grade02 ,  \
 grade03 =  stg.grade03 ,  \
 grade04 =  stg.grade04 ,  \
 grade05 =  stg.grade05 ,  \
 grade06 =  stg.grade06 ,  \
 grade07 =  stg.grade07 ,  \
 grade08 =  stg.grade08 ,  \
 grade09 =  stg.grade09 ,  \
 grade10 =  stg.grade10 ,  \
 grade11 =  stg.grade11 ,  \
 grade12 =  stg.grade12 ,  \
 grade13 =  stg.grade13 ,  \
 grade14 =  stg.grade14 ,  \
 grade15 =  stg.grade15 ,  \
 grade16 =  stg.grade16 ,  \
 grade17 =  stg.grade17 ,  \
 grade18 =  stg.grade18 ,  \
 grade19 =  stg.grade19 ,  \
 grade20 =  stg.grade20 ,  \
 grade21 =  stg.grade21 ,  \
 grade22 =  stg.grade22 ,  \
 grade23 =  stg.grade23 ,  \
 grade24 =  stg.grade24 ,  \
 gradeid =  stg.gradeid ,  \
 inv =  stg.inv ,  \
 "load#" =  stg."load#" ,  \
 loads =  stg.loads ,  \
 loc =  stg.loc ,  \
 spgr =  stg.spgr ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.blend ,  \
  stg."blend#" ,  \
  stg.dumps ,  \
  stg.grade00 ,  \
  stg.grade01 ,  \
  stg.grade02 ,  \
  stg.grade03 ,  \
  stg.grade04 ,  \
  stg.grade05 ,  \
  stg.grade06 ,  \
  stg.grade07 ,  \
  stg.grade08 ,  \
  stg.grade09 ,  \
  stg.grade10 ,  \
  stg.grade11 ,  \
  stg.grade12 ,  \
  stg.grade13 ,  \
  stg.grade14 ,  \
  stg.grade15 ,  \
  stg.grade16 ,  \
  stg.grade17 ,  \
  stg.grade18 ,  \
  stg.grade19 ,  \
  stg.grade20 ,  \
  stg.grade21 ,  \
  stg.grade22 ,  \
  stg.grade23 ,  \
  stg.grade24 ,  \
  stg.gradeid ,  \
  stg.inv ,  \
  stg."load#" ,  \
  stg.loads ,  \
  stg.loc ,  \
  stg.spgr ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts); `

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_grade_list_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_grade_list_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_grade_list_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     )  ` ;  

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = ` delete  from edw_target.lh2_grade_list_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_grade_list_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_grade_list_c_ds6_sp'; `;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------






create or  replace procedure freeport.edw_etl. lh2_location_c_ds6_sp  ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$


/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey \
* PURPOSE : Load the lh2_location_c collection table from  lh2_location_ds6_etl view based on dw_modify_ts of base table  edw_target.lh2_shift_loc_b  \
*                       \
* Usage :   \
call edw_etl.lh2_location_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_location_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D         Initial version \
*    *****************************************************************************************************************************************************/  

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_location_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_location_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_loc_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                            
                            
        proc_var_filter_list = ` ( shiftid , site_code ) in   ( select shiftid , site_code  from   edw_target.lh2_shift_loc_b    where  dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts  +`'  group by 1,2 ) ` ;                
//return proc_var_ds6_base_max_dw_modify_ts;"
         
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_location_ds6"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `  insert into edw_stage.lh2_location_ds6 ( shiftindex,\
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  locid,  \
  pit,  \
  region,  \
  elev,  \
  elev_dispatch,  \
  "unit#",  \
  unit,  \
  x,  \
  y,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   locid,  \
   pit,  \
   region,  \
   elev,  \
   elev_dispatch,  \
   "unit#",  \
   unit,  \
   x,  \
   y,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_location_ds6_etl   \
where ` +  proc_var_filter_list ;

  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_location_c as tgt \
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 locid ,   \
 pit ,   \
 region ,   \
 elev ,   \
 elev_dispatch ,   \
 "unit#" ,   \
 unit ,   \
 x ,   \
 y ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_location_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey) \
\
WHEN MATCHED THEN \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 locid =  stg.locid ,  \
 pit =  stg.pit ,  \
 region =  stg.region ,  \
 elev =  stg.elev ,  \
 elev_dispatch =  stg.elev_dispatch ,  \
 "unit#" =  stg."unit#" ,  \
 unit =  stg.unit ,  \
 x =  stg.x ,  \
 y =  stg.y ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.locid ,  \
  stg.pit ,  \
  stg.region ,  \
  stg.elev ,  \
  stg.elev_dispatch ,  \
  stg."unit#" ,  \
  stg.unit ,  \
  stg.x ,  \
  stg.y ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`; 

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_location_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_location_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_location_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     )  `;

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = ` delete  from edw_target.lh2_location_c  where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_location_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_location_c_ds6_sp';`;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------






create or replace procedure freeport.edw_etl.lh2_oper_list_c_ds6_sp  ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$
/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey  \
* PURPOSE : Load the lh2_oper_list_c collection table from  lh2_oper_list_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_oper_b \
*                       \
* Usage :   \
call edw_etl.lh2_oper_list_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_oper_list_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D         Initial version \
*    *****************************************************************************************************************************************************/  

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_list_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_list_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_oper_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 

if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                          
 //return proc_var_filter_list;
        proc_var_filter_list = ` 	( shiftid , site_code ) in   ( select shiftid , site_code from edw_target.lh2_shift_oper_b    where  dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts  +`'  group by 1,2 ) ` ;  
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_oper_list_ds6"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `   insert into edw_stage.lh2_oper_list_ds6 ( shiftindex, \
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  operid,  \
  name,  \
  "crew#",  \
  crew,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   operid,  \
   name,  \
   "crew#",  \
   crew,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts  from edw_etl_view.lh2_oper_list_ds6_etl   \
where ` +  proc_var_filter_list ;

  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_oper_list_c as tgt \
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 operid ,   \
 name ,   \
 "crew#" ,   \
 crew ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_oper_list_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey) \
\
WHEN MATCHED THEN \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 operid =  stg.operid ,  \
 name =  stg.name ,  \
 "crew#" =  stg."crew#" ,  \
 crew =  stg.crew ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED  THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.operid ,  \
  stg.name ,  \
  stg."crew#" ,  \
  stg.crew ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts) `;

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_oper_list_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_oper_list_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_oper_list_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     ) `  ;  

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = `delete from  edw_target.lh2_oper_list_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_oper_list_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_oper_list_c_ds6_sp'; `

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------


create or replace procedure freeport.edw_etl.lh2_oper_total_sum_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$


/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey , eqmtid , logintime , locid ,operid, "unit#" \
* PURPOSE : Load the lh2_oper_total_sum_c collection table from  lh2_oper_total_sum_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_oper_b \
*                       \
* Usage :   \
call edw_etl.lh2_oper_total_sum_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_oper_total_sum_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
"	Step 1a: Before actual table we have to bulit the  stage lh2_equip_state_oper_total_sum 
"	Step 1b: insert into  lh2_equip_state_oper_total_sum for better performance  
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D                Initial version \
"*   2019-04-10		 Kali D				To improve perfromance we are loading the data into stage table  edw_stage.lh2_equip_state_oper 
"*   2019-07-31		Anandhi P		Included timestamp field (logintime_ts) 
"*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.) 
"															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code 
"															Previous filter was made only with the driving table; 
"															If non-driving table gets refreshed there wont be any impact in this stored procedure  
"															so driving table will be up to date whereas non-driving table will not get latest data 
"															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure 
*    *****************************************************************************************************************************************************/  

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_total_sum_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_oper_total_sum_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_oper_b"} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                            
                            
                        
   //-- Sabarish S 2019-08-30 added as part of incremental load enhancement
//return proc_var_ds6_base_max_dw_modify_ts;"
 var proc_var_filter_list = `( shiftindex , site_code ) in  (\
select shiftindex,site_code from edw_target.lh2_load_c    where dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select DATEDIFF(DAY, (date '1970-01-01' ), shiftdate) * 2  + mod( (shiftid -1), 2) shiftindex ,site_code from edw_target.lh2_shift_aux_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select DATEDIFF(DAY, (date '1970-01-01' ), shiftdate) * 2  + mod( (shiftid -1), 2) shiftindex  ,site_code from edw_target.lh2_shift_eqmt_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select DATEDIFF(DAY, (date '1970-01-01' ), shiftdate) * 2  + mod( (shiftid -1), 2) shiftindex  ,site_code from edw_target.lh2_shift_loc_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select DATEDIFF(DAY, (date '1970-01-01' ), shiftdate) * 2  + mod( (shiftid -1), 2) shiftindex  ,site_code from edw_target.lh2_shift_state_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select DATEDIFF(DAY, (date '1970-01-01' ), shiftdate) * 2  + mod( (shiftid -1), 2) shiftindex ,site_code from edw_target.lh2_shift_reason_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select DATEDIFF(DAY, (date '1970-01-01' ), shiftdate) * 2  + mod( (shiftid -1), 2) shiftindex  ,site_code from edw_target.lh2_shift_oper_b where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`') ;`;
   //return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_equip_state_oper_total_sum;"} );

//--Step 1b: insert the data set into stage table based on the filter condition
//   
var_sql_insert_stage_ds6 = `  insert into edw_stage.lh2_equip_state_oper_total_sum ( site_code,\
  shiftindex,  \
  shiftid,  \
  shiftdate,  \
  eqmt_id,  \
  cliid,  \
  eqmt_name,  \
  eqmt_enum_type,  \
  eqmt_enum_type_code,  \
  enum_timecat_code,  \
  enum_timecat_descr,  \
  status_event_start_time,  \
  status_event_end_time,  \
  status_event_duration_sec,  \
  fieldreason,  \
  fieldreasonrec,  \
  state_enum_status_code,  \
  fieldcomment,  \
  oper_login_num,  \
  oper_logout_num,  \
  oper_id,  \
  oper_name,  \
  oper_start_time,  \
  oper_end_time,  \
  starttime_time,  \
  starttime_num,  \
  endtime_time,  \
  endtime_num,  \
  oper_available_time,  \
  oper_available_time_sec,  \
  tmcat01,  \
  tmcat02,  \
  tmcat03,  \
  tmcat04,  \
  tmcat05,  \
  tmcat06,  \
  tmcat07,  \
  tmcat08,  \
  tmcat09,  \
  tmcat10,  \
  tmcat11,  \
  tmcat12,  \
  tmcat13,  \
  tmcat14,  \
  tmcat15,  \
  tmcat16,  \
  tmcat17,  \
  tmcat18,  \
   tmcat19 ) \
 select  site_code,   \
   shiftindex,  \
   shiftid,  \
   shiftdate,  \
   eqmt_id,  \
   cliid,  \
   eqmt_name,  \
   eqmt_enum_type,  \
   eqmt_enum_type_code,  \
   enum_timecat_code,  \
   enum_timecat_descr,  \
   status_event_start_time,  \
   status_event_end_time,  \
   status_event_duration_sec,  \
   fieldreason,  \
   fieldreasonrec,  \
   state_enum_status_code,  \
   fieldcomment,  \
   oper_login_num,  \
   oper_logout_num,  \
   oper_id,  \
   oper_name,  \
   oper_start_time,  \
   oper_end_time,  \
   starttime_time,  \
   starttime_num,  \
   endtime_time,  \
   endtime_num,  \
   oper_available_time,  \
   oper_available_time_sec,  \
   tmcat01,  \
   tmcat02,  \
   tmcat03,  \
   tmcat04,  \
   tmcat05,  \
   tmcat06,  \
   tmcat07,  \
   tmcat08,  \
   tmcat09,  \
   tmcat10,  \
   tmcat11,  \
   tmcat12,  \
   tmcat13,  \
   tmcat14,  \
   tmcat15,  \
   tmcat16,  \
   tmcat17,  \
   tmcat18,  \
   tmcat19 from edw_etl_view.lh2_equip_state_oper_etl   \
 where ` +  proc_var_filter_list ;
snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_oper_total_sum_ds6"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = ` insert into edw_stage.lh2_oper_total_sum_ds6 ( shiftindex, \
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  eqmtid,  \
  eqmtid_orig,  \
  idletime,  \
  loadcnt,  \
  loadtime,  \
  locid,  \
  logintime,  \
  logintime_ts,  \
  name,  \
  operid,  \
  pit,  \
  spottime,  \
  tmcat00,  \
  tmcat01,  \
  tmcat02,  \
  tmcat03,  \
  tmcat04,  \
  tmcat05,  \
  tmcat06,  \
  tmcat07,  \
  tmcat08,  \
  tmcat09,  \
  tmcat10,  \
  tmcat11,  \
  tmcat12,  \
  tmcat13,  \
  tmcat14,  \
  tmcat15,  \
  tmcat16,  \
  tmcat17,  \
  tmcat18,  \
  tmcat19,  \
  totalloads,  \
  totaltime,  \
  totaltons,  \
  unit,  \
  "unit#",  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   eqmtid,  \
   eqmtid_orig,  \
   idletime,  \
   loadcnt,  \
   loadtime,  \
   locid,  \
   logintime,  \
   logintime_ts,  \
   name,  \
   operid,  \
   pit,  \
   spottime,  \
   tmcat00,  \
   tmcat01,  \
   tmcat02,  \
   tmcat03,  \
   tmcat04,  \
   tmcat05,  \
   tmcat06,  \
   tmcat07,  \
   tmcat08,  \
   tmcat09,  \
   tmcat10,  \
   tmcat11,  \
   tmcat12,  \
   tmcat13,  \
   tmcat14,  \
   tmcat15,  \
   tmcat16,  \
   tmcat17,  \
   tmcat18,  \
   tmcat19,  \
   totalloads,  \
   totaltime,  \
   totaltons,  \
   unit,  \
   "unit#",  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts  from edw_etl_view.lh2_oper_total_sum_ds6_etl   \
where ` +  proc_var_filter_list ;

  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_oper_total_sum_c as tgt \
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 eqmtid ,   \
 eqmtid_orig ,   \
 idletime ,   \
 loadcnt ,   \
 loadtime ,   \
 locid ,   \
 logintime ,   \
 logintime_ts ,   \
 name ,   \
 operid ,   \
 pit ,   \
 spottime ,   \
 tmcat00 ,   \
 tmcat01 ,   \
 tmcat02 ,   \
 tmcat03 ,   \
 tmcat04 ,   \
 tmcat05 ,   \
 tmcat06 ,   \
 tmcat07 ,   \
 tmcat08 ,   \
 tmcat09 ,   \
 tmcat10 ,   \
 tmcat11 ,   \
 tmcat12 ,   \
 tmcat13 ,   \
 tmcat14 ,   \
 tmcat15 ,   \
 tmcat16 ,   \
 tmcat17 ,   \
 tmcat18 ,   \
 tmcat19 ,   \
 totalloads ,   \
 totaltime ,   \
 totaltons ,   \
 unit ,   \
 "unit#" ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_oper_total_sum_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey and  \
stg.eqmtid =  tgt.eqmtid and \
stg.logintime =  tgt.logintime  and  \
stg.locid =  tgt.locid and \
stg.operid =  tgt.operid and \
stg."unit#" =  tgt."unit#" ) \
\
WHEN MATCHED then \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 eqmtid_orig =  stg.eqmtid_orig ,  \
 idletime =  stg.idletime ,  \
 loadcnt =  stg.loadcnt ,  \
 loadtime =  stg.loadtime ,  \
 logintime_ts =  stg.logintime_ts ,  \
 name =  stg.name ,  \
  pit =  stg.pit ,  \
 spottime =  stg.spottime ,  \
 tmcat00 =  stg.tmcat00 ,  \
 tmcat01 =  stg.tmcat01 ,  \
 tmcat02 =  stg.tmcat02 ,  \
 tmcat03 =  stg.tmcat03 ,  \
 tmcat04 =  stg.tmcat04 ,  \
 tmcat05 =  stg.tmcat05 ,  \
 tmcat06 =  stg.tmcat06 ,  \
 tmcat07 =  stg.tmcat07 ,  \
 tmcat08 =  stg.tmcat08 ,  \
 tmcat09 =  stg.tmcat09 ,  \
 tmcat10 =  stg.tmcat10 ,  \
 tmcat11 =  stg.tmcat11 ,  \
 tmcat12 =  stg.tmcat12 ,  \
 tmcat13 =  stg.tmcat13 ,  \
 tmcat14 =  stg.tmcat14 ,  \
 tmcat15 =  stg.tmcat15 ,  \
 tmcat16 =  stg.tmcat16 ,  \
 tmcat17 =  stg.tmcat17 ,  \
 tmcat18 =  stg.tmcat18 ,  \
 tmcat19 =  stg.tmcat19 ,  \
 totalloads =  stg.totalloads ,  \
 totaltime =  stg.totaltime ,  \
 totaltons =  stg.totaltons ,  \
 unit =  stg.unit ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.eqmtid ,  \
  stg.eqmtid_orig ,  \
  stg.idletime ,  \
  stg.loadcnt ,  \
  stg.loadtime ,  \
  stg.locid ,  \
  stg.logintime ,  \
  stg.logintime_ts ,  \
  stg.name ,  \
  stg.operid ,  \
  stg.pit ,  \
  stg.spottime ,  \
  stg.tmcat00 ,  \
  stg.tmcat01 ,  \
  stg.tmcat02 ,  \
  stg.tmcat03 ,  \
  stg.tmcat04 ,  \
  stg.tmcat05 ,  \
  stg.tmcat06 ,  \
  stg.tmcat07 ,  \
  stg.tmcat08 ,  \
  stg.tmcat09 ,  \
  stg.tmcat10 ,  \
  stg.tmcat11 ,  \
  stg.tmcat12 ,  \
  stg.tmcat13 ,  \
  stg.tmcat14 ,  \
  stg.tmcat15 ,  \
  stg.tmcat16 ,  \
  stg.tmcat17 ,  \
  stg.tmcat18 ,  \
  stg.tmcat19 ,  \
  stg.totalloads ,  \
  stg.totaltime ,  \
  stg.totaltons ,  \
  stg.unit ,  \
  stg."unit#" ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts) `;

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_oper_total_sum_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_oper_total_sum_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
		and stg.cliid = tgt.cliid  \
	and stg.ddbkey = tgt.ddbkey  \
		and stg.eqmtid =  tgt.eqmtid  \
		and stg.logintime =  tgt.logintime   \ 
		and stg.locid =  tgt.locid  \
		and stg.operid =  tgt.operid \
		and stg."unit#" =  tgt."unit#" \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_oper_total_sum_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     ) `  ;  
//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = `delete from edw_target.lh2_oper_total_sum_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_oper_total_sum_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_oper_total_sum_c_ds6_sp';`;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------



create or replace procedure freeport.edw_etl.lh2_reason_c_ds6_sp("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$
/**************************************************************************************************************************************************** 
* PK of extension table: cliid , shiftindex, ddbkey \
* PURPOSE : Load the lh2_reason_c collection table from  lh2_reason_ds6_etl view based on dw_modify_ts of base table ADD SOURCE TABLE NAME \
*                       \
* Usage :   \
call edw_etl.lh2_reason_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_reason_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D         Initial version \
*    *****************************************************************************************************************************************************/  

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_reason_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_reason_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_pit_reason_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                            
           proc_var_filter_list = ` ( shiftindex, cliid) in   ( select shiftindex, cliid from  edw_etl_view.lh2_reason_ds6_etl  where dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts  +`'  group by 1,2 ) ` ;                 
                        
//return proc_var_ds6_base_max_dw_modify_ts;
        //return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_reason_ds6;"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `  insert into edw_stage.lh2_reason_ds6 ( shiftindex,\
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  name,  \
  reason,  \
  status,  \
  delaytime,  \
  category,  \
  mainttime,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   name,  \
   reason,  \
   status,  \
   delaytime,  \
   category,  \
   mainttime,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts  from edw_etl_view.lh2_reason_ds6_etl   \
where ` +  proc_var_filter_list ;


  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_reason_c as tgt \ 
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 name ,   \
 reason ,   \
 status ,   \
 delaytime ,   \
 category ,   \
 mainttime ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_reason_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey and  \
stg.reason =  tgt.reason and  \
 stg.status =  tgt.status ) \
\
WHEN MATCHED then \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 name =  stg.name ,  \
 delaytime =  stg.delaytime ,  \
 category =  stg.category ,  \
 mainttime =  stg.mainttime ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.name ,  \
  stg.reason ,  \
  stg.status ,  \
  stg.delaytime ,  \
  stg.category ,  \
  stg.mainttime ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`;

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_reason_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_reason_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
and stg.reason =  tgt.reason 
and  stg.status =  tgt.status  
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_reason_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     ) `  ;  



//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = `delete from edw_target.lh2_reason_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_reason_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_reason_c_ds6_sp'`; 

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 



--------------------------------------------------------------------------------






create or replace procedure freeport.edw_etl.lh2_roaddump_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$
/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey , locstart ,locend \
* PURPOSE : Load the lh2_roaddump_c collection table from  lh2_roaddump_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_pit_travel_b \
*                       \
* Usage :   \
call edw_etl.lh2_roaddump_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_roaddump_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D         Initial version \
*    *****************************************************************************************************************************************************/  \
try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_roaddump_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_roaddump_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_pit_travel_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                            
                            
                        
//return proc_var_ds6_base_max_dw_modify_ts;"
  //return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_roaddump_ds6;"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = ` insert into edw_stage.lh2_roaddump_ds6 ( shiftindex, \
  shiftdate,  \
  site_code,  \
  site_name,  \
  cliid,  \
  ddbkey,  \
  id,  \
  locstart,  \
  locend,  \
  dist,  \
  startx,  \
  starty,  \
  startz,  \
  endx,  \
  endy,  \
  endz,  \
  grade,  \
  xgraph_0,  \
  xgraph_1,  \
  xgraph_2,  \
  ygraph_1,  \
  ygraph_2,  \
  closed,  \
  timeempty,  \
  timeloaded,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   site_name,  \
   cliid,  \
   ddbkey,  \
   id,  \
   locstart,  \
   locend,  \
   dist,  \
   startx,  \
   starty,  \
   startz,  \
   endx,  \
   endy,  \
   endz,  \
   grade,  \
   xgraph_0,  \
   xgraph_1,  \
   xgraph_2,  \
   ygraph_1,  \
   ygraph_2,  \
   closed,  \
   timeempty,  \
   timeloaded,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_roaddump_ds6_etl   \
where ` +  proc_var_filter_list ;


  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_roaddump_c as tgt \
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 site_name ,   \
 cliid ,   \
 ddbkey ,   \
 id ,   \
 locstart ,   \
 locend ,   \
 dist ,   \
 startx ,   \
 starty ,   \
 startz ,   \
 endx ,   \
 endy ,   \
 endz ,   \
 grade ,   \
 xgraph_0 ,   \
 xgraph_1 ,   \
 xgraph_2 ,   \
 ygraph_1 ,   \
 ygraph_2 ,   \
 closed ,   \
 timeempty ,   \
 timeloaded ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_roaddump_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey and  \
stg.locstart =  tgt.locstart and   \
 stg.locend =  tgt.locend  ) \
\
WHEN MATCHED THEN \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 site_name =  stg.site_name ,  \
 id =  stg.id ,  \
 dist =  stg.dist ,  \
 startx =  stg.startx ,  \
 starty =  stg.starty ,  \
 startz =  stg.startz ,  \
 endx =  stg.endx ,  \
 endy =  stg.endy ,  \
 endz =  stg.endz ,  \
 grade =  stg.grade ,  \
 xgraph_0 =  stg.xgraph_0 ,  \
 xgraph_1 =  stg.xgraph_1 ,  \
 xgraph_2 =  stg.xgraph_2 ,  \
 ygraph_1 =  stg.ygraph_1 ,  \
 ygraph_2 =  stg.ygraph_2 ,  \
 closed =  stg.closed ,  \
 timeempty =  stg.timeempty ,  \
 timeloaded =  stg.timeloaded ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.site_name ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.id ,  \
  stg.locstart ,  \
  stg.locend ,  \
  stg.dist ,  \
  stg.startx ,  \
  stg.starty ,  \
  stg.startz ,  \
  stg.endx ,  \
  stg.endy ,  \
  stg.endz ,  \
  stg.grade ,  \
  stg.xgraph_0 ,  \
  stg.xgraph_1 ,  \
  stg.xgraph_2 ,  \
  stg.ygraph_1 ,  \
  stg.ygraph_2 ,  \
  stg.closed ,  \
  stg.timeempty ,  \
  stg.timeloaded ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`; 

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_roaddump_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_roaddump_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
and stg.locstart =  tgt.locstart  
      and stg.locend =  tgt.locend \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_roaddump_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     ) `  ;  

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = `delete from edw_target.lh2_roaddump_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_roaddump_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_roaddump_c_ds6_sp'`; 

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------






create or replace procedure freeport.edw_etl.lh2_shift_date_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$


/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey  \
* PURPOSE : Load the lh2_shift_date_c collection table from  lh2_shift_date_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_info_b \
*                       \
* Usage :   \
call edw_etl.lh2_shift_date_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_shift_date_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D         Initial version \
*    *****************************************************************************************************************************************************/  \

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_shift_date_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_shift_date_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_info_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                            
                            
                        
//return proc_var_ds6_base_max_dw_modify_ts;"
        //return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_shift_date_ds6;"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = ` insert into edw_stage.lh2_shift_date_ds6 ( shiftindex,\
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  name,  \
  years,  \
  "month#",  \
  months,  \
  days,  \
  "shift#",  \
  shift,  \
  dates,  \
  starts,  \
  "crew#",  \
  crew,  \
  len,  \
  disptime,  \
  holiday,  \
  ddmmyy,  \
  finyear,  \
  finquarter,  \
  finmonth,  \
  finweek,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   name,  \
   years,  \
   "month#",  \
   months,  \
   days,  \
   "shift#",  \
   shift,  \
   dates,  \
   starts,  \
   "crew#",  \
   crew,  \
   len,  \
   disptime,  \
   holiday,  \
   ddmmyy,  \
   finyear,  \
   finquarter,  \
   finmonth,  \
   finweek,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
   timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_shift_date_ds6_etl   \
where ` +  proc_var_filter_list ;

--Step3: merge into target table
  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_shift_date_c as tgt  \ 
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 name ,   \
 years ,   \
 "month#" ,   \
 months ,   \
 days ,   \
 "shift#" ,   \
 shift ,   \
 dates ,   \
 starts ,   \
 "crew#" ,   \
 crew ,   \
 len ,   \
 disptime ,   \
 holiday ,   \
 ddmmyy ,   \
 finyear ,   \
 finquarter ,   \
 finmonth ,   \
 finweek ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_shift_date_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid \
and stg.ddbkey = tgt.ddbkey) \
\
WHEN MATCHED THEN \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 ddbkey =  stg.ddbkey ,  \
 name =  stg.name ,  \
 years =  stg.years ,  \
 "month#" =  stg."month#" ,  \
 months =  stg.months ,  \
 days =  stg.days ,  \
 "shift#" =  stg."shift#" ,  \
 shift =  stg.shift ,  \
 dates =  stg.dates ,  \
 starts =  stg.starts ,  \
 "crew#" =  stg."crew#" ,  \
 crew =  stg.crew ,  \
 len =  stg.len ,  \
 disptime =  stg.disptime ,  \
 holiday =  stg.holiday ,  \
 ddmmyy =  stg.ddmmyy ,  \
 finyear =  stg.finyear ,  \
 finquarter =  stg.finquarter ,  \
 finmonth =  stg.finmonth ,  \
 finweek =  stg.finweek ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.name ,  \
  stg.years ,  \
  stg."month#" ,  \
  stg.months ,  \
  stg.days ,  \
  stg."shift#" ,  \
  stg.shift ,  \
  stg.dates ,  \
  stg.starts ,  \
  stg."crew#" ,  \
  stg.crew ,  \
  stg.len ,  \
  stg.disptime ,  \
  stg.holiday ,  \
  stg.ddmmyy ,  \
  stg.finyear ,  \
  stg.finquarter ,  \
  stg.finmonth ,  \
  stg.finweek ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`; 

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_shift_date_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_shift_date_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_shift_date_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     ) `  ;  

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = `delete from edw_target.lh2_shift_date_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_shift_date_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_shift_date_c_ds6_sp'`; 

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------



create or replace procedure freeport.edw_etl.lh2_status_data_c_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$

/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey ( Is actually driving table's ID columns),eqmt, starttime  \
* PURPOSE : Load the lh2_status_data_c collection table from  lh2_status_data_etl view based on dw_modify_ts of base table pddw.lh_status_event \
*                       \
* Usage :   \
call edw_etl.lh2_status_data_c_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,43195,1554590','FULL' ); \
call edw_etl.lh2_status_data_c_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-07-30       Sabarish S         Initial version \
*    *****************************************************************************************************************************************************/  \

try {
var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_data_c_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_data_c_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);


set proc_var_base_max_dw_modify_ts =  (select max(dw_modify_ts) from pddw.lh_status_event );  



if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
        //Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
                   
      snowflake.execute( {sqlText: "truncate " edw_stage.lh2_status_data_shift_stage;"} );
//--Step2: insert the data set into stage table based on the filter condition
var_sql_insert_stage_ds6 = ` insert into edw_stage.lh2_status_data_shift_stage \
 (cliid,shiftindex)  \
 select	 cliid ,shiftindex \
 from pddw.lh_status_event  \ 
 where	shiftindex = shiftindex \
 and `+ proc_var_filter_list  +` group by 1,2 ;`
 snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
}
// 	--                 if  (select cast( proc_var_rt_max_dw_load_ts as timestamp) base_tbl_load_time ) > (select cast( proc_var_di_last_run_ts as timestamp)  as di_load_time) 
 //   --                        then
  //  --                      set proc_var_rt_max_dw_load_ts = proc_var_di_last_run_ts ;
  //  --                end if;

  else 
  {
  //--Step 1 a : Delete and Load the Stage table with list of Cliid and Shiftindex we are going to process
    
    snowflake.execute( {sqlText: "truncate " edw_stage.lh2_status_data_shift_stage;"} );
//--Step2: insert the data set into stage table based on the filter condition
var_sql_insert_stage_ds6 = ` insert into edw_stage.lh2_status_data_shift_stage \
 (cliid,shiftindex)  \ 
 select	 cliid ,shiftindex \  
 from pddw.lh_status_event   \
 where	shiftindex = shiftindex \ 
 and dw_modify_ts >=  timestamp '`+ proc_var_di_last_run_ts  +`'  group by 1,2 ` ; 
      //return proc_var_filter_list;
   snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );          
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_status_data"} );

//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `  insert into edw_stage.lh2_status_data ( shiftindex,\
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  eqmt,  \
  unit,  \
  operid,  \
  starttime,  \
  endtime,  \
  duration,  \
  category,  \
  reason,  \
  classification,  \
  comments,  \
  workorder,  \
  validevent,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   0,  \
   eqmt,  \
   unit,  \
   operid,  \
   starttime,  \
   endtime,  \
   duration,  \
   category,  \
   reason,  \
  classification,  \
   comments,  \
   workorder,  \
   validevent,  \
 system_version, \
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
 timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_status_data_etl  `; 

  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_status_data_c as tgt \
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 eqmt ,   \
 unit ,   \
 operid ,   \
 starttime ,   \
 endtime ,   \
 duration , \
 category ,  \
 reason ,   \
 classification ,     \
 comments ,   \
 workorder ,   \
 validevent ,    \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_status_data  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.eqmt = tgt.eqmt and \
stg.starttime = tgt.starttime ) \
\
WHEN MATCHED then \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 unit =  stg.unit ,  \
 operid =  stg.operid ,  \
 endtime =  stg.endtime ,  \
 duration =  stg.duration , \
 category =  stg.category ,  \
 reason =  stg.reason ,  \
 classification =  stg.classification ,   \
 comments =  stg.comments ,  \
 workorder =  stg.workorder ,  \
 validevent =  stg.validevent ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.eqmt ,  \
  stg.unit ,  \
  stg.operid ,  \
  stg.starttime ,  \
  stg.endtime ,  \
  stg.duration ,  \
  stg.category ,  \
  stg.reason ,  \
  stg.classification ,  \
  stg.comments ,  \
  stg.workorder ,  \
  stg.validevent ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`; 

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_status_data_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_status_data as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.eqmt = tgt.eqmt \
and stg.starttime = tgt.starttime  
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_status_data  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     ) `  ;  

//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = `delete from edw_target.lh2_status_data_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_status_data),`'+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_status_data_c_sp'`; 
snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
--------------------------------------------------------------------------------


create or replace procedure freeport.edw_etl.lh2_status_event_c_ds6_sp ("start_shift_date" string,"end_shift_date" string, "filter_cliid" string, "extract_mode" string)
    returns string
    language javascript
    strict
    execute as owner
    as
    $$


/**************************************************************************************************************************************************** 
* PK of collection table: cliid , shiftindex, ddbkey ( Is actually driving table's ID columns), starttime  \
* PURPOSE : Load the lh2_status_event_c collection table from  lh2_status_event_ds6_etl view based on dw_modify_ts of base table edw_target.lh2_shift_state_b \
*                       \
* Usage :   \
call edw_etl.lh2_status_event_c_ds6_sp ('1900-01-01' ,'9999-12-31' ,'16280,18176,18197,18404,19259,22362,32462,32578,32800,36616,36623,42468,1554590','FULL' ); \
call edw_etl.lh2_status_event_c_ds6_sp (null,null,null ,'Delta' ) \
 Procedure Steps: \
 Initial: Set the procedure run time  \
    Get the max of modify time from base table \
            check  job execution mode and define the filter  \
Step1: Delete the stage table \
Step2: insert the data set into stage table based on the filter condition \
Step3: merge into target table \
Step4: Capture the deleted rows \
Step5: Cleanup the target table  \
Step6: update the di job contorl entry ts base table \
* CREATE/CHANGE LOG :  \
* DATE                     MOD BY                               GCC                           DESC \
*-------------------------------------    \
*    2019-03-08       Kali D              Initial version \
"*   2019-07-31		 Anandhi P		 Included timestamp field (starttime_ts & endtime_ts) 
"*   2019-08-30      Sabarish S      	 Incremental load enhancement  (proc_var_filter_list  - logic change for delta.) 
"															Etl view is being filered with variable proc_var_filter_list which filters shiftid/shiftindex and site code 
"															Previous filter was made only with the driving table; 
"															If non-driving table gets refreshed there wont be any impact in this stored procedure  
"															so driving table will be up to date whereas non-driving table will not get latest data 
"															New filter includes all tables in it so that driving or non-driving table which ever get refreshed, there will be an impact in this stored procedure 
*    *****************************************************************************************************************************************************/   \

try {var proc_var_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast(current_timestamp(0) as varchar(30)),1,19)"}) ;
proc_var_dw_modify_ts1.next();
var proc_var_dw_modify_ts = proc_var_dw_modify_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts1 = snowflake.execute( {sqlText:" select substr(cast( DATEADD(minute, -24*60* lookback_days_dec,extract_high_ts) as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_event_c_ds6_sp'"} );
proc_var_di_last_run_ts1.next();
var proc_var_di_last_run_ts = proc_var_di_last_run_ts1.getColumnValue(1); 

var proc_var_di_last_run_ts_no_look_back1 = snowflake.execute( {sqlText:" select substr(cast( extract_high_ts  as varchar(30)),1,19)  from edw_target.di_job_control_entry_ts_base where job_name ='job_lh2_status_event_c_ds6_sp'"} );
proc_var_di_last_run_ts_no_look_back1.next();
var proc_var_di_last_run_ts_no_look_back = proc_var_di_last_run_ts_no_look_back1.getColumnValue(1);

var proc_var_ds6_base_max_dw_modify_ts1 = snowflake.execute( {sqlText: "select substr(cast( max(dw_modify_ts) as varchar(30)),1,19) from edw_target.lh2_shift_state_b "} ) ;
proc_var_ds6_base_max_dw_modify_ts1.next();
var proc_var_ds6_base_max_dw_modify_ts = proc_var_ds6_base_max_dw_modify_ts1.getColumnValue(1); 


if (extract_mode =='FULL') 
   
    {   
        //parameter https://docs.snowflake.net/manuals/sql-reference/stored-procedures-usage.html#restrictions-on-stored-procedures
        var proc_var_filter_list = ` shiftdate between '`+ start_shift_date +`' and '`+ end_shift_date + `' \
                                    and  cliid in  ( select cast(cliid_list.value as int)   from table (strtok_split_to_table('`+filter_cliid + `', ',' ) ) as cliid_list  ) ; ` ;
                    
//        return proc_var_filter_list;
         } 
   else  
{
            if  (proc_var_ds6_base_max_dw_modify_ts  > proc_var_di_last_run_ts ) 
                {
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-10-01 12:23:42
             proc_var_ds6_base_max_dw_modify_ts = proc_var_di_last_run_ts ;
             //return proc_var_ds6_base_max_dw_modify_ts; //--2019-09-03 12:35:20
             
                } 
                            
                            
                        
   //-- Sabarish S 2019-08-30 added as part of incremental load enhancement
//return proc_var_ds6_base_max_dw_modify_ts;"
proc_var_filter_list = ' ( shiftid, site_code) in \
(select shiftid,site_code from edw_target.lh2_shift_aux_b   where dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_state_b   where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union  \
select shiftid,site_code from edw_target.lh2_shift_reason_b   where  dw_modify_ts >= timestamp ''' || proc_var_ds6_base_max_dw_modify_ts  ||''' union  \
select shiftid,site_code from edw_target.lh2_shift_eqmt_b   where dw_modify_ts >= timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`' union \
select shiftid,site_code from edw_target.lh2_shift_oper_b   where dw_modify_ts >=  timestamp '`+ proc_var_ds6_base_max_dw_modify_ts +`') ;`;
        //return proc_var_filter_list;
            
       } 
//--Step1: Delete the stage table
 snowflake.execute( {sqlText: "truncate edw_stage.lh2_status_event_ds6;"} );


//--Step2: insert the data set into stage table based on the filter condition
   
var_sql_insert_stage_ds6 = `  insert into edw_stage.lh2_status_event_ds6 ( shiftindex ,\
  shiftdate,  \
  site_code,  \
  cliid,  \
  ddbkey,  \
  eqmt,  \
  unit,  \
  operid,  \
  starttime,  \
  starttime_ts,  \
  endtime,  \
  endtime_ts,  \
  duration,  \
  reason,  \
  status,  \
  category,  \
  comments,  \
  vevent,  \
  reasonlink,  \
  work_order_number,  \
  district_code,  \
  eqmtid_orig,  \
  loc,  \
  region,  \
  system_version,  \
  dw_logical_delete_flag,  \
  dw_modify_ts,  \
   dw_load_ts ) \
 select  shiftindex,    \
   shiftdate,  \
   site_code,  \
   cliid,  \
   ddbkey,  \
   eqmt,  \
   unit,  \
   operid,  \
   starttime,  \
   starttime_ts,  \
   endtime,  \
   endtime_ts,  \
   duration,  \
   reason,  \
   status,  \
   category,  \
   comments,  \
   vevent,  \
   reasonlink,  \
   work_order_number,  \
   district_code,  \
   eqmtid_orig,  \
   loc,  \
   region,  \
   'Dispatch 6' as system_version,\
 'N'as dw_logical_delete_flag,\
 timestamp '`+ proc_var_dw_modify_ts +`'  as dw_modify_ts,\
 timestamp '`+ proc_var_dw_modify_ts +`' as dw_load_ts from edw_etl_view.lh2_status_event_ds6_etl   \
where ` +  proc_var_filter_list ;

  snowflake.execute( {sqlText: var_sql_insert_stage_ds6 + ";"} );
//return var_sql_insert_stage_ds6; 
 //--Step3: merge into target table\\
  
var_sql_merge_target_ds6 = ` merge into edw_target.lh2_status_event_c as tgt \
using  \
(  \
select   \
shiftindex ,   \
 shiftdate ,   \
 site_code ,   \
 cliid ,   \
 ddbkey ,   \
 eqmt ,   \
 unit ,   \
 operid ,   \
 starttime ,   \
 starttime_ts ,  \
 endtime ,  \
 endtime_ts ,  \
 duration ,   \
 reason ,   \
 status ,   \
 category ,   \
 comments ,   \
 vevent ,   \
 reasonlink ,   \
 work_order_number ,   \
 district_code ,   \
 eqmtid_orig ,   \
 loc ,   \
 region ,   \
 system_version ,   \
 dw_logical_delete_flag ,   \
 dw_modify_ts ,   \
 dw_load_ts    \
from  edw_stage.lh2_status_event_ds6  \
) as stg  \
ON ( stg.shiftindex = tgt.shiftindex and  \
stg.cliid = tgt.cliid and  \
stg.ddbkey = tgt.ddbkey and \
stg.starttime = tgt.starttime ) \
\
WHEN MATCHED THEN \
UPDATE SET  \
shiftdate =  stg.shiftdate ,  \
 site_code =  stg.site_code ,  \
 eqmt =  stg.eqmt ,  \
 unit =  stg.unit ,  \
 operid =  stg.operid ,  \
 starttime_ts =  stg.starttime_ts ,  \
 endtime =  stg.endtime ,  \
 endtime_ts =  stg.endtime_ts ,  \
 duration =  stg.duration ,  \
 reason =  stg.reason ,  \
 status =  stg.status ,  \
 category =  stg.category ,  \
 comments =  stg.comments ,  \
 vevent =  stg.vevent ,  \
 reasonlink =  stg.reasonlink ,  \
 work_order_number =  stg.work_order_number ,  \
 district_code =  stg.district_code ,  \
 eqmtid_orig =  stg.eqmtid_orig ,  \
 loc =  stg.loc ,  \
 region =  stg.region ,  \
 system_version =  stg.system_version ,  \
 dw_logical_delete_flag =  stg.dw_logical_delete_flag ,  \
 dw_modify_ts =  stg.dw_modify_ts  \
\
WHEN NOT MATCHED THEN  \
INSERT VALUES ( \
 stg.shiftindex ,  \
  stg.shiftdate ,  \
  stg.site_code ,  \
  stg.cliid ,  \
  stg.ddbkey ,  \
  stg.eqmt ,  \
  stg.unit ,  \
  stg.operid ,  \
  stg.starttime ,  \
  stg.starttime_ts ,  \
  stg.endtime ,  \
  stg.endtime_ts ,  \
  stg.duration ,  \
  stg.reason ,  \
  stg.status ,  \
  stg.category ,  \
  stg.comments ,  \
  stg.vevent ,  \
  stg.reasonlink ,  \
  stg.work_order_number ,  \
  stg.district_code ,  \
  stg.eqmtid_orig ,  \
  stg.loc ,  \
  stg.region ,  \
  stg.system_version ,  \
  stg.dw_logical_delete_flag ,  \
  stg.dw_modify_ts ,  \
  stg.dw_load_ts)`;

  snowflake.execute( {sqlText: var_sql_merge_target_ds6 + ";"} ); 

// return var_sql_merge_target_ds6;

//--Step4: Capture the deleted rows\
var_sql_capture_logical_delete = ` update edw_target.lh2_status_event_c  as tgt  \
set dw_logical_delete_flag = 'Y' , \
       dw_modify_ts = cast('`+proc_var_dw_modify_ts +`' as timestamp(0))\
where  \
tgt.dw_logical_delete_flag <>'Y' \
and not exists \
      (select 1 \
      from edw_stage.lh2_status_event_ds6 as stg  \
      where stg.shiftindex = tgt.shiftindex  \
      and stg.cliid = tgt.cliid  \
      and stg.ddbkey = tgt.ddbkey  \
and stg.starttime = tgt.starttime  \
         )   \
and  exists \
     ( \
     select 'X' \
     from edw_stage.lh2_status_event_ds6  stg1  \
     where  stg1.shiftindex = tgt.shiftindex \
     and stg1.cliid = tgt.cliid \
     ) `  ;  
//return var_sql_capture_logical_delete;
     
snowflake.execute( {sqlText: var_sql_capture_logical_delete + ";"} ); 

//--Step5: Cleanup the target table 
var_sql_physical_delete = `delete from edw_target.lh2_status_event_c where dw_logical_delete_flag = 'Y' and dw_modify_ts <= DATEADD(day,-3,'`+proc_var_dw_modify_ts+ `')`;
//return var_sql_physical_delete;
snowflake.execute( {sqlText: var_sql_physical_delete + ";"} ); 

//--Step6: update the di job contorl entry ts base table 
var_sql_update_water_mark = ` update edw_target.di_job_control_entry_ts_base  \
set dw_load_ts =  cast('`+proc_var_dw_modify_ts +`' as timestamp(0)),\
extract_low_ts =  '`+ proc_var_di_last_run_ts_no_look_back +`' ,\
extract_high_ts =  coalesce ( (select max(dw_modify_ts) from edw_stage.lh2_status_event_ds6),'`+ proc_var_di_last_run_ts_no_look_back +`' )\
where job_name ='job_lh2_status_event_c_ds6_sp' `;

snowflake.execute( {sqlText: var_sql_update_water_mark + ";"} ); 

return "Succeeded.";   // Return a success/error indicator.
//  return var_sql_update_water_mark;
 
 }
catch (err)
    {
    return "Failed: " + err;   // Return a success/error indicator.
    }
    $$
; 
