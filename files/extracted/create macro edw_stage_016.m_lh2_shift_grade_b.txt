--------------------------------------------------------------------------------



"Request Text"

create  macro  edw_stage_016.m_lh2_shift_grade_b

as

(

merge into edw_target.lh2_shift_grade_b as tgt 

using 

( 

select  

 stg.orig_src_id ,  

 stg.site_code ,  

 stg.shift_grade_id ,  

 to_date(trim(substr(cast (stg.shiftid as varchar(30)),1,length(cast (stg.shiftid as varchar(30)))-3)),'yymmdd') as shiftdate ,  

 stg.dbprevious ,  

 stg.dbnext ,  

 stg.dbversion ,  

 stg.shiftid ,  

 coalesce(stg.shift_dbname,' ') as shift_dbname ,  

 stg.dbkey ,  

 coalesce(stg.fieldid,' ') as fieldid ,  

 stg.fieldloc ,  

 stg.fielddump ,  

 stg.fieldinv ,  

 stg.fieldspgr ,  

 stg.fieldload ,  

 stg.fieldblend ,  

 stg.fielddensity ,  

 stg.fieldthickness ,  

 stg.fieldshot ,  

 coalesce(stg.fieldproperty,' ') as fieldproperty ,  

 stg.src_change_id ,  

 stg.dw_logical_delete_flag ,  

 stg.dw_modify_ts ,  

 stg.dw_load_ts   

from   edw_stage_016.lh2_shift_grade as stg  

left outer join pddw.lh2_shift_info shift_info

on (stg.site_code = shift_info.site_code and 

stg.shiftid = shift_info.shiftid )   

where stg.change_type in ('I','U')

) as stg 

on ( stg.site_code = tgt.site_code and 

stg.shift_grade_id = tgt.shift_grade_id 

and stg.shiftid = tgt.shiftid )



when matched then 

update set 

 orig_src_id =  stg.orig_src_id , 

 shiftdate =  stg.shiftdate , 

 dbprevious =  stg.dbprevious , 

 dbnext =  stg.dbnext , 

 dbversion =  stg.dbversion , 

 shift_dbname =  stg.shift_dbname , 

 dbkey =  stg.dbkey , 

 fieldid =  stg.fieldid , 

 fieldloc =  stg.fieldloc , 

 fielddump =  stg.fielddump , 

 fieldinv =  stg.fieldinv , 

 fieldspgr =  stg.fieldspgr , 

 fieldload =  stg.fieldload , 

 fieldblend =  stg.fieldblend , 

 fielddensity =  stg.fielddensity , 

 fieldthickness =  stg.fieldthickness , 

 fieldshot =  stg.fieldshot , 

 fieldproperty =  stg.fieldproperty , 

 src_change_id =  stg.src_change_id , 

 dw_logical_delete_flag =  stg.dw_logical_delete_flag , 

 dw_modify_ts =  stg.dw_modify_ts 



when not matched then 

insert values (

  stg.orig_src_id , 

  stg.site_code , 

  stg.shift_grade_id , 

  stg.shiftdate , 

  stg.dbprevious , 

  stg.dbnext , 

  stg.dbversion , 

  stg.shiftid , 

  stg.shift_dbname , 

  stg.dbkey , 

  stg.fieldid , 

  stg.fieldloc , 

  stg.fielddump , 

  stg.fieldinv , 

  stg.fieldspgr , 

  stg.fieldload , 

  stg.fieldblend , 

  stg.fielddensity , 

  stg.fieldthickness , 

  stg.fieldshot , 

  stg.fieldproperty , 

  stg.src_change_id , 

  stg.dw_logical_delete_flag , 

  stg.dw_modify_ts , 

  stg.dw_load_ts);

--  step 2 ( for  deleted  records)

--  it  is based on incrementaly  loaded records in  stage

--  includes all the change type   ---   d

update  edw_target.lh2_shift_grade_b  

from 

( select stg.site_code , 

stg.shift_grade_id ,   

case  when stg.change_type in('D')     then

                      case 

                      when shift_info.shiftdate<(current_date-170) then 'A' 

                      else 'Y' ---handles  regular delete 

                      end               

    else 'U'---- for change type not in (i,u,d)

end as dw_logical_delete_flag,

stg.dw_modify_ts,  

stg.change_type 

from edw_stage_016.lh2_shift_grade stg 

left outer join pddw.lh2_shift_info shift_info

on (stg.site_code = shift_info.site_code and 

cast(substr(trim(stg.shift_grade_id),1,9) as integer) = shift_info.shiftid) 

) as stg 

set 

dw_logical_delete_flag = stg.dw_logical_delete_flag , 

dw_modify_ts = stg. dw_modify_ts 

where 

stg.site_code = edw_target.lh2_shift_grade_b.site_code and  

stg.shift_grade_id = edw_target.lh2_shift_grade_b.shift_grade_id

and  stg.change_type ='D' ;

);

--------------------------------------------------------------------------------



"Request Text"





create  macro edw_stage_016.m_lh2_shift_info_b

as

(

merge into edw_target.lh2_shift_info_b  as tgt 

using 

( 

select  

orig_src_id ,  

site_code ,  

shiftid ,  

cast(shiftstartdate as date) as shiftdate ,  -- changed from shiftdate to shiftstartdate  as we get native language description for month abbrevation on 10/30/2019

shiftdate as shiftdate_string, -- Included on 10/30/2019 to handle native language description for month abbrevation in hist_exproot  collection

coalesce(shiftname,' ') as shiftname ,  

coalesce(shift_dbname,' ') as shift_dbname ,  

shiftyear ,  

shiftmonth ,  

shiftday ,  

coalesce(shiftsuffix,' ') as shiftsuffix ,  

coalesce(fullshiftsuffix,' ') as fullshiftsuffix ,  

shiftstartsecsincemidnight ,  

shiftstarttimestamp ,  

shiftstartdate ,  

shiftstartdatetime ,  

--2019-11-04 Anandhi Changing the logic to fix the day-light saving issue

--(shiftstartdatetime + cast( shiftduration/3600 as interval hour )+ cast( shiftduration mod 3600 as interval second(4) )) shiftenddatetime,

case when shiftid = max(shiftid) over ( partition by site_code order by shiftid)

then (shiftstartdatetime + cast( shiftduration/3600 as interval hour )+ cast( shiftduration mod 3600 as interval second(4) ))

else max(shiftstartdatetime) over (partition by site_Code order by shiftid rows between 1 following  and 1 following)

end shiftenddatetime,

coalesce(fullshiftname,' ') as fullshiftname ,  

holiday ,  

coalesce(crew,' ') as crew ,  

shiftduration ,  

dw_logical_delete_flag ,  

dw_modify_ts ,  

dw_load_ts   

from  edw_stage_016.lh2_shift_info 

) as stg 

 on ( stg.site_code = tgt.site_code 

 and stg.shiftid = tgt.shiftid)



when matched then 

update 

set 

orig_src_id =  stg.orig_src_id , 

shiftdate =  stg.shiftdate , 

shiftdate_string =  stg.shiftdate_string , 

shiftname =  stg.shiftname , 

shift_dbname =  stg.shift_dbname , 

shiftyear =  stg.shiftyear , 

shiftmonth =  stg.shiftmonth , 

shiftday =  stg.shiftday , 

shiftsuffix =  stg.shiftsuffix , 

fullshiftsuffix =  stg.fullshiftsuffix , 

shiftstartsecsincemidnight =  stg.shiftstartsecsincemidnight ,

shiftstarttimestamp =  stg.shiftstarttimestamp , 

shiftstartdate =  stg.shiftstartdate , 

shiftstartdatetime =  stg.shiftstartdatetime , 

shiftenddatetime =  stg.shiftenddatetime , 

fullshiftname =  stg.fullshiftname , 

holiday =  stg.holiday , 

crew =  stg.crew , 

shiftduration =  stg.shiftduration , 

dw_logical_delete_flag =  stg.dw_logical_delete_flag , 

dw_modify_ts =  stg.dw_modify_ts 



when not matched then 

insert 

values (

stg.orig_src_id , 

stg.site_code , 

stg.shiftid , 

stg.shiftdate , 

stg.shiftdate_string , 

stg.shiftname , 

stg.shift_dbname , 

stg.shiftyear , 

stg.shiftmonth , 

stg.shiftday , 

stg.shiftsuffix , 

stg.fullshiftsuffix , 

stg.shiftstartsecsincemidnight , 

stg.shiftstarttimestamp , 

stg.shiftstartdate , 

stg.shiftstartdatetime , 

stg.shiftenddatetime , 

stg.fullshiftname , 

stg.holiday , 

stg.crew , 

stg.shiftduration , 

stg.dw_logical_delete_flag , 

stg.dw_modify_ts , 

stg.dw_load_ts);



update  edw_target.lh2_shift_info_b  

from 

     (

     select    

	 site_code,

	 shiftid, case 

                           when dw_load_ts <  (current_date-170)  then 'A' --archive

                           when dw_load_ts > (current_date - 170) then 'Y' ---handles  regular delete 

                           else 'N'  end  as dw_logical_delete_flag 

     from edw_target.lh2_shift_info_b 

     where dw_logical_delete_flag =  'N'  

     )  as src

set

dw_logical_delete_flag =   src.dw_logical_delete_flag

,dw_modify_ts =  ( select max(dw_modify_ts)  from edw_stage_016.lh2_shift_info)

where 

  src.site_code = edw_target.lh2_shift_info_b.site_code

 and src.shiftid=edw_target.lh2_shift_info_b.shiftid

 and edw_target.lh2_shift_info_b.dw_logical_delete_flag =  'N'  

 and not exists 

        (

        select 'X'  

        from edw_stage_016.lh2_shift_info stg 

        where stg.site_code = edw_target.lh2_shift_info_b.site_code

         and stg.shiftid = edw_target.lh2_shift_info_b.shiftid

        )

  and exists 

        (

        select 'X'  

        from edw_stage_016.lh2_shift_info stg 

        where stg.site_code = edw_target.lh2_shift_info_b.site_code

        );

);

